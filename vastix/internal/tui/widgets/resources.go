package widgets

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"
	"vastix/internal/colors"
	shared "vastix/internal/common"
	"vastix/internal/database"
	"vastix/internal/msg_types"
	"vastix/internal/tui/widgets/common"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	vast_client "github.com/vast-data/go-vast-client"
	"github.com/vast-data/go-vast-client/rest"
	"go.uber.org/zap"
)

var customResources = shared.NewSet[string](
	[]string{
		"profiles",
		"api_tokens [local database]",
		"user_keys [local database]",
		"ssh_connections",
		"vsettings",
	},
)

// Global widgets map to store auto-generated widgets
var generatedWidgets map[string]common.Widget
var globalFactory *WidgetFactory

type Resources struct {
	*BaseWidget
	factory *WidgetFactory
	msgChan chan tea.Msg
}

// InitializeWidgets initializes specific widgets one by one and returns the factory
func InitializeWidgets(db *database.Service, restClient *rest.UntypedVMSRest) (*WidgetFactory, error) {
	if restClient == nil {
		return nil, fmt.Errorf("rest client is nil")
	}

	factory := NewWidgetFactory(db)
	generatedWidgets = make(map[string]common.Widget)

	usersWidget := factory.CreateAndRegisterWidgetMust(restClient.Users, []string{"id", "name", "uid", "sid"})

	if baseWidget, ok := usersWidget.(*AutoGeneratedWidget); ok {
		// Get the extra widget group
		if extraGroup, ok := baseWidget.GetExtraWidget().(*ExtraWidgetGroup); ok {
			// Get all extra widgets (keyed by unique resourceType like "POST:/users/{id}/access_keys/")
			allExtraWidgets := extraGroup.GetAllExtraWidgets()

			// Attach callback to LOCAL user key generation (isNonLocal=false)
			if userKeyWidget, exists := allExtraWidgets["POST:/users/{id}/access_keys/"]; exists {
				if extraMethodWidget, ok := userKeyWidget.(*ExtraMethodWidget); ok {
					extraMethodWidget.SetAfterCreateCallback(createUserAccessKeyAfterCreateCallback(db, false))
				}
			}

			// Attach callback to NON-LOCAL user key generation (isNonLocal=true)
			if userKeyWidget, exists := allExtraWidgets["POST:/users/non_local_keys/"]; exists {
				if extraMethodWidget, ok := userKeyWidget.(*ExtraMethodWidget); ok {
					extraMethodWidget.SetAfterCreateCallback(createUserAccessKeyAfterCreateCallback(db, true))
				}
			}
		}
	}

	apiTokensWidget := factory.CreateAndRegisterWidgetMust(restClient.ApiTokens, []string{"id", "name", "owner", "expiry_date", "last_used", "revoked"})

	// Set after-create callback to save token to local database
	if baseWidget, ok := apiTokensWidget.(*AutoGeneratedWidget); ok {
		baseWidget.SetAfterCreateCallback(createApiTokenAfterCreateCallback(db))
	}

	// All auto-generated widgets in alphabetical order
	factory.CreateAndRegisterWidgetMust(restClient.ActiveDirectories, []string{"id", "ldap_id", "domain_name", "machine_account_name"})
	factory.CreateAndRegisterWidgetMust(restClient.Alarms, []string{"id", "severity", "event_type"})
	factory.CreateAndRegisterWidgetMust(restClient.Analytics, []string{"id", "title", "class_name", "object_types", "units"})
	factory.CreateAndRegisterWidgetMust(restClient.BasicSettings, []string{"capacity_base_10", "performance_base_10", "login_banner", "cluster_guid"})
	factory.CreateAndRegisterWidgetMust(restClient.BGPConfigs, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.BigCatalogConfigs, []string{"id", "name", "prefix", "state", "clone_type"})
	factory.CreateAndRegisterWidgetMust(restClient.BigCatalogIndexedColumns, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.BlockHosts, []string{"id", "name", "nqn", "tenant_name"})
	factory.CreateAndRegisterWidgetMust(restClient.BlockHostMappings, []string{"id", "guid", "created"})
	factory.CreateAndRegisterWidgetMust(restClient.CallhomeConfigs, []string{"id", "compress_method", "callhome_upload_destination", "bundle_interval"})
	factory.CreateAndRegisterWidgetMust(restClient.Capacities, []string{"keys", "sort_key", "time"})
	factory.CreateAndRegisterWidgetMust(restClient.Carriers, []string{"id", "name", "box_type", "carrier_type", "sw_version"})
	factory.CreateAndRegisterWidgetMust(restClient.Cboxes, []string{"id", "name", "uid", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.Certificates, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.ChallengeTokens, []string{"id", "name", "expiration_time"})
	factory.CreateAndRegisterWidgetMust(restClient.Clusters, []string{"id", "name", "state", "build", "bw"})
	factory.CreateAndRegisterWidgetMust(restClient.Cnodes, []string{"id", "name", "state", "bios_version", "build", "hostname"})
	factory.CreateAndRegisterWidgetMust(restClient.CnodeGroups, []string{"id", "name"})
	// TODO: error: code 400 — response body: { "database_name": "field required", "schema_name": "field required", "table_name": "field required" }
	//factory.CreateAndRegisterWidgetMust(restClient.Columns, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Configs, []string{"key", "value", "is_modified"})
	factory.CreateAndRegisterWidgetMust(restClient.Dboxes, []string{"id", "name", "arch_type", "box_vendor", "drive_type"})
	// TODO: error: resource not found on this server
	//factory.CreateAndRegisterWidgetMust(restClient.Deltas, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.Dnodes, []string{"id", "name", "state", "arch_type", "bios_version", "build", "hostname"})
	factory.CreateAndRegisterWidgetMust(restClient.Dns, []string{"id", "name", "domain_suffix", "vip"})
	factory.CreateAndRegisterWidgetMust(restClient.Dtrays, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Eboxes, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.EncryptedPaths, []string{"id", "path"})
	factory.CreateAndRegisterWidgetMust(restClient.EncryptionGroups, []string{"id", "crn", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.Envs, []string{"id", "name", "env_id", "cnode", "port", "silo_count"})
	factory.CreateAndRegisterWidgetMust(restClient.Events, []string{"id", "time", "severity", "event_type", "message"})
	factory.CreateAndRegisterWidgetMust(restClient.EventDefinitionConfigs, []string{"id", "critical_value", "info_value", "syslog_host", "syslog_port", "syslog_protocol", "webhook_method", "audit_logs_retention"})
	factory.CreateAndRegisterWidgetMust(restClient.EventDefinitions, []string{"id", "name", "event_type", "object_type", "severity"})
	factory.CreateAndRegisterWidgetMust(restClient.Fans, []string{"id", "name", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.Filesystems, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Folders, []string{"id", "path"})
	factory.CreateAndRegisterWidgetMust(restClient.GlobalSnapshotStreams, []string{"id", "name", "loanee_root_path"})
	factory.CreateAndRegisterWidgetMust(restClient.Groups, []string{"id", "name", "gid", "sid"})
	factory.CreateAndRegisterWidgetMust(restClient.IamRoles, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Indestructibility, []string{"id", "state", "is_locked", "title", "passwd_delay"})
	// TODO: error: Injection type was not provided
	//factory.CreateAndRegisterWidgetMust(restClient.Injections, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.IoData, []string{"data", "nodes_data", "connections", "timestamp", "min_timestamp"})
	factory.CreateAndRegisterWidgetMust(restClient.KafkaBrokers, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Kerberos, []string{"id", "realm"})
	factory.CreateAndRegisterWidgetMust(restClient.Ldaps, []string{"id", "domain_name", "binddn"})
	factory.CreateAndRegisterWidgetMust(restClient.Licenses, []string{"id", "name", "capacity", "period", "start_date", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.LocalProviders, []string{"id", "name", "assigned_tenants_preview", "guid", "managed_by"})
	factory.CreateAndRegisterWidgetMust(restClient.LocalS3Keys, []string{"id", "access_key", "enabled", "creation_time"})
	factory.CreateAndRegisterWidgetMust(restClient.ManagedApplications, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Managers, []string{"id", "username", "is_active", "tenant"})
	factory.CreateAndRegisterWidgetMust(restClient.Metrics, []string{"id", "class_name", "fqn", "object_types", "units", "title"})
	factory.CreateAndRegisterWidgetMust(restClient.Modules, []string{"id", "env", "module_type", "silo_id", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.Monitors, []string{"id", "name", "granularity", "metrics_exposure", "monitor_type", "time_frame"})
	factory.CreateAndRegisterWidgetMust(restClient.Nics, []string{"id", "name", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.NicPorts, []string{"id", "name", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.Nis, []string{"id", "name", "domain_name"})
	factory.CreateAndRegisterWidgetMust(restClient.Nvrams, []string{"id", "name", "arch_type", "box_type", "state", "fw_version", "model"})
	factory.CreateAndRegisterWidgetMust(restClient.Oidcs, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Permissions, []string{"id", "name", "permission_type", "realm"})
	factory.CreateAndRegisterWidgetMust(restClient.Ports, []string{"id", "name", "state"})
	// TODO: error: { "database_name": "field required", "schema_name": "field required", "table_name": "field required" }
	//factory.CreateAndRegisterWidgetMust(restClient.Projections, []string{"id", "name"})
	//factory.CreateAndRegisterWidgetMust(restClient.ProjectionColumns, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.PrometheusMetrics, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.ProtectedPaths, []string{"id", "name", "protection_policy_name"})
	factory.CreateAndRegisterWidgetMust(restClient.ProtectionPolicies, []string{"id", "name", "internal", "is_local", "is_on_schedule", "is_sync_replication"})
	factory.CreateAndRegisterWidgetMust(restClient.Psus, []string{"id", "name", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.QosPolicies, []string{"id", "name", "policy_type", "is_default", "tenant_name"})
	// TODO: error: The requested resource was not found
	//factory.CreateAndRegisterWidgetMust(restClient.QuotaEntityInfos, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.Quotas, []string{"id", "name", "path", "tenant_name"})
	factory.CreateAndRegisterWidgetMust(restClient.Racks, []string{"id", "name", "available_capacity", "guid", "number_of_units"})
	factory.CreateAndRegisterWidgetMust(restClient.Realms, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.ReplicationPeers, []string{"id", "name", "peer_name", "pool_name", "leading_vip", "is_local", "remote_vip_range"})
	factory.CreateAndRegisterWidgetMust(restClient.ReplicationPolicies, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.ReplicationRestorePoints, []string{"id", "name", "state", "stream_name", "upload_finish_time", "upload_start_time"})
	factory.CreateAndRegisterWidgetMust(restClient.ReplicationStreams, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Roles, []string{"id", "name", "tenant", "is_default"})
	factory.CreateAndRegisterWidgetMust(restClient.S3Keys, []string{"id", "access_key"})
	factory.CreateAndRegisterWidgetMust(restClient.S3LifeCycleRules, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.S3Policies, []string{"id", "name", "enabled", "tenant_name"})
	factory.CreateAndRegisterWidgetMust(restClient.S3replicationPeers, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Schemas, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.SettingDiffs, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.SnapshotPolicies, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Snapshots, []string{"id", "name", "path", "clone_id"})
	factory.CreateAndRegisterWidgetMust(restClient.Ssds, []string{"id", "name", "arch_type", "carrier_id", "dbox_id", "model"})
	//factory.CreateAndRegisterWidgetMust(restClient.SubnetManagers, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.SupportBundles, []string{"id", "name", "state"})
	factory.CreateAndRegisterWidgetMust(restClient.SupportedDrivers, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.Switches, []string{"id", "name", "state"})
	// TODO: error: field required
	//factory.CreateAndRegisterWidgetMust(restClient.Tables, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMustWithExclusions(restClient.Tenants, []string{"id", "name", "client_ip_ranges"}, []string{"client_ip_ranges"})
	// TODO: error: field required
	//factory.CreateAndRegisterWidgetMust(restClient.Topics, []string{"id", "name"})
	factory.CreateAndRegisterWidgetMust(restClient.UserQuotas, []string{"id"})
	// TODO: error: The requested resource was not found
	//factory.CreateAndRegisterWidgetMust(restClient.VastAuditLogs, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.VastDb, []string{"id"})
	factory.CreateAndRegisterWidgetMust(restClient.Versions, []string{"id", "name", "build", "os_version", "sys_version", "status"})
	factory.CreateAndRegisterWidgetMust(restClient.ViewPolicies, []string{"id", "name", "access_flavor", "flavor"})
	factory.CreateAndRegisterWidgetMust(restClient.Views, []string{"id", "name", "path", "policy", "protocols", "tenant_name"})
	factory.CreateAndRegisterWidgetMust(restClient.Vips, []string{"id", "ip", "cnode", "tenant_id", "hostname"})
	factory.CreateAndRegisterWidgetMustWithExclusions(restClient.VipPools, []string{"id", "role", "name", "ip_ranges", "tenant_name"}, []string{"ip_ranges"})
	factory.CreateAndRegisterWidgetMust(restClient.Vms, []string{"id", "name", "mgmt_vip", "sw_version", "build"})
	factory.CreateAndRegisterWidgetMust(restClient.Volumes, []string{"id", "name", "size", "tenant_name", "subsystem_name", "qos_policy"})
	factory.CreateAndRegisterWidgetMust(restClient.VpnTunnels, []string{"id", "name", "state"})

	// Store globally for Resources widget to access
	globalFactory = factory

	return factory, nil
}

// GetGeneratedWidget returns a generated widget by name
func GetGeneratedWidget(name string) (common.Widget, bool) {
	widget, ok := generatedWidgets[name]
	if ok {
		return widget, true
	}

	for key, widget := range generatedWidgets {
		if strings.EqualFold(key, name) {
			return widget, true
		}
	}

	return nil, false
}

// NewResources creates a new resources widget
func NewResources(db *database.Service, msgChan chan tea.Msg) common.Widget {
	resourceType := "resources"
	listHeaders := []string{"type"}

	keyRestrictions := &common.NavigatorKeyRestrictions{
		Main: common.KeyRestrictions{
			NotAllowedListKeys: []string{"d"}, // Block extra actions in main list mode
		},
		Extra: common.NewDefaultKeyRestrictions(), // No restrictions for extra widgets
	}

	widget := &Resources{
		BaseWidget: NewBaseWidget(db, listHeaders, nil, resourceType, nil, keyRestrictions),
		factory:    globalFactory,
		msgChan:    msgChan,
	}

	widget.SetParentForBaseWidget(widget, false)
	return widget
}

// GetAllWidgets returns all available widgets (custom + generated)
func (r *Resources) GetAllWidgets() map[string]common.Widget {
	allWidgets := make(map[string]common.Widget)

	// Add Profile widget (always available)
	profileWidget := NewProfile(r.db, r.msgChan)
	allWidgets[profileWidget.GetResourceType()] = profileWidget

	// Add ApiTokens from Local Database widget (always available)
	// Extract extra widgets from the auto-generated apitokens widget if available
	var apiTokensExtraWidgets []common.ExtraWidget
	if apiTokensAutoWidget, ok := generatedWidgets["apitokens"]; ok {
		if extraGetter, ok := apiTokensAutoWidget.(interface{ GetExtraWidgets() []common.ExtraWidget }); ok {
			apiTokensExtraWidgets = extraGetter.GetExtraWidgets()
		}
	}

	apiTokensLocalDbWidget := NewApiTokensFromLocalDb(r.db, r.msgChan, apiTokensExtraWidgets)
	allWidgets[apiTokensLocalDbWidget.GetResourceType()] = apiTokensLocalDbWidget

	// Add UserKeys from Local Database widget (always available)
	userKeysLocalDbWidget := NewUserKeysFromLocalDb(r.db, r.msgChan)
	allWidgets[userKeysLocalDbWidget.GetResourceType()] = userKeysLocalDbWidget

	// Add SSH Connections widget (always available)
	sshConnectionsWidget := NewSshConnections(r.db, r.msgChan)
	allWidgets[sshConnectionsWidget.GetResourceType()] = sshConnectionsWidget

	// Add VSettings widget (always available)
	vsettingsWidget := NewVSettingsWidget(r.db)
	allWidgets[vsettingsWidget.GetResourceType()] = vsettingsWidget

	// Add Resources widget itself
	allWidgets["resources"] = r

	// Add all generated widgets from factory (already using clean keys)
	for key, widget := range generatedWidgets {
		allWidgets[key] = widget
	}

	return allWidgets
}

func (r *Resources) SetListData() tea.Msg {
	return r.setListDataInternal()
}

// SetListDataWithContext overrides BaseWidget to ignore context since Resources doesn't need API calls
func (r *Resources) SetListDataWithContext(_ context.Context) tea.Msg {
	return r.setListDataInternal()
}

// setListDataInternal contains the actual logic for setting list data
func (r *Resources) setListDataInternal() tea.Msg {
	var supportedResources []string

	// Add custom resources first (always available)
	supportedResources = append(supportedResources, customResources.ToOrderedSlice()...)

	// Add resources from factory if available
	// Check if globalFactory has been initialized since widget creation
	if globalFactory != nil {
		r.factory = globalFactory // Update reference to current factory
		supportedResources = append(supportedResources, r.factory.GetSupportedResources()...)
	}

	// Sort alphabetically, but keep "profiles" first and "ssh_connections" second (both not sortable)
	var sortedResources []string
	var otherResources []string

	for _, resource := range supportedResources {
		if customResources.Contains(resource) {
			continue
		}
		otherResources = append(otherResources, resource)
	}

	sort.Strings(otherResources)

	sortedResources = append(sortedResources, customResources.ToOrderedSlice()...)
	sortedResources = append(sortedResources, otherResources...)

	// Convert to data format
	data := make([][]string, 0, len(sortedResources))
	for _, resource := range sortedResources {
		data = append(data, []string{resource})
	}

	r.ListAdapter.SetListData(data, r.GetFuzzyListSearchString())
	return msg_types.MockMsg{}
}

func (Resources) GetNotAllowedNavigatorModes() []common.NavigatorMode {
	return []common.NavigatorMode{
		common.NavigatorModeCreate,
		common.NavigatorModeDetails,
	}
}

func (r *Resources) GetKeyBindings() []common.KeyBinding {
	// Only list mode keybindings, no create/details/delete
	keyBindings := []common.KeyBinding{
		{Key: "</>", Desc: "search", Generic: true},
		{Key: "<↑/↓>", Desc: "navigate"},
		{Key: "<enter>", Desc: "select"},
	}
	return keyBindings
}

// Select implements the Selectable interface for resource type switching
func (r *Resources) Select(selectedRowData common.RowData) (tea.Cmd, error) {
	if selectedRowData.Len() == 0 {
		return nil, fmt.Errorf("no resource selected")
	}

	r.log.Debug("Resource selection requested",
		zap.Any("rowData", selectedRowData),
		zap.Int("dataLength", selectedRowData.Len()))

	// Extract resource type from the row data
	resourceType := strings.TrimSpace(strings.ToLower(selectedRowData.GetID()))
	if resourceType == "" {
		return nil, fmt.Errorf("invalid resource data: missing type")
	}

	r.log.Info("Switching to resource type", zap.String("resourceType", resourceType))

	// Return a command to switch resource type
	return func() tea.Msg {
		return msg_types.SetResourceTypeMsg{ResourceType: resourceType}
	}, nil
}

// RenderRow implements the RenderRow interface for custom resource row styling
func (r *Resources) RenderRow(rowData common.RowData, isSelected bool, colWidth int) []string {
	if rowData.Len() == 0 {
		return []string{}
	}

	// Get ordered slice from RowData
	styledRow := rowData.ToSlice()

	// Apply styling to "profiles" and "ssh_connections" entries
	for i, cell := range styledRow {
		lowerCell := strings.TrimSpace(strings.ToLower(cell))
		if customResources.Contains(lowerCell) && !isSelected {
			greenStyle := lipgloss.NewStyle().
				Foreground(colors.GreenTerm) // Green color (same as [active])
			styledRow[i] = greenStyle.Render(cell)
		}
	}

	return styledRow
}

// createApiTokenAfterCreateCallback creates a callback function that saves API tokens to the local database
// This is called after successfully creating an API token via the REST API
func createApiTokenAfterCreateCallback(db *database.Service) common.AfterCreateFunc {
	return func(record vast_client.Record, parentRowData common.RowData) (tea.Msg, error) {
		// Note: parentRowData is not used for API tokens as they don't have a parent resource
		// Get active REST client
		rest, err := getActiveRest(db)
		if err != nil {
			return nil, fmt.Errorf("failed to get REST client: %w", err)
		}

		// Get active profile
		activeProfile, err := db.GetActiveProfile()
		if err != nil {
			return nil, fmt.Errorf("failed to get active profile: %w", err)
		}

		// Extract ID from initial record to fetch complete details
		tokenID, ok := record["id"].(string)
		if !ok || tokenID == "" {
			return nil, fmt.Errorf("missing or invalid id field in record")
		}

		// Extract token string from initial record
		token, ok := record["token"].(string)
		if !ok || token == "" {
			return nil, fmt.Errorf("missing or invalid token field in record")
		}

		// Get complete token details by ID
		fullTokenRecord, err := rest.ApiTokens.GetById(tokenID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch complete token details: %w", err)
		}

		// Extract data from complete record with nil checks
		owner, ok := fullTokenRecord["owner"].(string)
		if !ok || owner == "" {
			return nil, fmt.Errorf("missing or invalid owner field in complete record")
		}

		name, ok := fullTokenRecord["name"].(string)
		if !ok || name == "" {
			return nil, fmt.Errorf("missing or invalid name field in complete record")
		}

		createdStr, ok := fullTokenRecord["created"].(string)
		if !ok || createdStr == "" {
			return nil, fmt.Errorf("missing or invalid created field in complete record")
		}

		// Get owner details from managers
		ownerRecord, err := rest.Managers.Get(params{"username": owner})
		if err != nil {
			return nil, fmt.Errorf("failed to get owner details: %w", err)
		}
		ownerID := ownerRecord.RecordID()

		// Parse created timestamp
		vastCreated, err := time.Parse(time.RFC3339, createdStr)
		if err != nil {
			return nil, fmt.Errorf("failed to parse created timestamp: %w", err)
		}

		// Parse expiry date (can be null)
		var expireDate *time.Time
		if expiryVal, exists := fullTokenRecord["expiry_date"]; exists && expiryVal != nil {
			if expiryStr, ok := expiryVal.(string); ok && expiryStr != "" {
				if parsed, err := time.Parse(time.RFC3339, expiryStr); err == nil {
					expireDate = &parsed
				}
			}
		}

		// Create local database record
		apiToken := &database.ApiToken{
			ProfileID:   activeProfile.ID,
			TokenID:     tokenID,
			Token:       token, // Use the actual token string from initial record
			Name:        name,
			Owner:       owner,
			OwnerID:     uint(ownerID),
			ExpireDate:  expireDate,
			VastCreated: vastCreated,
		}

		// Save to database
		if err := db.CreateApiToken(apiToken); err != nil {
			return nil, fmt.Errorf("failed to save API token to database: %w", err)
		}

		// Return nil to indicate success - BaseWidget will handle content display and mode switching
		return nil, nil
	}
}
