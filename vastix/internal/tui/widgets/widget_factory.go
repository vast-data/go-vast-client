package widgets

import (
	"fmt"
	"net/http"
	"strings"
	"unicode"

	"vastix/internal/database"
	"vastix/internal/msg_types"
	"vastix/internal/tui/widgets/common"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/openapi_schema"
	"github.com/vast-data/go-vast-client/rest"
)

// WidgetFactory creates widgets based on resource introspection
type WidgetFactory struct {
	db                 *database.Service
	rest               *rest.UntypedVMSRest
	supportedResources []string
}

// NewWidgetFactory creates a new widget factory
func NewWidgetFactory(db *database.Service, rest *rest.UntypedVMSRest) *WidgetFactory {
	return &WidgetFactory{
		db:                 db,
		rest:               rest,
		supportedResources: []string{}, // Will be populated as widgets are created
	}
}

// GetSupportedResources returns the list of supported resource names
func (f *WidgetFactory) GetSupportedResources() []string {
	return f.supportedResources
}

// AddSupportedResource adds a resource name to the supported list
func (f *WidgetFactory) addSupportedResource(name string) {
	f.supportedResources = append(f.supportedResources, name)
}

// CreateWidget creates a widget from an API resource
func (f *WidgetFactory) CreateWidget(resource core.VastResourceAPIWithContext, listHeaders []string) (common.Widget, error) {
	// Extract resource info using introspection
	resourceType := resource.GetResourceType()
	resourcePath := resource.GetResourcePath()
	crudHints := core.GetCRUDHintsFromResource(resource)
	extraMethods := core.DiscoverExtraMethodsFromResource(resource)

	// Clean resource type for use as widget key (remove slashes)
	// resourcePath is "/users/", we want "users"
	cleanResourceType := strings.Trim(resourcePath, "/")

	// Use default headers if none provided
	if listHeaders == nil {
		listHeaders = []string{"id", "name"}
	}

	// Create form hints
	formHints := &common.FormHints{
		SchemaRef: common.NewSchemaReference(http.MethodPost, resourcePath, "", ""),
	}

	// Create extra widgets from extra methods
	extraNav := f.createExtraWidgetsFromMethods(resourceType, resourcePath, extraMethods)

	// Log discovered extra methods for debugging
	fmt.Printf("[WidgetFactory] Discovered %d extra methods for %s\n", len(extraMethods), resourceType)
	if len(extraMethods) > 0 {
		for _, method := range extraMethods {
			fmt.Printf("  - %s (%s) -> %s\n", method.Name, method.HTTPVerb, method.Path)
		}
	}
	fmt.Printf("[WidgetFactory] Created %d extra widgets from %d methods\n", len(extraNav), len(extraMethods))
	fmt.Printf("[WidgetFactory] Passing %d extra widgets to NewBaseWidget\n", len(extraNav))

	// Create the auto widget with cleanResourceType as the key
	widget := &AutoGeneratedWidget{
		BaseWidget:   NewBaseWidget(f.db, listHeaders, formHints, cleanResourceType, extraNav, nil),
		resource:     resource,
		resourceType: resourceType,
		resourcePath: resourcePath,
		crudHints:    crudHints,
		restClient:   f.rest,
	}

	// Set parent reference
	widget.SetParentForBaseWidget(widget, false)

	// Set allowed/disallowed modes based on CRUD hints
	widget.allowedModes = crudHintsToNavigatorModes(crudHints)
	widget.disallowedModes = crudHintsToDisallowedModes(crudHints)

	// Add Extra mode if there are extra widgets
	if len(extraNav) > 0 {
		widget.allowedModes = append(widget.allowedModes, common.NavigatorModeExtra)
		fmt.Printf("[WidgetFactory] Added NavigatorModeExtra to allowed modes (has %d extra widgets)\n", len(extraNav))
	}

	return widget, nil
}

// CreateAllWidgets is intentionally removed - create widgets one by one instead.
// Use CreateWidget() for each resource individually for better control and safety.

// createExtraWidgetsFromMethods creates extra navigation widgets from extra methods
func (f *WidgetFactory) createExtraWidgetsFromMethods(resourceType, resourcePath string, methods []core.ExtraMethodInfo) []common.ExtraWidget {
	var extraWidgets []common.ExtraWidget

	for _, method := range methods {
		extraWidget := f.createExtraWidget(resourceType, method)
		if extraWidget != nil {
			extraWidgets = append(extraWidgets, extraWidget)
		}
	}

	return extraWidgets
}

// createExtraWidget creates an extra widget from an extra method info
func (f *WidgetFactory) createExtraWidget(parentResourceType string, method core.ExtraMethodInfo) common.ExtraWidget {
	// Determine HTTP method from the verb
	httpMethod := method.HTTPVerb

	// Create form hints for the extra method
	formHints := &common.FormHints{
		SchemaRef: common.NewSchemaReference(httpMethod, method.Path, "", ""),
	}

	// Determine list headers
	listHeaders := []string{"id", "name"}

	// Create display name from method name (e.g., "UserAccessKeys_POST" -> "User Access Keys")
	displayName := formatDisplayName(method.Name)

	// Fetch and cache summary from OpenAPI schema
	summary, err := openapi_schema.GetOperationSummary(method.HTTPVerb, method.Path)
	if err != nil || summary == "" {
		// Fallback to formatted display name if summary not found
		summary = displayName
	}

	// Create the extra widget
	extraWidget := &ExtraMethodWidget{
		BaseWidget:  NewBaseWidget(f.db, listHeaders, formHints, method.Path, nil, nil),
		methodInfo:  method,
		displayName: displayName,
		summary:     summary, // Cached summary from OpenAPI
	}

	extraWidget.SetParentForBaseWidget(extraWidget, false)

	return extraWidget
}

// formatDisplayName converts a method name to a display name
// e.g., "UserAccessKeys_POST" -> "User Access Keys"
func formatDisplayName(methodName string) string {
	// Remove HTTP verb suffix
	methodName = strings.TrimSuffix(methodName, "_GET")
	methodName = strings.TrimSuffix(methodName, "_POST")
	methodName = strings.TrimSuffix(methodName, "_PATCH")
	methodName = strings.TrimSuffix(methodName, "_PUT")
	methodName = strings.TrimSuffix(methodName, "_DELETE")

	// Insert spaces before uppercase letters
	var result []rune
	for i, r := range methodName {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, ' ')
		}
		result = append(result, r)
	}

	return string(result)
}

// AutoGeneratedWidget is a widget that was auto-generated from resource introspection
type AutoGeneratedWidget struct {
	*BaseWidget
	resource        core.VastResourceAPIWithContext
	resourceType    string
	resourcePath    string
	crudHints       core.ResourceOps
	restClient      *rest.UntypedVMSRest
	allowedModes    []common.NavigatorMode
	disallowedModes []common.NavigatorMode
}

// API returns the API interface for this widget (implements VastResourceGetter)
func (w *AutoGeneratedWidget) API(rest *VMSRest) VastResourceAPI {
	// Return the actual resource that was passed to CreateWidget
	return w.resource
}

// String returns a string representation of the widget showing the resource name
func (w *AutoGeneratedWidget) String() string {
	// Capitalize first letter of resource type
	resourceName := w.resourceType
	if len(resourceName) > 0 {
		resourceName = strings.ToUpper(resourceName[:1]) + resourceName[1:]
	}
	return fmt.Sprintf("%s (AutoGeneratedWidget)", resourceName)
}

// GetAllowedNavigatorModes returns allowed navigator modes based on CRUD hints
func (w *AutoGeneratedWidget) GetAllowedNavigatorModes() []common.NavigatorMode {
	if len(w.allowedModes) > 0 {
		return w.allowedModes
	}
	return w.BaseWidget.GetAllowedNavigatorModes()
}

// GetNotAllowedNavigatorModes returns disallowed navigator modes
func (w *AutoGeneratedWidget) GetNotAllowedNavigatorModes() []common.NavigatorMode {
	return w.disallowedModes
}

// GetDisplayName returns a user-friendly display name
func (w *AutoGeneratedWidget) GetDisplayName() string {
	// Convert resource type to Title Case with spaces
	// e.g., "users" -> "Users", "vip_pools" -> "Vip Pools"
	return formatDisplayName(w.resourceType)
}

// ExtraMethodWidget represents a widget for an extra method
type ExtraMethodWidget struct {
	*BaseWidget
	methodInfo  core.ExtraMethodInfo
	displayName string
	summary     string // Cached summary from OpenAPI schema
}

// API returns the API interface for this extra widget
func (w *ExtraMethodWidget) API(rest *VMSRest) VastResourceAPI {
	// For extra methods, we need to return a resource that can handle the extra method
	// This is a placeholder - in practice, you'd need to determine the parent resource
	// from the method path or have it passed in during creation
	return nil // TODO: Implement proper parent resource lookup
}

// GetDisplayName returns the display name for this extra method
func (w *ExtraMethodWidget) GetDisplayName() string {
	return w.displayName
}

// GetHTTPMethod returns the HTTP method (verb) for this extra method
func (w *ExtraMethodWidget) GetHTTPMethod() string {
	return w.methodInfo.HTTPVerb
}

// GetSummary returns the cached operation summary from OpenAPI schema
func (w *ExtraMethodWidget) GetSummary() string {
	return w.summary
}

// InitialExtraMode returns the initial mode based on HTTP method
func (w *ExtraMethodWidget) InitialExtraMode() common.ExtraNavigatorMode {
	// Determine initial mode based on HTTP verb
	// For all methods that accept input (POST, PATCH, PUT), start in create mode to show the form
	// After submission, we'll switch to details mode to show the response
	switch w.methodInfo.HTTPVerb {
	case "GET":
		// GET methods typically don't have request bodies, but may have query params
		// Start in create mode so query params can be entered
		return common.ExtraNavigatorModeCreate
	case "POST", "PATCH", "PUT":
		// These methods accept request bodies, so start in create mode to show the form
		return common.ExtraNavigatorModeCreate
	case "DELETE":
		// DELETE may or may not have a request body, start with prompt
		return common.ExtraNavigatorModePrompt
	default:
		return common.ExtraNavigatorModeCreate
	}
}

// ViewDetails implements the DetailsWidget interface for ExtraMethodWidget
// Shows the response from the API call
func (w *ExtraMethodWidget) ViewDetails() string {
	// Use the inherited BaseWidget.ViewDetails which shows DetailsAdapter content
	// The details will be populated after the API call completes
	return w.BaseWidget.ViewDetails()
}

// ViewCreateForm implements the CreateWidget interface for ExtraMethodWidget
// Shows the input form for the extra method based on OpenAPI schema
func (w *ExtraMethodWidget) ViewCreateForm() string {
	// Use the inherited BaseWidget.ViewCreateForm which renders the form from FormHints
	// The FormHints were set during widget creation with the OpenAPI schema reference
	return w.BaseWidget.ViewCreateForm()
}

// ViewList implements the ListWidget interface for ExtraMethodWidget
// For extra methods, list mode is not typically used, but we provide it for completeness
func (w *ExtraMethodWidget) ViewList() string {
	// Use the inherited BaseWidget.ViewList
	return w.BaseWidget.ViewList()
}

// CreateFromInputs executes the extra method API call with the provided inputs
func (w *ExtraMethodWidget) CreateFromInputs(inputs common.Inputs) (tea.Cmd, error) {
	// Get the parent resource to access REST client
	// The parent should be an AutoGeneratedWidget that has the parent resource
	parentWidget, ok := w.parent.(*AutoGeneratedWidget)
	if !ok {
		return nil, fmt.Errorf("parent widget is not an AutoGeneratedWidget, cannot execute API call")
	}

	// Validate inputs before conversion
	if err := inputs.Validate(); err != nil {
		return nil, err
	}

	// Convert inputs to request parameters (core.Params type)
	params := inputs.ToParams()

	// Create the API execution command
	cmd := func() tea.Msg {
		ctx := parentWidget.restClient.GetCtx()

		// Execute the API call based on HTTP method
		// Try RecordSet first (most common for list endpoints), then fall back to Record
		var result interface{}
		var err error

		switch w.methodInfo.HTTPVerb {
		case http.MethodGet:
			// For GET, try RecordSet first (most endpoints return lists)
			resultSet, errSet := core.Request[core.RecordSet](
				ctx,
				parentWidget.resource,
				http.MethodGet,
				w.methodInfo.Path,
				params, // query params
				nil,    // no body
			)
			if errSet != nil && strings.Contains(errSet.Error(), "got core.Record, expected core.RecordSet") {
				// Try as single Record instead
				resultRec, errRec := core.Request[core.Record](
					ctx,
					parentWidget.resource,
					http.MethodGet,
					w.methodInfo.Path,
					params,
					nil,
				)
				if errRec != nil {
					err = errRec
				} else {
					result = resultRec
				}
			} else if errSet != nil {
				err = errSet
			} else {
				result = resultSet
			}

		case http.MethodPost, http.MethodPatch, http.MethodPut:
			// For POST/PATCH/PUT, try Record first (most common for create/update)
			resultRec, errRec := core.Request[core.Record](
				ctx,
				parentWidget.resource,
				w.methodInfo.HTTPVerb,
				w.methodInfo.Path,
				nil,    // no query params
				params, // body
			)
			if errRec != nil && strings.Contains(errRec.Error(), "got core.RecordSet, expected core.Record") {
				// Try as RecordSet instead
				resultSet, errSet := core.Request[core.RecordSet](
					ctx,
					parentWidget.resource,
					w.methodInfo.HTTPVerb,
					w.methodInfo.Path,
					nil,
					params,
				)
				if errSet != nil {
					err = errSet
				} else {
					result = resultSet
				}
			} else if errRec != nil {
				err = errRec
			} else {
				result = resultRec
			}

		case http.MethodDelete:
			// For DELETE, try Record first
			resultRec, errRec := core.Request[core.Record](
				ctx,
				parentWidget.resource,
				http.MethodDelete,
				w.methodInfo.Path,
				nil,    // no query params
				params, // body
			)
			if errRec != nil && strings.Contains(errRec.Error(), "got core.RecordSet, expected core.Record") {
				// Try as RecordSet instead
				resultSet, errSet := core.Request[core.RecordSet](
					ctx,
					parentWidget.resource,
					http.MethodDelete,
					w.methodInfo.Path,
					nil,
					params,
				)
				if errSet != nil {
					err = errSet
				} else {
					result = resultSet
				}
			} else if errRec != nil {
				err = errRec
			} else {
				result = resultRec
			}

		default:
			err = fmt.Errorf("unsupported HTTP method: %s", w.methodInfo.HTTPVerb)
		}

		if err != nil {
			return msg_types.ErrorMsg{Err: err}
		}

		// Return the result as details content
		// The mode will be switched to details by the message handler
		return msg_types.DetailsContentMsg{
			Content:      result,
			ResourceType: w.methodInfo.Path,
			Error:        nil,
		}
	}

	return cmd, nil
}

// Helper functions for CRUD hints to navigator modes conversion
func crudHintsToNavigatorModes(hints core.ResourceOps) []common.NavigatorMode {
	var modes []common.NavigatorMode

	if hints&core.L != 0 {
		modes = append(modes, common.NavigatorModeList)
	}
	if hints&core.R != 0 {
		modes = append(modes, common.NavigatorModeDetails)
	}
	if hints&core.C != 0 || hints&core.U != 0 {
		// Both Create and Update use NavigatorModeCreate
		modes = append(modes, common.NavigatorModeCreate)
	}
	if hints&core.D != 0 {
		modes = append(modes, common.NavigatorModeDelete)
	}

	return modes
}

func crudHintsToDisallowedModes(hints core.ResourceOps) []common.NavigatorMode {
	var disallowed []common.NavigatorMode

	if hints&core.L == 0 {
		disallowed = append(disallowed, common.NavigatorModeList)
	}
	if hints&core.R == 0 {
		disallowed = append(disallowed, common.NavigatorModeDetails)
	}
	if hints&core.C == 0 && hints&core.U == 0 {
		// Disallow create mode only if both C and U are not supported
		disallowed = append(disallowed, common.NavigatorModeCreate)
	}
	if hints&core.D == 0 {
		disallowed = append(disallowed, common.NavigatorModeDelete)
	}

	return disallowed
}
