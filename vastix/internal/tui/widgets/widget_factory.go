package widgets

import (
	"fmt"
	"net/http"
	"strings"
	"unicode"

	"vastix/internal/database"
	"vastix/internal/tui/widgets/common"

	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/openapi_schema"
	"github.com/vast-data/go-vast-client/rest"
)

// WidgetFactory creates widgets based on resource introspection
type WidgetFactory struct {
	db                 *database.Service
	rest               *rest.UntypedVMSRest
	supportedResources []string
}

// NewWidgetFactory creates a new widget factory
func NewWidgetFactory(db *database.Service, rest *rest.UntypedVMSRest) *WidgetFactory {
	return &WidgetFactory{
		db:                 db,
		rest:               rest,
		supportedResources: []string{}, // Will be populated as widgets are created
	}
}

// GetSupportedResources returns the list of supported resource names
func (f *WidgetFactory) GetSupportedResources() []string {
	return f.supportedResources
}

// AddSupportedResource adds a resource name to the supported list
func (f *WidgetFactory) addSupportedResource(name string) {
	f.supportedResources = append(f.supportedResources, name)
}

// CreateWidget creates a widget from an API resource
func (f *WidgetFactory) CreateWidget(resource core.VastResourceAPIWithContext, listHeaders []string) (common.Widget, error) {
	// Extract resource info using introspection
	resourceType := resource.GetResourceType()
	resourcePath := resource.GetResourcePath()
	crudHints := core.GetCRUDHintsFromResource(resource)
	extraMethods := core.DiscoverExtraMethodsFromResource(resource)

	// Clean resource type for use as widget key (remove slashes)
	// resourcePath is "/users/", we want "users"
	cleanResourceType := strings.Trim(resourcePath, "/")

	// Use default headers if none provided
	if listHeaders == nil {
		listHeaders = []string{"id", "name"}
	}

	// Create form hints
	formHints := &common.FormHints{
		SchemaRef: common.NewSchemaReference(http.MethodPost, resourcePath, "", ""),
	}

	// Create extra widgets from extra methods
	extraNav := f.createExtraWidgetsFromMethods(resourceType, resourcePath, extraMethods)

	// Log discovered extra methods for debugging
	fmt.Printf("[WidgetFactory] Discovered %d extra methods for %s\n", len(extraMethods), resourceType)
	if len(extraMethods) > 0 {
		for _, method := range extraMethods {
			fmt.Printf("  - %s (%s) -> %s\n", method.Name, method.HTTPVerb, method.Path)
		}
	}
	fmt.Printf("[WidgetFactory] Created %d extra widgets from %d methods\n", len(extraNav), len(extraMethods))
	fmt.Printf("[WidgetFactory] Passing %d extra widgets to NewBaseWidget\n", len(extraNav))

	// Create the auto widget with cleanResourceType as the key
	widget := &AutoGeneratedWidget{
		BaseWidget:   NewBaseWidget(f.db, listHeaders, formHints, cleanResourceType, extraNav, nil),
		resource:     resource,
		resourceType: resourceType,
		resourcePath: resourcePath,
		crudHints:    crudHints,
		restClient:   f.rest,
	}

	// Set parent reference
	widget.SetParentForBaseWidget(widget, false)

	// Set allowed/disallowed modes based on CRUD hints
	widget.allowedModes = crudHintsToNavigatorModes(crudHints)
	widget.disallowedModes = crudHintsToDisallowedModes(crudHints)

	// Add Extra mode if there are extra widgets
	if len(extraNav) > 0 {
		widget.allowedModes = append(widget.allowedModes, common.NavigatorModeExtra)
		fmt.Printf("[WidgetFactory] Added NavigatorModeExtra to allowed modes (has %d extra widgets)\n", len(extraNav))
	}

	return widget, nil
}

// CreateAllWidgets is intentionally removed - create widgets one by one instead.
// Use CreateWidget() for each resource individually for better control and safety.

// createExtraWidgetsFromMethods creates extra navigation widgets from extra methods
func (f *WidgetFactory) createExtraWidgetsFromMethods(resourceType, resourcePath string, methods []core.ExtraMethodInfo) []common.ExtraWidget {
	var extraWidgets []common.ExtraWidget

	for _, method := range methods {
		extraWidget := f.createExtraWidget(resourceType, method)
		if extraWidget != nil {
			extraWidgets = append(extraWidgets, extraWidget)
		}
	}

	return extraWidgets
}

// createExtraWidget creates an extra widget from an extra method info
func (f *WidgetFactory) createExtraWidget(parentResourceType string, method core.ExtraMethodInfo) common.ExtraWidget {
	// Determine HTTP method from the verb
	httpMethod := method.HTTPVerb

	// Create form hints for the extra method
	formHints := &common.FormHints{
		SchemaRef: common.NewSchemaReference(httpMethod, method.Path, "", ""),
	}

	// Determine list headers
	listHeaders := []string{"id", "name"}

	// Create display name from method name (e.g., "UserAccessKeys_POST" -> "User Access Keys")
	displayName := formatDisplayName(method.Name)

	// Fetch and cache summary from OpenAPI schema
	summary, err := openapi_schema.GetOperationSummary(method.HTTPVerb, method.Path)
	if err != nil || summary == "" {
		// Fallback to formatted display name if summary not found
		summary = displayName
	}

	// Create the extra widget
	extraWidget := &ExtraMethodWidget{
		BaseWidget:  NewBaseWidget(f.db, listHeaders, formHints, method.Path, nil, nil),
		methodInfo:  method,
		displayName: displayName,
		summary:     summary, // Cached summary from OpenAPI
	}

	extraWidget.SetParentForBaseWidget(extraWidget, false)

	return extraWidget
}

// formatDisplayName converts a method name to a display name
// e.g., "UserAccessKeys_POST" -> "User Access Keys"
func formatDisplayName(methodName string) string {
	// Remove HTTP verb suffix
	methodName = strings.TrimSuffix(methodName, "_GET")
	methodName = strings.TrimSuffix(methodName, "_POST")
	methodName = strings.TrimSuffix(methodName, "_PATCH")
	methodName = strings.TrimSuffix(methodName, "_PUT")
	methodName = strings.TrimSuffix(methodName, "_DELETE")

	// Insert spaces before uppercase letters
	var result []rune
	for i, r := range methodName {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, ' ')
		}
		result = append(result, r)
	}

	return string(result)
}

// AutoGeneratedWidget is a widget that was auto-generated from resource introspection
type AutoGeneratedWidget struct {
	*BaseWidget
	resource        core.VastResourceAPIWithContext
	resourceType    string
	resourcePath    string
	crudHints       core.ResourceOps
	restClient      *rest.UntypedVMSRest
	allowedModes    []common.NavigatorMode
	disallowedModes []common.NavigatorMode
}

// API returns the API interface for this widget (implements VastResourceGetter)
func (w *AutoGeneratedWidget) API(rest *VMSRest) VastResourceAPI {
	// Return the actual resource that was passed to CreateWidget
	return w.resource
}

// String returns a string representation of the widget showing the resource name
func (w *AutoGeneratedWidget) String() string {
	// Capitalize first letter of resource type
	resourceName := w.resourceType
	if len(resourceName) > 0 {
		resourceName = strings.ToUpper(resourceName[:1]) + resourceName[1:]
	}
	return fmt.Sprintf("%s (AutoGeneratedWidget)", resourceName)
}

// GetAllowedNavigatorModes returns allowed navigator modes based on CRUD hints
func (w *AutoGeneratedWidget) GetAllowedNavigatorModes() []common.NavigatorMode {
	if len(w.allowedModes) > 0 {
		return w.allowedModes
	}
	return w.BaseWidget.GetAllowedNavigatorModes()
}

// GetNotAllowedNavigatorModes returns disallowed navigator modes
func (w *AutoGeneratedWidget) GetNotAllowedNavigatorModes() []common.NavigatorMode {
	return w.disallowedModes
}

// GetDisplayName returns a user-friendly display name
func (w *AutoGeneratedWidget) GetDisplayName() string {
	// Convert resource type to Title Case with spaces
	// e.g., "users" -> "Users", "vip_pools" -> "Vip Pools"
	return formatDisplayName(w.resourceType)
}

// ExtraMethodWidget represents a widget for an extra method
type ExtraMethodWidget struct {
	*BaseWidget
	methodInfo  core.ExtraMethodInfo
	displayName string
	summary     string // Cached summary from OpenAPI schema
}

// API returns the API interface for this extra widget
func (w *ExtraMethodWidget) API(rest *VMSRest) VastResourceAPI {
	// For extra methods, we need to return a resource that can handle the extra method
	// This is a placeholder - in practice, you'd need to determine the parent resource
	// from the method path or have it passed in during creation
	return nil // TODO: Implement proper parent resource lookup
}

// GetDisplayName returns the display name for this extra method
func (w *ExtraMethodWidget) GetDisplayName() string {
	return w.displayName
}

// GetHTTPMethod returns the HTTP method (verb) for this extra method
func (w *ExtraMethodWidget) GetHTTPMethod() string {
	return w.methodInfo.HTTPVerb
}

// GetSummary returns the cached operation summary from OpenAPI schema
func (w *ExtraMethodWidget) GetSummary() string {
	return w.summary
}

// InitialExtraMode returns the initial mode based on HTTP method
func (w *ExtraMethodWidget) InitialExtraMode() common.ExtraNavigatorMode {
	// Determine initial mode based on HTTP verb
	switch w.methodInfo.HTTPVerb {
	case "GET":
		return common.ExtraNavigatorModeDetails
	case "POST":
		return common.ExtraNavigatorModeCreate
	case "PATCH", "PUT":
		// PATCH/PUT could be update, but we treat it as details mode
		// The user can switch to create mode if needed
		return common.ExtraNavigatorModeDetails
	case "DELETE":
		return common.ExtraNavigatorModeDelete
	default:
		return common.ExtraNavigatorModeDetails
	}
}

// Helper functions for CRUD hints to navigator modes conversion
func crudHintsToNavigatorModes(hints core.ResourceOps) []common.NavigatorMode {
	var modes []common.NavigatorMode

	if hints&core.L != 0 {
		modes = append(modes, common.NavigatorModeList)
	}
	if hints&core.R != 0 {
		modes = append(modes, common.NavigatorModeDetails)
	}
	if hints&core.C != 0 || hints&core.U != 0 {
		// Both Create and Update use NavigatorModeCreate
		modes = append(modes, common.NavigatorModeCreate)
	}
	if hints&core.D != 0 {
		modes = append(modes, common.NavigatorModeDelete)
	}

	return modes
}

func crudHintsToDisallowedModes(hints core.ResourceOps) []common.NavigatorMode {
	var disallowed []common.NavigatorMode

	if hints&core.L == 0 {
		disallowed = append(disallowed, common.NavigatorModeList)
	}
	if hints&core.R == 0 {
		disallowed = append(disallowed, common.NavigatorModeDetails)
	}
	if hints&core.C == 0 && hints&core.U == 0 {
		// Disallow create mode only if both C and U are not supported
		disallowed = append(disallowed, common.NavigatorModeCreate)
	}
	if hints&core.D == 0 {
		disallowed = append(disallowed, common.NavigatorModeDelete)
	}

	return disallowed
}
