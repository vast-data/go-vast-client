package widgets

import (
	"fmt"
	"net/http"
	"reflect"
	"sort"
	"strings"
	"time"
	"unicode"

	"vastix/internal/database"
	log "vastix/internal/logging"
	"vastix/internal/msg_types"
	"vastix/internal/tui/widgets/common"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/openapi_schema"
	"github.com/vast-data/go-vast-client/resources/untyped"
	"go.uber.org/zap"
)

// WidgetFactory creates widgets based on resource introspection
type WidgetFactory struct {
	db                 *database.Service
	supportedResources []string
}

// NewWidgetFactory creates a new widget factory
func NewWidgetFactory(db *database.Service) *WidgetFactory {
	return &WidgetFactory{
		db:                 db,
		supportedResources: []string{}, // Will be populated as widgets are created
	}
}

// GetSupportedResources returns the list of supported resource names
func (f *WidgetFactory) GetSupportedResources() []string {
	return f.supportedResources
}

// AddSupportedResource adds a resource name to the supported list
func (f *WidgetFactory) addSupportedResource(name string) {
	f.supportedResources = append(f.supportedResources, name)
}

// CreateWidget creates a widget from an API resource
func (f *WidgetFactory) CreateWidget(resource core.VastResourceAPIWithContext, listHeaders []string) (common.Widget, error) {
	return f.CreateWidgetWithExclusions(resource, listHeaders, nil)
}

// CreateWidgetWithExclusions creates a widget from an API resource with excluded fields
func (f *WidgetFactory) CreateWidgetWithExclusions(resource core.VastResourceAPIWithContext, listHeaders []string, excludedFields []string) (common.Widget, error) {
	// Extract resource info using introspection
	resourceType := resource.GetResourceType()
	resourcePath := resource.GetResourcePath()
	crudHints := core.GetCRUDHintsFromResource(resource)
	extraMethods := core.DiscoverExtraMethodsFromResource(resource)

	// Log if extra methods are discovered
	if len(extraMethods) > 0 {
		log.Debug("Extra methods discovered for widget",
			zap.String("resourceType", resourceType),
			zap.Int("count", len(extraMethods)))
	}

	// Clean resource type for use as widget key (remove slashes)
	// resourcePath is "/users/", we want "users"
	cleanResourceType := strings.Trim(resourcePath, "/")

	// Use default headers if none provided
	if listHeaders == nil {
		listHeaders = []string{"id", "name"}
	}

	// Create form hints
	formHints := &common.FormHints{
		SchemaRef:      common.NewSchemaReference(http.MethodPost, resourcePath, "", ""),
		ExcludedFields: excludedFields,
	}

	// Create extra widgets from extra methods
	extraNav := f.createExtraWidgetsFromMethods(resourceType, resourcePath, extraMethods)

	// Log discovered extra methods for debugging
	if len(extraMethods) > 0 {
		log.Debug("Extra methods discovered",
			zap.Int("method_count", len(extraMethods)),
			zap.Int("widget_count", len(extraNav)))
	}

	// Create the auto widget with cleanResourceType as the key
	widget := &AutoGeneratedWidget{
		BaseWidget:   NewBaseWidget(f.db, listHeaders, formHints, cleanResourceType, extraNav, nil),
		resourceType: resourceType,
		resourcePath: resourcePath,
		crudHints:    crudHints,
		allowedModes: []common.NavigatorMode{},
	}

	// Set parent reference
	widget.SetParentForBaseWidget(widget, false)

	// Set allowed modes based on CRUD hints
	widget.allowedModes = crudHintsToNavigatorModes(crudHints)

	// Check if CREATE mode is allowed but no inputs can be generated
	// This handles resources that have C (Create) hint but no create schema
	hasCreateMode := false
	for _, mode := range widget.allowedModes {
		if mode == common.NavigatorModeCreate {
			hasCreateMode = true
			break
		}
	}

	if hasCreateMode {
		// Try to get inputs to see if they can be generated
		inputs, err := widget.BaseWidget.GetInputsWithError()
		if err != nil || len(inputs) == 0 {
			// Remove CREATE mode if no inputs can be generated
			var filteredModes []common.NavigatorMode
			for _, mode := range widget.allowedModes {
				if mode != common.NavigatorModeCreate {
					filteredModes = append(filteredModes, mode)
				}
			}
			widget.allowedModes = filteredModes
			log.Debug("Removed NavigatorModeCreate due to missing inputs",
				zap.String("resourceType", resourceType),
				zap.Error(err))
		}
	}

	// Add Extra mode if there are extra widgets
	if len(extraNav) > 0 {
		widget.allowedModes = append(widget.allowedModes, common.NavigatorModeExtra)
		log.Debug("Added NavigatorModeExtra to allowed modes",
			zap.Int("extra_widget_count", len(extraNav)))
	}

	return widget, nil
}

// CreateWidgetMust is a helper that panics on error instead of returning it
// Use this during initialization when widget creation failure should be fatal
func (f *WidgetFactory) CreateWidgetMust(resource core.VastResourceAPIWithContext, listHeaders []string) common.Widget {
	widget, err := f.CreateWidget(resource, listHeaders)
	if err != nil {
		panic(fmt.Sprintf("CreateWidgetMust failed for resource %s: %v", resource.GetResourceType(), err))
	}
	return widget
}

// CreateWidgetMustWithExclusions is a helper that panics on error instead of returning it
// Use this during initialization when widget creation failure should be fatal
func (f *WidgetFactory) CreateWidgetMustWithExclusions(resource core.VastResourceAPIWithContext, listHeaders []string, excludedFields []string) common.Widget {
	widget, err := f.CreateWidgetWithExclusions(resource, listHeaders, excludedFields)
	if err != nil {
		panic(fmt.Sprintf("CreateWidgetMustWithExclusions failed for resource %s: %v", resource.GetResourceType(), err))
	}
	return widget
}

// RegisterWidget adds the widget to the global widget map and factory's supported resources
// This is a helper to reduce boilerplate when registering widgets
func (f *WidgetFactory) RegisterWidget(widget common.Widget) {
	resourceKey := widget.GetResourceType()
	generatedWidgets[resourceKey] = widget
	f.addSupportedResource(resourceKey)
}

// CreateAndRegisterWidgetMustWithExclusions creates a widget with excluded fields and registers it in one call
func (f *WidgetFactory) CreateAndRegisterWidgetMustWithExclusions(resource core.VastResourceAPIWithContext, listHeaders []string, excludedFields []string) common.Widget {
	widget := f.CreateWidgetMustWithExclusions(resource, listHeaders, excludedFields)
	f.RegisterWidget(widget)
	return widget
}

// CreateAndRegisterWidgetMust creates a widget and immediately registers it
// Returns the widget so callbacks can be set afterward
// Panics on error - use this during initialization when failure should be fatal
func (f *WidgetFactory) CreateAndRegisterWidgetMust(resource core.VastResourceAPIWithContext, listHeaders []string) common.Widget {
	widget := f.CreateWidgetMust(resource, listHeaders)
	f.RegisterWidget(widget)
	return widget
}

// createExtraWidgetsFromMethods creates extra navigation widgets from extra methods
func (f *WidgetFactory) createExtraWidgetsFromMethods(resourceType, resourcePath string, methods []core.ExtraMethodInfo) []common.ExtraWidget {
	// Sort methods for consistent ordering: first by path, then by HTTP verb
	sort.Slice(methods, func(i, j int) bool {
		if methods[i].Path != methods[j].Path {
			return methods[i].Path < methods[j].Path
		}
		// Within same path, sort by HTTP verb priority: DELETE < GET < PATCH < POST < PUT
		verbPriority := map[string]int{
			"DELETE": 1,
			"GET":    2,
			"PATCH":  3,
			"POST":   4,
			"PUT":    5,
		}
		return verbPriority[methods[i].HTTPVerb] < verbPriority[methods[j].HTTPVerb]
	})

	var extraWidgets []common.ExtraWidget

	// Create a widget for EACH method (not just one per path)
	for i, method := range methods {
		// Assign numbered shortcuts 1-6 for first 6 methods
		var shortcutNum int
		if i < 6 {
			shortcutNum = i + 1 // 1-based numbering
		}

		extraWidget := f.createExtraWidget(resourceType, method, shortcutNum)
		if extraWidget != nil {
			extraWidgets = append(extraWidgets, extraWidget)
		}
	}

	return extraWidgets
}

// createExtraWidget creates an extra widget from an extra method info
func (f *WidgetFactory) createExtraWidget(parentResourceType string, method core.ExtraMethodInfo, shortcutNum int) common.ExtraWidget {
	// Determine HTTP method from the verb
	httpMethod := method.HTTPVerb

	// Create form hints for the extra method
	// Check if the operation has query parameters to determine the right schema reference
	queryParams, queryErr := openapi_schema.GetQueryParameters(httpMethod, method.Path)
	hasQueryParams := queryErr == nil && len(queryParams) > 0

	log.GetAuxLogger().Printf("[createExtraWidget] Method: %s %s, hasQueryParams=%v, paramCount=%d, err=%v",
		httpMethod, method.Path, hasQueryParams, len(queryParams), queryErr)

	var formHints *common.FormHints
	if hasQueryParams {
		// Operation uses query parameters - set up read path for query params
		log.GetAuxLogger().Printf("[createExtraWidget] Setting up for query parameters")
		formHints = &common.FormHints{
			SchemaRef: common.NewSchemaReference("", "", httpMethod, method.Path),
		}
	} else {
		// Operation uses request body - set up create path for body schema
		log.GetAuxLogger().Printf("[createExtraWidget] Setting up for request body")
		formHints = &common.FormHints{
			SchemaRef: common.NewSchemaReference(httpMethod, method.Path, "", ""),
		}
	}

	// Determine list headers
	listHeaders := []string{"id", "name"}

	// Create display name in format: [method]path
	// e.g., "[patch]apitokens/{id}/revoke"
	cleanPath := strings.Trim(method.Path, "/")
	displayName := fmt.Sprintf("[%s]%s", strings.ToLower(method.HTTPVerb), cleanPath)

	// Fetch and cache summary from OpenAPI schema
	summary, err := openapi_schema.GetOperationSummary(method.HTTPVerb, method.Path)
	if err != nil || summary == "" {
		// Fallback to formatted display name if summary not found
		summary = displayName
	}

	// Create numbered shortcut if within range 1-6
	var shortcut *common.KeyBinding
	if shortcutNum > 0 && shortcutNum <= 6 {
		shortcut = &common.KeyBinding{
			Key:           fmt.Sprintf("<%d>", shortcutNum),
			Desc:          displayName,
			IsExtraAction: true, // Mark as extra action for special coloring
		}
	}

	// Create the extra widget
	// Use unique resourceType combining HTTP method and path to avoid collisions
	// when multiple HTTP methods exist for the same path
	uniqueResourceType := fmt.Sprintf("%s:%s", method.HTTPVerb, method.Path)
	baseWidget := NewBaseWidget(f.db, listHeaders, formHints, uniqueResourceType, nil, nil)

	// Set the title for extra actions to just be the unique resource type (no prefixes)
	baseWidget.ListAdapter.SetPredefinedTitle(uniqueResourceType)
	baseWidget.CreateAdapter.SetPredefinedTitle(uniqueResourceType)
	baseWidget.DetailsAdapter.SetPredefinedTitle(uniqueResourceType)

	// Determine if this action requires a resource (check if path contains {id} or {guid})
	// Actions like /apitokens/{id}/revoke/ need a selected resource (resourceless=false)
	// Actions like /users/query/ don't need a selected resource (resourceless=true, default)
	requiresResource := strings.Contains(method.Path, "{id}") || strings.Contains(method.Path, "{guid}")
	if requiresResource {
		baseWidget.SetResourceless(false)
	}

	extraWidget := &ExtraMethodWidget{
		BaseWidget:   baseWidget,
		methodInfo:   method,
		displayName:  displayName,
		summary:      summary,            // Cached summary from OpenAPI
		shortcut:     shortcut,           // Assigned numbered shortcut
		resourceType: parentResourceType, // Store only resource type, NOT the resource object
	}

	extraWidget.SetParentForBaseWidget(extraWidget, false)

	return extraWidget
}

// formatDisplayName converts a method name to a display name
// e.g., "UserAccessKeys_POST" -> "User Access Keys"
func formatDisplayName(methodName string) string {
	// Remove HTTP verb suffix
	methodName = strings.TrimSuffix(methodName, "_GET")
	methodName = strings.TrimSuffix(methodName, "_POST")
	methodName = strings.TrimSuffix(methodName, "_PATCH")
	methodName = strings.TrimSuffix(methodName, "_PUT")
	methodName = strings.TrimSuffix(methodName, "_DELETE")

	// Insert spaces before uppercase letters
	var result []rune
	for i, r := range methodName {
		if i > 0 && unicode.IsUpper(r) {
			result = append(result, ' ')
		}
		result = append(result, r)
	}

	return string(result)
}

// AutoGeneratedWidget is a widget that was auto-generated from resource introspection
type AutoGeneratedWidget struct {
	*BaseWidget
	resourceType string
	resourcePath string
	crudHints    core.ResourceOps
	allowedModes []common.NavigatorMode
}

// SupportsListOperation returns true if the resource supports LIST operations
func (w *AutoGeneratedWidget) SupportsListOperation() bool {
	return (w.crudHints & core.L) != 0
}

// SupportsReadOperation returns true if the resource supports READ operations
func (w *AutoGeneratedWidget) SupportsReadOperation() bool {
	return (w.crudHints & core.R) != 0
}

// API returns the API interface for this widget (implements VastAPIGetter)
func (w *AutoGeneratedWidget) API(rest *VMSRest) VastResourceAPIWithContext {
	// Get resource dynamically from REST client's resource map
	// This ensures we use the resource tied to the current profile's session
	resourceMap := rest.GetResourceMap()
	if resource, exists := resourceMap[w.resourceType]; exists {
		return resource
	}
	return nil
}

// String returns a string representation of the widget showing the resource name
func (w *AutoGeneratedWidget) String() string {
	// Capitalize first letter of resource type
	resourceName := w.resourceType
	if len(resourceName) > 0 {
		resourceName = strings.ToUpper(resourceName[:1]) + resourceName[1:]
	}
	return fmt.Sprintf("%s (AutoGeneratedWidget)", resourceName)
}

// GetAllowedNavigatorModes returns allowed navigator modes based on CRUD hints
func (w *AutoGeneratedWidget) GetAllowedNavigatorModes() []common.NavigatorMode {
	if len(w.allowedModes) > 0 {
		return w.allowedModes
	}
	return w.BaseWidget.GetAllowedNavigatorModes()
}

// GetDisplayName returns a user-friendly display name
func (w *AutoGeneratedWidget) GetDisplayName() string {
	// Convert resource type to Title Case with spaces
	// e.g., "users" -> "Users", "vip_pools" -> "Vip Pools"
	return formatDisplayName(w.resourceType)
}

// ExtraMethodWidget represents a widget for an extra method
type ExtraMethodWidget struct {
	*BaseWidget
	methodInfo   core.ExtraMethodInfo
	displayName  string
	summary      string             // Cached summary from OpenAPI schema
	shortcut     *common.KeyBinding // Numbered shortcut for quick access (1-6)
	resourceType string             // Only store resource type, NOT the resource object itself
}

// API returns the API interface for this extra widget
func (w *ExtraMethodWidget) API(rest *VMSRest) VastResourceAPIWithContext {
	// For extra methods, we need to return a resource that can handle the extra method
	// This is a placeholder - in practice, you'd need to determine the parent resource
	// from the method path or have it passed in during creation
	return nil // TODO: Implement proper parent resource lookup
}

// SetListData overrides BaseWidget.SetListData for extra method widgets
// Extra method widgets don't have "list" data in the traditional sense
func (w *ExtraMethodWidget) SetListData() tea.Msg {
	// Extra method widgets don't fetch list data
	// They work with single operations (GET/POST/PATCH/etc on specific endpoints)
	return nil
}

// GetDisplayName returns the display name for this extra method
func (w *ExtraMethodWidget) GetDisplayName() string {
	return w.displayName
}

// GetHTTPMethod returns the HTTP method (verb) for this extra method
func (w *ExtraMethodWidget) GetHTTPMethod() string {
	return w.methodInfo.HTTPVerb
}

// GetPath returns the URL path for this extra method
func (w *ExtraMethodWidget) GetPath() string {
	return w.methodInfo.Path
}

// GetSummary returns the cached operation summary from OpenAPI schema
func (w *ExtraMethodWidget) GetSummary() string {
	return w.summary
}

// GetInputs overrides BaseWidget.GetInputs to handle query parameters for GET requests
func (w *ExtraMethodWidget) GetInputs() (common.Inputs, error) {
	if w.formHints == nil || w.formHints.SchemaRef == nil {
		return nil, fmt.Errorf("no schema reference available for extra method")
	}

	var inputs common.Inputs
	var err error

	// Determine if this operation uses query parameters or request body
	// by checking what parameters actually exist in the OpenAPI schema
	queryParams, queryErr := openapi_schema.GetQueryParameters(w.methodInfo.HTTPVerb, w.methodInfo.Path)
	hasQueryParams := queryErr == nil && len(queryParams) > 0

	// For operations with query parameters (GET, DELETE with params, etc.), use query params
	// For operations with body (POST, PATCH, PUT), use body schema
	// Prioritize query params if both exist (rare but possible)
	if hasQueryParams {
		inputs, err = w.formHints.SchemaRef.GetInputsFromQueryParams(false)
	} else {
		inputs, err = w.formHints.GetInputsFromCreateSchemaWithCustom(false)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to get inputs for %s %s: %w",
			w.methodInfo.HTTPVerb, w.methodInfo.Path, err)
	}

	// If the path contains {id} or {guid}, add an ID input field as the first field
	if strings.Contains(w.methodInfo.Path, "{id}") || strings.Contains(w.methodInfo.Path, "{guid}") {
		// Get the ID value from selected row data to pre-populate
		var idValue string
		if w.BaseWidget.selectedRowData.Len() > 0 {
			if id := w.BaseWidget.selectedRowData.Get("id"); id != nil {
				idValue = fmt.Sprintf("%v", id)
			} else if guid := w.BaseWidget.selectedRowData.Get("guid"); guid != nil {
				idValue = fmt.Sprintf("%v", guid)
			}
		}

		// Create a text input for the ID using the Inputs helper method
		var idInputs common.Inputs
		idInputs.NewTextInput("id", "ID (part of URL path)", true, idValue)

		// Mark as touched if pre-populated with a value so it appears in JSON view
		if idValue != "" {
			idInputs[0].Touched = true
		}

		// Prepend the ID input to the beginning of the inputs list
		inputs = append(idInputs, inputs...)
	}

	// Pre-populate input fields with values from the parent widget's selected row
	// if the field names match (case-insensitive)
	if w.BaseWidget.selectedRowData.Len() > 0 {
		for i := range inputs {
			fieldName := inputs[i].GetLabel()

			// Skip the "id" field as it's already populated above
			if fieldName == "id" {
				continue
			}

			// Try to get value from parent row data (case-insensitive lookup)
			if value := w.BaseWidget.selectedRowData.Get(fieldName); value != nil {
				// Set the default value for this input
				valueStr := fmt.Sprintf("%v", value)
				if valueStr != "" && valueStr != "<nil>" {
					inputs[i].SetValue(valueStr)
					// Mark as touched so pre-populated values appear in JSON view
					inputs[i].Touched = true
				}
			}
		}
	}

	return inputs, nil
}

// ShortCut returns the numbered shortcut key binding for this extra action (1-6)
func (w *ExtraMethodWidget) ShortCut() *common.KeyBinding {
	return w.shortcut
}

// InitialExtraMode returns the initial mode based on HTTP method and whether inputs are required
func (w *ExtraMethodWidget) InitialExtraMode() common.ExtraNavigatorMode {
	// Check if this method requires any inputs by examining:
	// 1. Request body schema (for POST, PATCH, PUT)
	// 2. Query parameters (for GET and other methods)

	hasInputs := false

	// Check for request body parameters
	schema, err := openapi_schema.GetRequestBodySchema(w.methodInfo.HTTPVerb, w.methodInfo.Path)
	if err == nil && schema != nil && schema.Value != nil {
		// Check if schema has any properties (non-empty request body)
		hasInputs = len(schema.Value.Properties) > 0
	}

	// Check for query parameters (important for GET requests)
	if !hasInputs {
		queryParams, err := openapi_schema.GetQueryParameters(w.methodInfo.HTTPVerb, w.methodInfo.Path)
		if err == nil && len(queryParams) > 0 {
			hasInputs = true
		}
	}

	// Debug logging
	log.Debug("ExtraMethod InitialMode determination",
		zap.String("method", w.methodInfo.HTTPVerb),
		zap.String("path", w.methodInfo.Path),
		zap.Bool("hasInputs", hasInputs))

	// Determine mode based on whether the method requires inputs
	// Methods without inputs should show a confirmation prompt
	// Methods with inputs should show a create form
	if !hasInputs {
		// No inputs required - show confirmation prompt
		return common.ExtraNavigatorModePrompt
	}

	// Has inputs - show create form
	return common.ExtraNavigatorModeCreate
}

// ViewDetails implements the DetailsWidget interface for ExtraMethodWidget
// Shows the response from the API call
func (w *ExtraMethodWidget) ViewDetails() string {
	// Use the inherited BaseWidget.ViewDetails which shows DetailsAdapter content
	// The details will be populated after the API call completes
	return w.BaseWidget.ViewDetails()
}

// ViewCreateForm implements the CreateWidget interface for ExtraMethodWidget
// Shows the input form for the extra method based on OpenAPI schema
func (w *ExtraMethodWidget) ViewCreateForm() string {
	// Use the inherited BaseWidget.ViewCreateForm which renders the form from FormHints
	// The FormHints were set during widget creation with the OpenAPI schema reference
	return w.BaseWidget.ViewCreateForm()
}

// ViewList implements the ListWidget interface for ExtraMethodWidget
// For extra methods, list mode is not typically used, but we provide it for completeness
func (w *ExtraMethodWidget) ViewList() string {
	// Use the inherited BaseWidget.ViewList
	return w.BaseWidget.ViewList()
}

// ViewPrompt overrides BaseWidget.ViewPrompt to provide context-specific prompt text
func (w *ExtraMethodWidget) ViewPrompt() string {
	// Get selected resource info
	var selectedInfo string
	selectedRowData := w.GetSelectedRowData()
	if selectedRowData.Len() > 0 {
		// Convert RowData to string representation using ordered slice
		values := selectedRowData.ToSlice()
		selectedInfo = strings.Join(values, " ")
	}

	if selectedInfo == "" {
		selectedInfo = "the selected item"
	}

	// For extra actions, use generic prompt wording
	msg := fmt.Sprintf("Are you sure you want to perform %s?\n\n%s", w.displayName, selectedInfo)
	title := fmt.Sprintf(" %s ", w.displayName)

	return w.PromptAdapter.PromptDo(msg, title, w.GetWidth(), w.GetHeight())
}

// CreateFromInputs executes the extra method API call with the provided inputs
func (w *ExtraMethodWidget) CreateFromInputs(inputs common.Inputs) (tea.Cmd, error) {
	// Fetch REST client dynamically from active profile
	profile, err := w.db.GetActiveProfile()
	if err != nil || profile == nil {
		return nil, fmt.Errorf("no active profile found: %w", err)
	}

	restClient, err := profile.RestClientFromProfile()
	if err != nil {
		return nil, fmt.Errorf("failed to get REST client from profile: %w", err)
	}

	// Get the resource dynamically from the current REST client's resource map
	// This ensures we always use the resource tied to the active profile's session
	resourceMap := restClient.GetResourceMap()
	resource, exists := resourceMap[w.resourceType]
	if !exists || resource == nil {
		return nil, fmt.Errorf("resource type '%s' not found in REST client", w.resourceType)
	}

	// Prepare the API path - replace {id} or {guid} with actual value from input field
	apiPath := w.methodInfo.Path

	// Only process ID replacement if the path contains {id} or {guid} placeholders
	if strings.Contains(apiPath, "{id}") || strings.Contains(apiPath, "{guid}") {
		// Get the ID value from the "id" input field (user can modify it)
		var idValue string
		if idField := inputs.Field("id"); idField != nil {
			idValue = idField.Value()
		}

		// If no ID in inputs, fall back to selected row data
		if idValue == "" {
			selectedRow := w.BaseWidget.selectedRowData
			if selectedRow.Len() == 0 {
				return nil, fmt.Errorf("no resource ID provided and no resource selected from parent widget")
			}

			// Extract the ID from the selected row
			if id := selectedRow.Get("id"); id != nil {
				idValue = fmt.Sprintf("%v", id)
			} else if guid := selectedRow.Get("guid"); guid != nil {
				idValue = fmt.Sprintf("%v", guid)
			}
		}

		if idValue == "" {
			return nil, fmt.Errorf("no ID value provided for path with {id} placeholder")
		}

		// Replace placeholders with actual value
		apiPath = strings.ReplaceAll(apiPath, "{id}", idValue)
		apiPath = strings.ReplaceAll(apiPath, "{guid}", idValue)
	}
	// For resourceless paths (no {id} or {guid}), use the path as-is

	// Validate inputs before conversion
	if err := inputs.Validate(); err != nil {
		return nil, err
	}

	// Convert inputs to request parameters (core.Params type)
	allParams := inputs.ToParams()

	// Remove the "id" field from params if it exists, as it's part of the URL path, not a parameter
	if strings.Contains(w.methodInfo.Path, "{id}") || strings.Contains(w.methodInfo.Path, "{guid}") {
		delete(allParams, "id")
	}

	// Create the API execution command
	cmd := func() tea.Msg {
		ctx := restClient.GetCtx()

		// Split parameters into query params and body params based on OpenAPI schema
		queryParams := make(core.Params)
		bodyParams := make(core.Params)

		// Get query parameters from OpenAPI schema
		queryParamDefs, queryErr := openapi_schema.GetQueryParameters(w.methodInfo.HTTPVerb, w.methodInfo.Path)
		if queryErr == nil && queryParamDefs != nil {
			// Build a set of query parameter names for fast lookup
			queryParamNames := make(map[string]bool)
			for _, param := range queryParamDefs {
				queryParamNames[param.Name] = true
			}

			// Split allParams into queryParams and bodyParams
			for key, value := range allParams {
				if queryParamNames[key] {
					queryParams[key] = value
				} else {
					bodyParams[key] = value
				}
			}
			log.GetAuxLogger().Printf("[ExtraMethodWidget] %s %s - Split params: queryParams=%v, bodyParams=%v",
				w.methodInfo.HTTPVerb, w.methodInfo.Path, queryParams, bodyParams)
		} else {
			// If we can't determine from schema, fall back to method-based assumptions
			// GET: all params are query params
			// POST/PATCH/PUT/DELETE: all params are body params
			if strings.ToUpper(w.methodInfo.HTTPVerb) == "GET" {
				queryParams = allParams
			} else {
				bodyParams = allParams
			}
			log.GetAuxLogger().Printf("[ExtraMethodWidget] %s %s - Fallback split: queryParams=%v, bodyParams=%v (queryErr=%v)",
				w.methodInfo.HTTPVerb, w.methodInfo.Path, queryParams, bodyParams, queryErr)
		}

		// Call the actual extra method on the resource using reflection
		result, err := w.callExtraMethod(ctx, resource, queryParams, bodyParams)

		if err != nil {
			return msg_types.ErrorMsg{Err: err}
		}

		// Call after create callback if provided (for additional work like saving to DB)
		// This is especially important for key generation endpoints
		if w.afterCreateFn != nil {
			// Try to extract Record from result (might be Record or RecordSet)
			var record core.Record
			switch v := result.(type) {
			case core.Record:
				record = v
			case core.RecordSet:
				// For RecordSet, use the first record if available
				if len(v) > 0 {
					record = v[0]
				}
			}

			if record != nil {
				// Pass the parent widget's selected row data to the callback
				// This contains the selected user's information (name, id, etc.)
				parentRowData := w.BaseWidget.selectedRowData
				_, err := w.afterCreateFn(record, parentRowData)
				if err != nil {
					log.GetAuxLogger().Printf("[ExtraMethodWidget] After create callback failed: %v", err)
					// Don't fail the whole operation, just log the error
					// The API call succeeded, just the post-processing failed
				}
			}
		}

		// Return the result as details content
		// The mode will be switched to details by the message handler
		return msg_types.DetailsContentMsg{
			Content:      result,
			ResourceType: w.methodInfo.Path,
			Error:        nil,
		}
	}

	return cmd, nil
}

// callExtraMethod uses reflection to call the actual extra method on the resource
// It handles different method signatures based on the method's parameters
func (w *ExtraMethodWidget) callExtraMethod(ctx any, resource core.VastResourceAPIWithContext, queryParams, bodyParams core.Params) (any, error) {
	// Build the method name: replace _VERB with WithContext_VERB
	// e.g., "ViewCheckPermissionsTemplates_POST" -> "ViewCheckPermissionsTemplatesWithContext_POST"
	methodName := strings.Replace(w.methodInfo.Name, "_"+strings.ToUpper(w.methodInfo.HTTPVerb), "WithContext_"+strings.ToUpper(w.methodInfo.HTTPVerb), 1)

	// Get the reflect.Value of the resource
	resourceValue := reflect.ValueOf(resource)
	method := resourceValue.MethodByName(methodName)

	if !method.IsValid() {
		return nil, fmt.Errorf("method %s not found on resource %T", methodName, resource)
	}

	// Get method type to inspect its signature
	methodType := method.Type()
	numIn := methodType.NumIn()

	// Build the arguments list based on method signature
	// All extra methods start with ctx, then optionally have id, params (query/body), and waitTimeout
	args := []reflect.Value{reflect.ValueOf(ctx)}

	// Determine if method has ID parameter (check if second param is 'any' or 'interface{}')
	hasID := false
	if numIn >= 2 {
		secondParamType := methodType.In(1)
		if secondParamType.Kind() == reflect.Interface && secondParamType.Name() == "" {
			// This is 'any' or 'interface{}'
			hasID = true
		}
	}

	// Extract ID if needed
	var idValue interface{}
	if hasID {
		selectedRow := w.BaseWidget.selectedRowData
		if selectedRow.Len() > 0 {
			if id := selectedRow.Get("id"); id != nil {
				idValue = id
			} else if guid := selectedRow.Get("guid"); guid != nil {
				idValue = guid
			}
		}

		if idValue != nil {
			args = append(args, reflect.ValueOf(idValue))
		} else {
			return nil, fmt.Errorf("method %s requires ID but no ID found in selected row", methodName)
		}
	}

	// Now check remaining parameters for params and waitTimeout
	currentParamIdx := len(args) // Start from where we left off

	for i := currentParamIdx; i < numIn; i++ {
		paramType := methodType.In(i)

		switch paramType.String() {
		case "core.Params":
			// This is a Params parameter - could be query params or body params
			// For GET methods, use queryParams; for others, check if we've already added params
			if strings.ToUpper(w.methodInfo.HTTPVerb) == "GET" {
				// GET methods use query params
				args = append(args, reflect.ValueOf(queryParams))
			} else {
				// For POST/PATCH/PUT/DELETE, we might have both query and body params
				// The first Params is usually query params (if any), second is body params
				paramCount := 0
				for j := currentParamIdx; j < numIn; j++ {
					if methodType.In(j).String() == "core.Params" {
						paramCount++
					}
				}

				if paramCount == 1 {
					// Only one params - use body params
					args = append(args, reflect.ValueOf(bodyParams))
				} else if paramCount == 2 {
					// Two params - first is query, second is body
					// Check which one we're adding now
					addedParamsCount := 0
					for j := currentParamIdx; j < i; j++ {
						if methodType.In(j).String() == "core.Params" {
							addedParamsCount++
						}
					}

					if addedParamsCount == 0 {
						// First params - query params
						args = append(args, reflect.ValueOf(queryParams))
					} else {
						// Second params - body params
						args = append(args, reflect.ValueOf(bodyParams))
					}
				}
			}

		case "time.Duration":
			// This is a waitTimeout parameter for async operations
			// Use 10 minutes as default timeout
			timeout := 10 * time.Minute
			args = append(args, reflect.ValueOf(timeout))
		}
	}

	results := method.Call(args)

	// Handle different return types
	// Methods can return: error, (result, error), or (*AsyncResult, error)
	numOut := methodType.NumOut()

	if numOut == 0 {
		// No return value (shouldn't happen)
		return nil, nil
	} else if numOut == 1 {
		// Only error returned
		if !results[0].IsNil() {
			return nil, results[0].Interface().(error)
		}
		return nil, nil
	} else if numOut == 2 {
		// (result, error) or (*AsyncResult, error)
		var err error
		if !results[1].IsNil() {
			err = results[1].Interface().(error)
		}

		if err != nil {
			return nil, err
		}

		// Check if result is AsyncResult
		if results[0].Type().String() == "*untyped.AsyncResult" {
			// Handle async result - wait for completion and check for errors
			asyncResult := results[0].Interface().(*untyped.AsyncResult)

			if asyncResult.Err != nil {
				return nil, asyncResult.Err
			}

			// Return the async result as a Record for display
			// The async operation has already been waited for in the method call
			return asyncResult, nil
		}

		// Regular result (Record or RecordSet)
		return results[0].Interface(), nil
	}

	return nil, fmt.Errorf("unexpected number of return values: %d", numOut)
}

// Helper functions for CRUD hints to navigator modes conversion
func crudHintsToNavigatorModes(hints core.ResourceOps) []common.NavigatorMode {
	var modes []common.NavigatorMode

	if hints&core.L != 0 {
		modes = append(modes, common.NavigatorModeList)
	}
	if hints&core.R != 0 {
		modes = append(modes, common.NavigatorModeDetails)
	}
	if hints&core.C != 0 || hints&core.U != 0 {
		// Both Create and Update use NavigatorModeCreate
		modes = append(modes, common.NavigatorModeCreate)
	}
	if hints&core.D != 0 {
		modes = append(modes, common.NavigatorModeDelete)
	}

	return modes
}
