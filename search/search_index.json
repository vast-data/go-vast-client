{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VAST Go Client","text":"<p>The VAST Go client provides an interface to the VAST Data REST API. It wraps low-level HTTP calls in structured methods, allowing you to interact with volumes, views, quotas, and other resources easily.</p> <p>NOTE: Since version 0.100.0, the REST client has been split into two distinct client types:</p> <ul> <li>Typed Client (<code>NewTypedVMSRest</code>): Provides strongly-typed structs for requests and responses. Offers compile-time type safety, IDE auto-completion, and clear API contracts. Recommended for most use cases.</li> <li>Untyped Client (<code>NewVMSRest</code>): Uses flexible <code>map[string]any</code> for data handling. Useful for dynamic scenarios and prototyping. This is the default recommended client.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/vast-data/go-vast-client@v0.103.0  # Replace with the latest available tag\n</code></pre> <p>Import it in your Go code:</p> <pre><code>import client \"github.com/vast-data/go-vast-client\"\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    client \"github.com/vast-data/go-vast-client\"\n    \"github.com/vast-data/go-vast-client/resources/typed\"\n)\n\nfunc main() {\n    config := &amp;client.VMSConfig{\n        Host:     \"10.27.40.1\",\n        Username: \"admin\",\n        Password: \"123456\",\n    }\n\n    rest, err := client.NewTypedVMSRest(config)\n    if err != nil {\n        panic(err)\n    }\n\n    searchParams := &amp;typed.ViewSearchParams{\n        Path: \"/myview\",\n    }\n\n    body := &amp;typed.ViewRequestBody{\n        Name:      \"myview\",\n        Path:      \"/myview\",\n        Protocols: &amp;[]string{\"NFS\"},\n        PolicyId:  1,\n        CreateDir: true,\n    }\n\n    view, err := rest.Views.Ensure(searchParams, body)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"View: %s (ID: %d)\\n\", view.Name, view.Id)\n}\n</code></pre>"},{"location":"DEVELOPER/","title":"Development Guide","text":""},{"location":"DEVELOPER/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.20 or later</li> <li>golangci-lint (for linting)</li> <li>git</li> </ul>"},{"location":"DEVELOPER/#building","title":"Building","text":"<pre><code># Build the library\nmake build\n\n# Run all checks (format, lint, test)\nmake all\n</code></pre>"},{"location":"DEVELOPER/#testing","title":"Testing","text":"<pre><code># Run all tests\nmake test\n\n# Run tests with coverage\nmake test-coverage\n\n# View coverage report\nmake coverage-report\n\n# Run short tests only\nmake test-short\n</code></pre>"},{"location":"DEVELOPER/#code-quality","title":"Code Quality","text":"<pre><code># Format code\nmake fmt\n\n# Run linter\nmake lint\n\n# Run static analysis\nmake vet\n\n# Run security checks\nmake security\n</code></pre>"},{"location":"DEVELOPER/#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create your feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Make your changes</li> <li>Run tests and linting (<code>make all</code>)</li> <li>Commit your changes (<code>git commit -m 'Add some amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol> <p>Please ensure your code follows the existing style and includes appropriate tests.</p>"},{"location":"DEVELOPER/#continuous-integration","title":"Continuous Integration","text":"<p>This project uses GitHub Actions for CI/CD:</p> <ul> <li>Tests: Run on Go 1.20, 1.21, and 1.22</li> <li>Linting: golangci-lint with comprehensive rules</li> <li>Security: gosec and govulncheck</li> <li>Coverage: Reports sent to Coveralls</li> <li>Dependencies: Automated updates via Dependabot</li> </ul>"},{"location":"DEVELOPER/#adding-new-api-resources","title":"Adding New API Resources","text":""},{"location":"DEVELOPER/#do-you-want-to-add-new-api-resource","title":"Do you want to add new API resource?","text":"<p>Suppose you want to add a User resource so that it can be queried using the endpoints <code>&lt;base url&gt;/users</code> for listing and <code>&lt;base url&gt;/users/&lt;id&gt;</code> for retrieving details.</p> <ul> <li>Start by defining a new VastResource named User in the <code>vast_resource.go</code> file.</li> </ul> <pre><code>type User struct {\n    *VastResource\n}\n</code></pre> <ul> <li>Add new <code>User</code> type to <code>VastResourceType</code> generic type in <code>the vast_resource.go</code> file.</li> </ul> <pre><code>type VastResourceType interface {\n    Version | Quota | View | User // &lt;- Here\n}\n</code></pre> <ul> <li>Declare new <code>Users</code> sub-resource in <code>rest.go</code> file and add resource initialization.</li> </ul> <pre><code>type VMSRest struct {\n    Session     RESTSession\n    resourceMap map[string]VastResource\n\n    Versions          *Version\n    VTasks            *VTask\n    Quotas            *Quota\n    Views             *View\n    VipPools          *VipPool\n    Users             *User  // &lt;- Here\n}\n</code></pre> <pre><code>....\nrest.Quotas = newResource[Quota](rest, \"quotas\")\nrest.Views = newResource[View](rest, \"views\")\nrest.VipPools = newResource[VipPool](rest, \"vippools\")\nrest.Users = newResource[User](rest, \"users\") // &lt;- Here\n....\n</code></pre> <p>At this point methods: <code>List</code>, <code>Get</code>, <code>Delete</code>, <code>Update</code>, <code>Create</code>, <code>Ensure</code>, <code>EnsureByName</code>, <code>GetById</code>, <code>DeleteById</code>  and also variants of forementioned methods with context: <code>ListWithContext</code>, <code>GetWithContext</code>, <code>DeleteWithContext</code>, <code>UpdateWithContext</code>, <code>CreateWithContext</code>, <code>EnsureWithContext</code>, <code>EnsureByNameWithContext</code>, <code>GetByIdWithContext</code>, <code>DeleteByIdWithContext</code> are available for <code>User</code> resource.</p> <p>Examples:</p> <p>Create <code>User</code>: <pre><code>result, err := rest.Users.Create(client.Params{\n    \"name\": \"myUser\",\n    \"uid\":  9999,\n})\n</code></pre></p> <p>Ensure <code>User</code> by name (Get by name or Create with provided name and additional params): <pre><code>result, err := rest.Users.EnsureByName(\"myUser\", client.Params{\"uid\": 9999})\n</code></pre></p> <p>Ensure <code>User</code> by search params (Get by search params or Create with body params): <pre><code>searchParams := client.Params{\"name\": \"test\", \"tenant_id\": 1}\nresult, err := rest.Users.EnsureByName(searchParams, client.Params{\"uid\": 9999})\n</code></pre></p> <p>Update <code>User</code>: <pre><code>result, err := rest.Users.Update(1, client.Params{\"uid\": 10000})\n</code></pre></p> <p>Get <code>User</code>: <pre><code>result, err := rest.User.Get(client.Params{\"name\": \"myUser\"})\n</code></pre></p> <p>Get <code>User</code> by id: <pre><code>result, err := rest.Users.GetById(1)\n</code></pre></p> <p>Delete <code>User</code> (Get user by search params and if found delete it. Not found is not error condition): <pre><code>result, err := rest.Users.Delete(client.Params{\"name\": \"myUser\"}, nil)\n</code></pre></p> <p>Delete <code>User</code> by id: <pre><code>result, err := rest.Users.DeleteById(1, nil)\n</code></pre></p> <p>Note</p> <p>Aforementioned flow covers \"classic\" API resources of form <code>/&lt;resource name&gt;/&lt;id&gt;</code>. For non-standard APIs you have to define custom methods or use \"Low level API\" (see Overview section)</p>"},{"location":"DEVELOPER/#define-non-standard-method-for-api-resource","title":"Define non-standard method for API Resource","text":"<p>You can define custom methods for API Resource. Good example is <code>UserKey</code> Resource for generating S3 keys. It has 2 custom methods <code>CreateKey</code> and <code>DeleteKey</code></p> <pre><code>type UserKey struct {\n    *VastResource\n}\n\nfunc (r *UserKey) CreateKey(context.Context, userId int64) (Record, error) {\n    path := fmt.Sprintf(r.resourcePath, userId)\n    return request[Record](ctx, r, http.MethodPost, path, nil, nil)\n}\n\nfunc (r *UserKey) DeleteKey(context.Context, userId int64, accessKey string) (Record, error) {\n    path := fmt.Sprintf(r.resourcePath, userId)\n    return request[Record](ctx, r, http.MethodDelete, path, nil, Params{\"access_key\": accessKey})\n}\n</code></pre> <p>Warning</p> <p>Main rule: Do not override standard methods Ensure, Get, List, Create, DeleteById etc. Create your own methods like CreateUser, DeleteKey etc.</p> <p>Another good example is <code>BlockHostMapping</code> Resource where specific methods are used to map BlockHosts to Volumes.</p>"},{"location":"DEVELOPER/#requestresponse-interceptors","title":"Request/Response interceptors","text":"<p>API Resources can implement <code>RequestInterceptor</code> interface</p> <p>You can define method <code>beforeRequest</code> for particular resource: <pre><code>beforeRequest(context.Context, r *http.Request, verb string, url string, body io.Reader) error\n</code></pre></p> <p>Parameters:</p> <ul> <li>ctx: The request context, useful for deadlines, tracing, or cancellation.</li> <li>verb: The HTTP method (e.g., GET, POST, PUT).</li> <li>url: The URL path being accessed (including query params)</li> <li>body: The request body as an io.Reader, typically containing JSON data.</li> </ul> <p>Or you can define method <code>afterRequest</code>:</p> <pre><code>afterRequest(ctx context.Context, response Renderable) (Renderable, error)\n</code></pre> <p>Parameters:</p> <ul> <li>ctx: The request context, useful for deadlines, tracing, or cancellation.</li> <li>response: Resources that implement Renderable interface (Record, RecordSet)</li> </ul> <p>At this moment I don't have practical example for <code>beforeRequest</code>. Probably it can be used for logging etc.</p> <p>For <code>afterRequest</code> good example is <code>Snapshot</code> resource:</p> <pre><code>type Snapshot struct {\n    *VastResource\n}\n\nfunc (s *Snapshot) afterRequest(ctx context.Context, response Renderable) (Renderable, error) {\n    // List of snapshots is returned under \"results\" key\n    return applyCallbackForRecordUnion[RecordSet](response, func(r Renderable) (Renderable, error) {\n        // This callback is only invoked if response is a RecordSet\n        if rawMap, ok := any(r).(map[string]interface{}); ok {\n            if inner, found := rawMap[\"results\"]; found {\n                if list, ok := inner.([]map[string]any); ok {\n                    return toRecordSet(list)\n                }\n            }\n        }\n        return r, nil\n    })\n}\n</code></pre> <p>Here in case of <code>RecordSet</code> (List endpoint) list of snapshot records are returned under <code>results</code> key. IOW smth like: <pre><code>{\n  \"results\": [\n    {\n      \"name\": \"snapshot1\",  .. other fields\n    },\n    {\n      \"name\": \"snapshot2\" .. other fields\n    }\n  ]\n}\n</code></pre></p> <p>So make sense to get <code>results</code> value and return only it to avoid additional parsing of returned Record.</p>"},{"location":"DEVELOPER/#typed-resources-auto-generation","title":"Typed Resources Auto-Generation","text":"<p>The go-vast-client supports automatic generation of typed resources that provide compile-time type safety and better IDE support. This system uses APIBuilder markers to define how to generate typed structs and methods.</p>"},{"location":"DEVELOPER/#generating-typed-resources","title":"Generating Typed Resources","text":"<p>To generate all typed resources:</p> <pre><code>make generate-typed\n</code></pre> <p>This command: 1. Scans <code>vast_resource.go</code> for resources with APIBuilder markers 2. Generates typed structs based on OpenAPI schema 3. Creates typed methods with proper request/response types 4. Formats the generated code with <code>go fmt</code></p> <p>Generated files are placed in the <code>typed/</code> directory: - <code>rest.go</code> - Typed VMSRest client - <code>&lt;resource&gt;.go</code> - Individual typed resource implementations (e.g., <code>quota.go</code>, <code>user.go</code>)</p>"},{"location":"DEVELOPER/#apibuilder-markers","title":"APIBuilder Markers","text":"<p>APIBuilder markers are Go comments that define how to generate typed resources. They must be placed directly above the resource struct definition.</p>"},{"location":"DEVELOPER/#required-markers","title":"Required Markers","text":"<p>Every resource must have:</p> <ol> <li>Search Query Marker - Defines how to search/list resources</li> <li>Model Marker - Defines the response structure</li> </ol> <p>Non-read-only resources also need:</p> <ol> <li>Request Body Marker - Defines the structure for create/update operations</li> </ol>"},{"location":"DEVELOPER/#search-query-markers","title":"Search Query Markers","text":"<p>Define how to generate search parameters for listing and filtering resources:</p> <pre><code>// +apityped:searchQuery:GET=&lt;endpoint&gt;\n// +apityped:searchQuery:SCHEMA=&lt;SchemaName&gt;\n</code></pre> <p>Examples: <pre><code>// Use GET endpoint parameters\n// +apityped:searchQuery:GET=quotas\n\n// Use specific OpenAPI schema\n// +apityped:searchQuery:SCHEMA=QuotaSearchParams\n</code></pre></p> <p>Generated: <code>&lt;Resource&gt;SearchParams</code> struct with fields for filtering.</p>"},{"location":"DEVELOPER/#request-body-markers","title":"Request Body Markers","text":"<p>Define the structure for create and update operations:</p> <pre><code>// +apityped:requestBody:POST=&lt;endpoint&gt;\n// +apityped:requestBody:PUT=&lt;endpoint&gt;  \n// +apityped:requestBody:PATCH=&lt;endpoint&gt;\n// +apityped:requestBody:SCHEMA=&lt;SchemaName&gt;\n</code></pre> <p>Examples: <pre><code>// Use POST endpoint request body\n// +apityped:requestBody:POST=quotas\n\n// Use specific OpenAPI schema\n// +apityped:requestBody:SCHEMA=QuotaCreateRequest\n</code></pre></p> <p>Generated: <code>&lt;Resource&gt;RequestBody</code> struct for create/update operations.</p>"},{"location":"DEVELOPER/#model-markers","title":"Model Markers","text":"<p>Define the response structure for API operations:</p> <pre><code>// +apityped:model:GET=&lt;endpoint&gt;\n// +apityped:model:POST=&lt;endpoint&gt;\n// +apityped:model:PUT=&lt;endpoint&gt;\n// +apityped:model:DELETE=&lt;endpoint&gt;\n// +apityped:model:PATCH=&lt;endpoint&gt;\n// +apityped:model:SCHEMA=&lt;SchemaName&gt;\n</code></pre> <p>Examples: <pre><code>// Use POST endpoint response\n// +apityped:model:POST=quotas\n\n// Use specific OpenAPI schema  \n// +apityped:model:SCHEMA=Quota\n</code></pre></p> <p>Generated: <code>&lt;Resource&gt;Model</code> struct for API responses.</p>"},{"location":"DEVELOPER/#read-only-marker","title":"Read-Only Marker","text":"<p>For resources that don't support create/update/delete operations:</p> <pre><code>// +apityped:readOnly\n</code></pre> <p>Read-only resources only generate <code>Get*</code>, <code>List*</code>, <code>Exists*</code>, and <code>MustExists*</code> methods.</p>"},{"location":"DEVELOPER/#complete-resource-examples","title":"Complete Resource Examples","text":""},{"location":"DEVELOPER/#full-crud-resource","title":"Full CRUD Resource","text":"<pre><code>// +apityped:searchQuery:GET=quotas\n// +apityped:requestBody:POST=quotas  \n// +apityped:model:SCHEMA=Quota\ntype Quota struct {\n    *VastResource\n}\n</code></pre> <p>Generates: - <code>QuotaSearchParams</code> - for filtering/searching - <code>QuotaRequestBody</code> - for create/update operations - <code>QuotaModel</code> - for API responses - Full CRUD methods: <code>Create</code>, <code>Update</code>, <code>Delete</code>, <code>Get</code>, <code>List</code>, <code>Ensure</code>, etc.</p>"},{"location":"DEVELOPER/#read-only-resource","title":"Read-Only Resource","text":"<pre><code>// +apityped:readOnly\n// +apityped:searchQuery:GET=versions\n// +apityped:model:SCHEMA=Version\ntype Version struct {\n    *VastResource  \n}\n</code></pre> <p>Generates: - <code>VersionSearchParams</code> - for filtering/searching - <code>VersionModel</code> - for API responses - Read-only methods: <code>Get</code>, <code>List</code>, <code>Exists</code>, <code>MustExists</code> (no Create/Update/Delete)</p>"},{"location":"DEVELOPER/#using-schema-references","title":"Using Schema References","text":"<pre><code>// +apityped:searchQuery:SCHEMA=UserSearchCriteria\n// +apityped:requestBody:SCHEMA=UserCreateRequest\n// +apityped:model:SCHEMA=User\ntype User struct {\n    *VastResource\n}\n</code></pre> <p>This approach uses specific OpenAPI schema definitions instead of endpoint-derived schemas.</p>"},{"location":"DEVELOPER/#generated-struct-features","title":"Generated Struct Features","text":"<p>All generated structs include:</p> <ul> <li>JSON Tags: For serialization (<code>json:\"field_name,omitempty\"</code>)</li> <li>YAML Tags: For YAML support (<code>yaml:\"field_name,omitempty\"</code>)  </li> <li>Required Tags: Field requirement info (<code>required:\"true/false\"</code>)</li> <li>Doc Tags: Field documentation (<code>doc:\"Field description\"</code>)</li> <li>Type Safety: Proper Go types (string, int64, bool, etc.)</li> <li>Nested Structs: For complex object fields</li> <li>Pointer Fields: For arrays and objects to handle <code>omitempty</code> correctly</li> </ul>"},{"location":"DEVELOPER/#generated-methods","title":"Generated Methods","text":"<p>Typed resources provide the same methods as untyped resources but with typed parameters:</p> <p>Standard Methods: - <code>Get(req *SearchParams) (*Model, error)</code> - <code>List(req *SearchParams) ([]*Model, error)</code> - <code>Create(req *RequestBody) (*Model, error)</code> - <code>Update(id any, req *RequestBody) (*Model, error)</code> - <code>Delete(req *SearchParams) error</code> - <code>Ensure(searchParams *SearchParams, body *RequestBody) (*Model, error)</code></p> <p>Context Methods: - <code>GetWithContext(ctx context.Context, req *SearchParams) (*Model, error)</code> - <code>ListWithContext(ctx context.Context, req *SearchParams) ([]*Model, error)</code> - And so on...</p>"},{"location":"DEVELOPER/#accessing-untyped-methods","title":"Accessing Untyped Methods","text":"<p>From any typed resource, you can access the underlying untyped client:</p> <pre><code>// Access untyped methods when needed\nrecord, err := typedRest.Untyped.Quotas.GetWithContext(ctx, params)\n</code></pre>"},{"location":"DEVELOPER/#troubleshooting-generation","title":"Troubleshooting Generation","text":"<p>Common Issues:</p> <ol> <li>Missing Markers: Ensure all required markers are present</li> <li>Invalid Schema Names: Verify schema names exist in OpenAPI spec</li> <li>Compilation Errors: Check generated code for syntax issues</li> <li>Missing Fields: Verify OpenAPI schema completeness</li> </ol> <p>Debug Generation: <pre><code># Verbose generation output\ncd autogen &amp;&amp; go run ./cmd/generate-typed-resources\n</code></pre></p>"},{"location":"DEVELOPER/#adding-new-resources-for-typed-generation","title":"Adding New Resources for Typed Generation","text":"<ol> <li>Add APIBuilder markers to your resource in <code>vast_resource.go</code></li> <li>Ensure the resource exists in the untyped <code>VMSRest</code> struct</li> <li>Run <code>make generate-typed</code></li> <li>Verify generated code compiles: <code>go build ./typed/...</code></li> </ol>"},{"location":"DEVELOPER/#release-new-version-of-the-client","title":"Release new version of the client","text":"<p>To release a new version of the client:</p> <ol> <li>Update the version in <code>version</code> file.</li> <li>Push changes to the <code>main</code> branch.</li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>This struct configures how the client connects to the VAST API.</p> <p>Example with all fields:</p> <pre><code>config := &amp;client.VMSConfig{\n    Host:           \"10.27.40.1\",\n    Port:           443,\n    Username:       \"admin\",\n    Password:       \"123456\",\n    ApiToken:       \"\",        // Alternative to Username/Password\n    UseBasicAuth:   false,     // Use HTTP Basic Auth instead of JWT\n    Tenant:         \"mytenant\", // Optional tenant for scoped authentication\n    SslVerify:      true,\n    Timeout:        &amp;timeout,\n    MaxConnections: 10,\n    UserAgent:      \"vast-go-client/1.0\",\n    ApiVersion:     \"v5\",\n    Context:        ctx,       // Optional external context for request control\n    BeforeRequestFn: func(ctx context.Context, r *http.Request, verb, url string, body io.Reader) error {\n        log.Printf(\"Request: %s %s\", verb, url)\n        return nil\n    },\n    AfterRequestFn: func(ctx context.Context, response client.Renderable) (client.Renderable, error) {\n        log.Println(response.PrettyTable())\n        return response, nil\n    },\n}\n</code></pre> Field Type Description Required Default <code>Host</code> <code>string</code> Hostname or IP of the VMS API server. \u2705 \u2014 <code>Port</code> <code>uint64</code> Port for the API server. \u274c <code>443</code> <code>Username</code> <code>string</code> Username for authentication (used with <code>Password</code>). \u26a0\ufe0f \u2014 <code>Password</code> <code>string</code> Password for authentication (used with <code>Username</code>). \u26a0\ufe0f \u2014 <code>ApiToken</code> <code>string</code> Optional API token (alternative to username/password). Takes priority over other auth methods. \u26a0\ufe0f \u2014 <code>UseBasicAuth</code> <code>bool</code> Use HTTP Basic Authentication instead of JWT (requires <code>Username</code>/<code>Password</code>). \u274c <code>false</code> <code>Tenant</code> <code>string</code> Optional tenant name for tenant scoped authentication (tenant admin). \u274c \u2014 <code>SslVerify</code> <code>bool</code> Verify SSL certificates when <code>true</code>. \u274c <code>false</code> <code>Timeout</code> <code>*time.Duration</code> HTTP timeout for API requests. If <code>nil</code>, a default is used. \u274c <code>30s</code> <code>MaxConnections</code> <code>int</code> Max concurrent HTTP connections. \u274c <code>10</code> <code>UserAgent</code> <code>string</code> Optional custom <code>User-Agent</code> string for HTTP requests. \u274c <code>vast-go-client</code> <code>ApiVersion</code> <code>string</code> Optional API version to use for requests. \u274c <code>v5</code> <code>Context</code> <code>context.Context</code> Optional external context for controlling HTTP request lifecycle. Used as parent context for all requests. \u274c <code>nil</code> <code>BeforeRequestFn</code> <code>func(ctx context.Context, r *http.Request, verb, url string, body io.Reader) error</code> Optional hook executed before each request. Useful for logging or mutation. \u274c \u2014 <code>AfterRequestFn</code> <code>func(ctx context.Context, response Renderable) (Renderable, error)</code> Optional hook executed after receiving a response. Useful for logging or mutation. \u274c \u2014"},{"location":"configuration/#authentication-methods","title":"Authentication Methods","text":"<p>The client supports three authentication methods with the following priority:</p> <ol> <li>API Token (highest priority) - if <code>ApiToken</code> is provided</li> <li>HTTP Basic Authentication - if <code>UseBasicAuth=true</code> AND <code>Username/Password</code> are provided</li> <li>JWT Authentication (default) - if <code>Username/Password</code> are provided</li> </ol>"},{"location":"configuration/#jwt-authentication-default","title":"JWT Authentication (Default)","text":"<pre><code>config := &amp;client.VMSConfig{\n    Host:     \"10.27.40.1\",\n    Username: \"admin\",\n    Password: \"secret\",\n    // UseBasicAuth: false (or omitted) - uses JWT by default\n}\n</code></pre>"},{"location":"configuration/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<pre><code>config := &amp;client.VMSConfig{\n    Host:         \"10.27.40.1\",\n    Username:     \"admin\",\n    Password:     \"secret\",\n    UseBasicAuth: true,  // Enable Basic Auth\n}\n</code></pre>"},{"location":"configuration/#api-token-authentication","title":"API Token Authentication","text":"<pre><code>config := &amp;client.VMSConfig{\n    Host:     \"10.27.40.1\",\n    ApiToken: \"your-api-token-here\",\n    // ApiToken always takes precedence\n}\n</code></pre>"},{"location":"configuration/#context-usage","title":"Context Usage","text":"<p>The <code>Context</code> field allows you to control the lifecycle of all HTTP requests:</p>"},{"location":"configuration/#request-timeout","title":"Request Timeout","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\nconfig := &amp;client.VMSConfig{\n    Host:    \"10.27.40.1\",\n    Context: ctx,  // All requests will respect this 30s timeout\n}\n</code></pre>"},{"location":"configuration/#request-cancellation","title":"Request Cancellation","text":"<pre><code>ctx, cancel := context.WithCancel(context.Background())\n\nconfig := &amp;client.VMSConfig{\n    Host:    \"10.27.40.1\",\n    Context: ctx,\n}\n\n// Later: cancel all in-flight requests\ncancel()\n</code></pre>"},{"location":"errors/","title":"Errors","text":"<p>The VAST client can return two categories of errors:</p>"},{"location":"errors/#1-api-errors-from-vast-backend","title":"1. API Errors (from VAST backend)","text":"<p>These are errors returned by the VAST server, such as:</p> <p>They are represented by the <code>ApiError</code> type.</p> <pre><code>type ApiError struct {\n    Method     string\n    URL        string\n    StatusCode int\n    Body       string\n}\n</code></pre> <p>Helpers:</p> Helper Function Description <code>IsApiError(err error) bool</code> Checks if the error is of type <code>*ApiError</code> <code>IgnoreStatusCodes(err, codes...) error</code> Ignores the error if its HTTP status is in <code>codes</code>"},{"location":"errors/#2-validation-errors-from-client-side-logic","title":"2. Validation Errors (from client-side logic)","text":"<p>These are raised after an HTTP request is sent, such as:</p> <p>Common validation errors include:</p> <ul> <li><code>NotFoundError</code>: Resource not found - for methods which expect at least one record to be returned.</li> <li><code>TooManyRecordsError</code>: More than one record found - for methods which expect a single record to be returned.</li> </ul> <pre><code>type NotFoundError struct {\n    Resource string\n    Query    string\n}\n\ntype TooManyRecordsError struct {\n    ResourcePath string\n    Params       Params\n}\n</code></pre> <p>Helpers:</p> Helper Function Description <code>IsNotFoundErr(err error) bool</code> Checks if error is <code>*NotFoundError</code> <code>IgnoreNotFound(record, err) (record, error)</code> Returns <code>record, nil</code> if error is <code>NotFoundError</code>"},{"location":"iterators/","title":"Iterators","text":""},{"location":"iterators/#overview","title":"Overview","text":"<p>Iterators provide low-level access to paginated API responses. For most use cases, you should use <code>List()</code> or <code>ListWithContext()</code> methods instead, which automatically fetch all pages and return complete results.</p> <p>Use iterators only when you need fine-grained control over pagination, such as: - Processing very large datasets page-by-page to limit memory usage - Implementing custom pagination logic - Early termination based on page contents</p>"},{"location":"iterators/#basic-usage","title":"Basic Usage","text":""},{"location":"iterators/#simple-iteration","title":"Simple Iteration","text":"<pre><code>// Create an iterator with page size of 50\niter := resource.GetIterator(core.Params{\"name__contains\": \"test\"}, 50)\n\n// Iterate through pages\nfor {\n    records, err := iter.Next()\n    if err != nil {\n        log.Fatalf(\"Error: %v\", err)\n    }\n    if len(records) == 0 {\n        break // No more pages\n    }\n\n    // Process current page\n    for _, record := range records {\n        fmt.Printf(\"ID: %v, Name: %v\\n\", record[\"id\"], record[\"name\"])\n    }\n}\n</code></pre>"},{"location":"iterators/#using-context","title":"Using Context","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\niter := resource.GetIteratorWithContext(ctx, core.Params{}, 100)\n\nfor {\n    records, err := iter.Next()\n    if err != nil {\n        log.Fatalf(\"Error: %v\", err)\n    }\n    if len(records) == 0 {\n        break\n    }\n    // Process records...\n}\n</code></pre>"},{"location":"iterators/#fetch-all-pages-at-once","title":"Fetch All Pages at Once","text":"<pre><code>iter := resource.GetIterator(core.Params{}, 100)\n\n// Fetch all pages into a single RecordSet\nallRecords, err := iter.All()\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\nfmt.Printf(\"Total records: %d\\n\", len(allRecords))\n</code></pre>"},{"location":"iterators/#iterator-methods","title":"Iterator Methods","text":"<pre><code>type Iterator interface {\n    Next() (RecordSet, error)          // Advance to next page\n    Previous() (RecordSet, error)      // Go to previous page\n    HasNext() bool                     // Check if next page exists\n    HasPrevious() bool                 // Check if previous page exists\n    Count() int                        // Total count (-1 if unknown)\n    PageSize() int                     // Current page size\n    Reset() (RecordSet, error)         // Reset to first page\n    All() (RecordSet, error)           // Fetch all remaining pages\n}\n</code></pre>"},{"location":"iterators/#configuration","title":"Configuration","text":""},{"location":"iterators/#global-page-size","title":"Global Page Size","text":"<pre><code>config := &amp;core.VMSConfig{\n    Host:     \"vast.example.com\",\n    ApiToken: \"your-token\",\n    PageSize: 100,  // Default for all iterators (0 = server default)\n}\n</code></pre>"},{"location":"iterators/#per-iterator-page-size","title":"Per-Iterator Page Size","text":"<pre><code>// Use config default (0 = no page_size param, server decides)\niter := resource.GetIterator(params, 0)\n\n// Override with specific page size\niter := resource.GetIterator(params, 50)\n</code></pre>"},{"location":"iterators/#prefer-list-over-iterators","title":"Prefer List() Over Iterators","text":"<p>Recommended approach for most use cases:</p> <pre><code>// Simple and straightforward - fetches all pages automatically\nrecords, err := resource.List(core.Params{\"status\": \"active\"})\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\n// Process all records\nfor _, record := range records {\n    fmt.Printf(\"Processing: %v\\n\", record[\"name\"])\n}\n</code></pre> <p>Use iterators only when needed:</p> <pre><code>// Example: Process large dataset page-by-page to limit memory\niter := resource.GetIterator(core.Params{}, 1000)\nprocessedCount := 0\n\nfor {\n    records, err := iter.Next()\n    if err != nil || len(records) == 0 {\n        break\n    }\n\n    for _, record := range records {\n        // Process one record at a time\n        processRecord(record)\n        processedCount++\n    }\n\n    log.Printf(\"Processed %d records so far...\\n\", processedCount)\n}\n</code></pre>"},{"location":"iterators/#api-support","title":"API Support","text":"<p>Iterators handle both paginated and non-paginated endpoints transparently: - Paginated responses: Responses with <code>results</code>, <code>count</code>, <code>next</code>, <code>previous</code> fields - Non-paginated responses: Flat arrays are treated as a single page</p> <p>The iterator automatically detects the response format and adapts accordingly.</p>"},{"location":"resource-lock/","title":"Resource Lock","text":"<p>In concurrent applications, it's common for multiple operations  to target the same backend resource at the same time \u2014  such as modifying the same user, group, or bucket. To prevent race conditions and ensure consistency,  the vast_client provides a built-in resource locking mechanism.</p> <p>You can use resource locks to:</p> <ul> <li>Ensures that only one operation at a time can modify a specific resource.</li> <li>Prevents conflicts when working with shared data.</li> <li>Helps maintain API consistency during complex or multi-step operations.</li> </ul> <p>Call the <code>Lock()</code> method on a resource before performing operations that should not overlap.  Always use defer to ensure the lock is released automatically:</p> <pre><code>defer rest.Users.Lock(\"uid\", 3001)()\n// safely perform operations on user with uid=3001\n</code></pre> <p>Lock using a specific key (e.g. ID, name): <pre><code>defer rest.Groups.Lock(\"gid\", 1001)()\n</code></pre></p> <p>Lock using multiple keys (for composite identity): <pre><code>defer rest.Quotas.Lock(\"tenant\", 1, \"path\", \"/shared\")()\n</code></pre></p> <p>Lock with no key (acts as a general-purpose lock using an empty string): <pre><code>defer rest.Users.Lock()()\n</code></pre></p>"},{"location":"response/","title":"API Responses","text":"<p>API operations return different response types depending on whether you're using the typed or untyped client.</p>"},{"location":"response/#response-types-by-client","title":"Response Types by Client","text":""},{"location":"response/#typed-client-responses","title":"Typed Client Responses","text":"<p>The typed client returns strongly-typed structs for all operations:</p> <pre><code>rest, _ := client.NewTypedVMSRest(config)\n\n// Returns *typed.ViewUpsertModel\nview, err := rest.Views.Create(body)\n\n// Returns []typed.ViewDetailsModel\nviews, err := rest.Views.List(nil)\n\n// Returns *typed.ViewDetailsModel\nview, err := rest.Views.Get(searchParams)\n</code></pre> <p>Benefits: - Compile-time type safety - IDE autocomplete for all fields - Clear struct definitions - No need for type assertions or manual unmarshaling</p>"},{"location":"response/#untyped-client-responses","title":"Untyped Client Responses","text":"<p>The untyped client returns flexible map-based types:</p> <ul> <li><code>core.Record</code>: Single record (key-value map: <code>map[string]any</code>). Can be empty (<code>Record{}</code>) for operations like DELETE.</li> <li><code>core.RecordSet</code>: List of records (<code>[]map[string]any</code>)</li> </ul> <pre><code>rest, _ := client.NewVMSRest(config)\n\n// Returns core.Record\nrecord, err := rest.Views.Create(params)\n\n// Returns core.RecordSet\nrecordSet, err := rest.Views.List(params)\n</code></pre> <p>These types implement the <code>core.Renderable</code> interface with formatting and data-extraction methods.</p>"},{"location":"response/#working-with-typed-responses","title":"Working with Typed Responses","text":"<p>Typed responses are Go structs with strongly-typed fields:</p> <pre><code>rest, _ := client.NewTypedVMSRest(config)\n\nview, err := rest.Views.Get(&amp;typed.ViewSearchParams{Name: \"myview\"})\nif err != nil {\n    log.Fatal(err)\n}\n\n// Direct field access with type safety\nfmt.Printf(\"View ID: %d\\n\", view.Id)\nfmt.Printf(\"View Name: %s\\n\", view.Name)\nfmt.Printf(\"View Path: %s\\n\", view.Path)\n\n// Work with nested structs\nif view.Protocols != nil {\n    for _, protocol := range *view.Protocols {\n        fmt.Printf(\"Protocol: %s\\n\", protocol)\n    }\n}\n</code></pre>"},{"location":"response/#working-with-untyped-responses","title":"Working with Untyped Responses","text":"<p>Untyped responses provide helper methods for display and data extraction.</p>"},{"location":"response/#display-output","title":"Display Output","text":"Method Description Output Style <code>PrettyTable()</code> Render response as a formatted table Grid-like CLI table <code>PrettyJson()</code> Render response as pretty-printed JSON Indented/compact JSON <p>Example:</p> <pre><code>rest, _ := client.NewVMSRest(config)\n\nrecord, err := rest.Views.Get(client.Params{\"name\": \"myview\"})\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Println(record.PrettyTable())\nfmt.Println(record.PrettyJson(\"  \"))\n</code></pre>"},{"location":"response/#common-attribute-access","title":"Common Attribute Access","text":"<p>You can extract frequently used fields directly from a response object:</p> Method Description Source Key <code>RecordID()</code> Returns record ID as <code>int64</code> <code>\"id\"</code> <code>RecordName()</code> Returns name as <code>string</code> <code>\"name\"</code> <code>RecordTenantID()</code> Returns tenant ID as <code>int64</code> <code>\"tenant_id\"</code> <code>RecordTenantName()</code> Returns tenant name as <code>string</code> <code>\"tenant_name\"</code> <code>RecordGUID()</code> Returns GUID as <code>string</code> <code>\"guid\"</code> <p>Example:</p> <pre><code>rest, _ := client.NewVMSRest(config)\n\nrecord, err := rest.Views.Get(client.Params{\"name\": \"myview\"})\nif err != nil {\n    log.Fatal(err)\n}\n\n// Direct map access\nviewID := record.RecordID()\nviewName := record.RecordName()\nfmt.Printf(\"View: %s (ID: %d)\\n\", viewName, viewID)\n</code></pre>"},{"location":"response/#converting-untyped-to-typed-with-fill","title":"Converting Untyped to Typed with Fill()","text":"<p>Untyped responses can be converted to Go structs using the <code>Fill()</code> method:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    client \"github.com/vast-data/go-vast-client\"\n)\n\n// Custom struct that mirrors the expected API response\ntype ViewData struct {\n    ID       int64  `json:\"id\"`\n    Name     string `json:\"name\"`\n    Path     string `json:\"path\"`\n    TenantID int64  `json:\"tenant_id\"`\n}\n\nfunc main() {\n    config := &amp;client.VMSConfig{\n        Host:     \"10.27.40.1\",\n        Username: \"admin\",\n        Password: \"123456\",\n    }\n\n    // Use untyped client\n    rest, err := client.NewVMSRest(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Get untyped response\n    record, err := rest.Views.Get(client.Params{\"name\": \"myview\"})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Fill custom struct from untyped response\n    var view ViewData\n    if err := record.Fill(&amp;view); err != nil {\n        log.Fatalf(\"failed to fill struct: %v\", err)\n    }\n\n    fmt.Printf(\"View: %s (ID: %d, Path: %s)\\n\", view.Name, view.ID, view.Path)\n}\n</code></pre>"},{"location":"session/","title":"Session API","text":"<p>The Session API provides low-level HTTP access when you need more control over requests or need to access endpoints not exposed through the typed/untyped resource clients.</p>"},{"location":"session/#when-to-use-session","title":"When to Use Session","text":"<ul> <li>Custom or undocumented API endpoints</li> <li>Direct control over HTTP methods and paths</li> <li>Custom request headers or parameters</li> <li>Endpoints not yet available in resource clients</li> </ul>"},{"location":"session/#available-methods","title":"Available Methods","text":"<p>Session implements 5 HTTP methods:</p> <ul> <li>Get - Retrieve resources</li> <li>Post - Create resources</li> <li>Put - Replace resources</li> <li>Patch - Update resources</li> <li>Delete - Remove resources</li> </ul>"},{"location":"session/#accessing-session","title":"Accessing Session","text":"<p>Both typed and untyped clients provide access to the Session API:</p> <pre><code>// From typed client\ntypedRest, _ := client.NewTypedVMSRest(config)\nsession := typedRest.GetSession()\n\n// From untyped client\nrest, _ := client.NewVMSRest(config)\nsession := rest.GetSession()\n</code></pre> <p>Note: Session methods always return untyped data (<code>core.Record</code> or <code>core.RecordSet</code>), even when accessed from a typed client.</p>"},{"location":"session/#example-usage","title":"Example Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    client \"github.com/vast-data/go-vast-client\"\n    \"github.com/vast-data/go-vast-client/core\"\n)\n\nfunc main() {\n    config := &amp;client.VMSConfig{\n        Host:     \"10.27.40.1\",\n        Username: \"admin\",\n        Password: \"123456\",\n    }\n\n    // Can use either typed or untyped client\n    rest, err := client.NewVMSRest(config)\n    if err != nil {\n        panic(err)\n    }\n\n    ctx := context.Background()\n\n    // Get view by name using query parameter\n    path := \"views?name=myview\"\n    result, err := rest.Session.Get(ctx, path, nil, nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Session returns untyped data\n    recordSet := result.(core.RecordSet)\n    if !recordSet.Empty() {\n        firstRecord := recordSet[0]\n        viewID := firstRecord.RecordID()\n\n        // Get view by ID\n        path = fmt.Sprintf(\"views/%d\", viewID)\n        result, err = rest.Session.Get(ctx, path, nil, nil)\n        if err != nil {\n            panic(err)\n        }\n\n        record := result.(core.Record)\n        fmt.Printf(\"View name: %s\\n\", record[\"name\"])\n    } else {\n        log.Println(\"No records found\")\n    }\n}\n</code></pre>"},{"location":"session/#custom-headers-and-parameters","title":"Custom Headers and Parameters","text":"<p>You can pass custom parameters and headers to Session methods:</p> <pre><code>// Using query parameters (note: for GET, params go in the URL, not as separate arg)\nresult, err := session.Get(ctx, \"views?name=myview&amp;limit=10&amp;offset=0\", nil, nil)\n\n// POST with request body\nbody := client.Params{\n    \"name\": \"newview\",\n    \"path\": \"/newview\",\n}\nresult, err := session.Post(ctx, \"views\", body, nil)\n\n// PATCH to update\nupdateBody := client.Params{\n    \"protocols\": []string{\"NFS\", \"SMB\"},\n}\nresult, err := session.Patch(ctx, \"views/123\", updateBody, nil)\n\n// DELETE\nresult, err := session.Delete(ctx, \"views/123\", nil, nil)\n\n// Using custom headers\ncustomHeaders := []http.Header{\n    {\"X-Custom-Header\": []string{\"value\"}},\n}\nresult, err := session.Get(ctx, \"views\", nil, customHeaders)\n</code></pre>"},{"location":"vmsrest/","title":"REST Clients","text":"<p>After configuration, you can use one of two REST client types:</p>"},{"location":"vmsrest/#client-types","title":"Client Types","text":""},{"location":"vmsrest/#typed-rest-client","title":"Typed REST Client","text":"<p>The typed client provides strongly-typed structs for all requests and responses:</p> <pre><code>import (\n    client \"github.com/vast-data/go-vast-client\"\n    \"github.com/vast-data/go-vast-client/resources/typed\"\n)\n\n// Initialize typed client\nrest, err := client.NewTypedVMSRest(config)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Use typed structs for requests and responses\nsearchParams := &amp;typed.QuotaSearchParams{\n    Name: \"my-quota\",\n}\n\nbody := &amp;typed.QuotaRequestBody{\n    Name:      \"my-quota\",\n    Path:      \"/data\",\n    HardLimit: 1099511627776, // 1TB\n}\n\nquota, err := rest.Quotas.Ensure(searchParams, body)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p>Benefits: - Type Safety: Compile-time checking of request/response structures - IDE Support: Better autocomplete and documentation - Clear Contracts: Explicit field types and requirements - Reduced Errors: Invalid field names caught at compile time</p>"},{"location":"vmsrest/#untyped-rest-client","title":"Untyped REST Client","text":"<p>The untyped client uses flexible <code>map[string]any</code> for parameters and responses:</p> <pre><code>import client \"github.com/vast-data/go-vast-client\"\n\n// Initialize untyped client\nrest, err := client.NewVMSRest(config)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Use Params maps for requests\nresult, err := rest.Quotas.Create(client.Params{\n    \"name\":       \"my-quota\",\n    \"path\":       \"/data\",\n    \"hard_limit\": 1099511627776, // 1TB\n})\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p>Use Cases: - Dynamic scenarios where field names are not known at compile time - Prototyping and experimentation - Working with custom or undocumented API fields</p>"},{"location":"vmsrest/#accessing-untyped-client-from-typed","title":"Accessing Untyped Client from Typed","text":"<p>If you're using the typed client but need untyped access for specific operations, you can access the underlying untyped client:</p> <pre><code>rest, err := client.NewTypedVMSRest(config)\n\n// Access untyped client when needed\nuntypedRest := rest.Untyped\nrecord, err := untypedRest.Quotas.GetWithContext(ctx, client.Params{\"name\": \"my-quota\"})\n</code></pre>"},{"location":"vmsrest/#standard-resource-methods","title":"Standard Resource Methods","text":"<p>Both typed and untyped clients support standard CRUD methods for each resource (subject to API permissions):</p>"},{"location":"vmsrest/#basic-methods","title":"Basic Methods","text":"<ul> <li><code>List</code> / <code>ListWithContext</code> - List all resources</li> <li><code>Get</code> / <code>GetWithContext</code> - Get a resource by search parameters</li> <li><code>Create</code> / <code>CreateWithContext</code> - Create a new resource</li> <li><code>Update</code> / <code>UpdateWithContext</code> - Update an existing resource</li> <li><code>Delete</code> / <code>DeleteWithContext</code> - Delete a resource</li> <li><code>Ensure</code> / <code>EnsureWithContext</code> - Create if doesn't exist, return if exists</li> </ul>"},{"location":"vmsrest/#context-aware-methods","title":"Context-Aware Methods","text":"<p>All methods have <code>WithContext</code> variants that accept a <code>context.Context</code> as the first parameter. These are useful when you need to:</p> <ul> <li>Set custom timeouts per request</li> <li>Cancel long-running operations</li> <li>Propagate request-scoped values (tracing, logging, etc.)</li> </ul> <pre><code>// Example: Request with timeout\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nview, err := rest.Views.GetWithContext(ctx, searchParams)\n</code></pre>"},{"location":"vmsrest/#example-usage-comparison","title":"Example Usage Comparison","text":""},{"location":"vmsrest/#creating-a-view","title":"Creating a View","text":"<p>Typed Client: <pre><code>import (\n    client \"github.com/vast-data/go-vast-client\"\n    \"github.com/vast-data/go-vast-client/resources/typed\"\n)\n\nrest, _ := client.NewTypedVMSRest(config)\n\nbody := &amp;typed.ViewRequestBody{\n    Name:      \"myview\",\n    Path:      \"/myview\",\n    Protocols: &amp;[]string{\"NFS\"},\n    PolicyId:  1,\n    CreateDir: true,\n}\n\nview, err := rest.Views.Create(body)\n</code></pre></p> <p>Untyped Client: <pre><code>import client \"github.com/vast-data/go-vast-client\"\n\nrest, _ := client.NewVMSRest(config)\n\nresult, err := rest.Views.Create(client.Params{\n    \"name\":       \"myview\",\n    \"path\":       \"/myview\",\n    \"protocols\":  []string{\"NFS\"},\n    \"policy_id\":  1,\n    \"create_dir\": true,\n})\n</code></pre></p>"},{"location":"vmsrest/#getting-a-user","title":"Getting a User","text":"<p>Typed Client: <pre><code>user, err := rest.Users.Get(&amp;typed.UserSearchParams{Name: \"admin\"})\n</code></pre></p> <p>Untyped Client: <pre><code>user, err := rest.Users.Get(client.Params{\"name\": \"admin\"})\n</code></pre></p>"}]}