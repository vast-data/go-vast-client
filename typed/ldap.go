// Code generated by generate-typed-resources. DO NOT EDIT.

package typed

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"

	vast_client "github.com/vast-data/go-vast-client"
)

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// LdapSearchParams represents the search parameters for Ldap operations
// Generated from GET query parameters for resource: ldaps
type LdapSearchParams struct {
	Guid     string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:""`
	TenantId int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Tenant ID"`
	Uid      string `json:"uid,omitempty" yaml:"uid,omitempty" required:"false" doc:""`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// LdapRequestBody represents the request body for Ldap operations
// Generated from POST request body for resource: ldaps
type LdapRequestBody struct {
	Bindpw                     string    `json:"bindpw,omitempty" yaml:"bindpw,omitempty" required:"true" doc:"The password used with the Bind DN to authenticate to the LDAP server."`
	DomainName                 string    `json:"domain_name,omitempty" yaml:"domain_name,omitempty" required:"true" doc:"FQDN of Active Directory domain. Must be resolvable in DNS"`
	Method                     string    `json:"method,omitempty" yaml:"method,omitempty" required:"true" doc:"The authentication method configured on the LDAP server for authenticating clients."`
	Port                       int64     `json:"port,omitempty" yaml:"port,omitempty" required:"true" doc:"The port of the remote LDAP server. Typical values: 389, 636."`
	AbacReadOnlyValueName      string    `json:"abac_read_only_value_name,omitempty" yaml:"abac_read_only_value_name,omitempty" required:"false" doc:"The attribute to use when querying a provider for a read only attribute access check"`
	AbacReadWriteValueName     string    `json:"abac_read_write_value_name,omitempty" yaml:"abac_read_write_value_name,omitempty" required:"false" doc:"The attribute to use when querying a provider for a read-write attribute access check"`
	AdvancedFilter             string    `json:"advanced_filter,omitempty" yaml:"advanced_filter,omitempty" required:"false" doc:"Use this parameter to specify manual filters for the BaseDN. This is useful when accounts are distributed across OUs and the baseDN needs to be wide to include all accounts, while there are also accounts that you would like to exclude from user queries."`
	Binddn                     string    `json:"binddn,omitempty" yaml:"binddn,omitempty" required:"false" doc:"The bind DN for authenticating to the LDAP domain. You can specify any user account that has read access to the domain."`
	DomainsWithPosixAttributes string    `json:"domains_with_posix_attributes,omitempty" yaml:"domains_with_posix_attributes,omitempty" required:"false" doc:"Allows to enumerate specific domains for POSIX attributes in case posix_attributes_source is set to SPECIFIC_DOMAINS."`
	GidNumber                  string    `json:"gid_number,omitempty" yaml:"gid_number,omitempty" required:"false" doc:"The attribute of a group entry on the LDAP server that contains the GID number of a group, if different from 'gidNumber'. When binding VAST Cluster to AD, you may need to set this to 'gidnumber' (case sensitive)."`
	GroupLoginName             string    `json:"group_login_name,omitempty" yaml:"group_login_name,omitempty" required:"false" doc:"Specifies the attribute used to query Active Directory for the group login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	GroupSearchbase            string    `json:"group_searchbase,omitempty" yaml:"group_searchbase,omitempty" required:"false" doc:"Base DN for group queries within the joined domain only. When auto discovery is enabled, group queries outside the joined domain use auto-discovered Base DNs."`
	IsVmsAuthProvider          bool      `json:"is_vms_auth_provider,omitempty" yaml:"is_vms_auth_provider,omitempty" required:"false" doc:"Enables use of the LDAP for VMS authentication. Two LDAP configurations per cluster can be used for VMS authentication: one with Active Directory and one without."`
	MailPropertyName           string    `json:"mail_property_name,omitempty" yaml:"mail_property_name,omitempty" required:"false" doc:"Specifies the attribute to use for the user's email address."`
	MatchUser                  string    `json:"match_user,omitempty" yaml:"match_user,omitempty" required:"false" doc:"The attribute to use when querying a provider for a user that matches a user that was already retrieved from another provider. A user entry that contains a matching value in this attribute will be considered the same user as the user previously retrieved."`
	MonitorAction              string    `json:"monitor_action,omitempty" yaml:"monitor_action,omitempty" required:"false" doc:"The type of periodic health check that VAST Cluster performs for the Active Directory provider. PING (default, less overhead and impact on the provider) = pings the provider. BIND = binds to the provider."`
	PosixAccount               string    `json:"posix_account,omitempty" yaml:"posix_account,omitempty" required:"false" doc:"The object class that defines a user entry on the LDAP server, if different from 'posixAccount'. When binding VAST Cluster to AD, set this parameter to 'user' in order for authorization to work properly."`
	PosixAttributesSource      string    `json:"posix_attributes_source,omitempty" yaml:"posix_attributes_source,omitempty" required:"false" doc:"Defines which domains POSIX attributes will be supported from."`
	PosixGroup                 string    `json:"posix_group,omitempty" yaml:"posix_group,omitempty" required:"false" doc:"The object class that defines a group entry on the LDAP server, if different from 'posixGroup'. When binding VAST Cluster to AD, set this parameter to 'group' in order for authorization to work properly."`
	QueryGroupsMode            string    `json:"query_groups_mode,omitempty" yaml:"query_groups_mode,omitempty" required:"false" doc:"A mode setting for how groups are queried: Set to COMPATIBLE to look up user groups using the 'memberOf' and 'memberUid' attributes. Set to RFC2307BIS_ONLY to look up user groups using only the 'memberOf' attribute. Set to RFC2307_ONLY to look up user groups using only the 'memberUid' attribute. Set to NONE not to look up user groups other than by leading GID and primary group SID."`
	ReverseLookup              bool      `json:"reverse_lookup,omitempty" yaml:"reverse_lookup,omitempty" required:"false" doc:"Resolve LDAP netgroups into hostnames"`
	Searchbase                 string    `json:"searchbase,omitempty" yaml:"searchbase,omitempty" required:"false" doc:"The entry in the LDAP directory tree to use as a starting point for user queries."`
	SuperAdminGroups           *[]string `json:"super_admin_groups,omitempty" yaml:"super_admin_groups,omitempty" required:"false" doc:"List of groups on the LDAP provider. Members of these groups can log into VMS as cluster admin users."`
	TlsCertificate             string    `json:"tls_certificate,omitempty" yaml:"tls_certificate,omitempty" required:"false" doc:"TLS certificate to use for verifying the remote LDAP server's TLS certificate."`
	Uid                        string    `json:"uid,omitempty" yaml:"uid,omitempty" required:"false" doc:"The attribute of a user entry on the LDAP server that contains the user name, if different from 'uid' When binding VAST Cluster to AD, you may need to set this to 'sAMAccountname'."`
	UidMember                  string    `json:"uid_member,omitempty" yaml:"uid_member,omitempty" required:"false" doc:"The attribute of a group entry on the LDAP server that contains names of group members, if different from 'memberUid'. When binding VAST Cluster to AD, you may need to set this to 'memberUID'."`
	UidMemberValuePropertyName string    `json:"uid_member_value_property_name,omitempty" yaml:"uid_member_value_property_name,omitempty" required:"false" doc:"Specifies the attribute which represents the value of the LDAP group's member property."`
	UidNumber                  string    `json:"uid_number,omitempty" yaml:"uid_number,omitempty" required:"false" doc:"The attribute of a user entry on the LDAP server that contains the UID number, if different from 'uidNumber'. Often when binding VAST Cluster to Active Directory this does not need to be set."`
	Url                        string    `json:"url,omitempty" yaml:"url,omitempty" required:"false" doc:"LDAP server URI in the format SCHEME://ADDRESS. ADDRESS can be either a DNS name or an IP address. Example: ldap://ldap.company.com"`
	Urls                       *[]string `json:"urls,omitempty" yaml:"urls,omitempty" required:"false" doc:"Comma separated list of URIs of LDAP servers in the format SCHEME://ADDRESS. The order of listing defines the priority order. The URI with highest priority that has a good health status is used."`
	UseAutoDiscovery           bool      `json:"use_auto_discovery,omitempty" yaml:"use_auto_discovery,omitempty" required:"false" doc:"When enabled, Active Directory Domain Controllers (DCs) and Active Directory domains are auto discovered. Queries extend beyond the joined domain to all domains in the forest. When disabled, queries are restricted to the joined domain and DCs must be provided in the URLs field."`
	UseLdaps                   bool      `json:"use_ldaps,omitempty" yaml:"use_ldaps,omitempty" required:"false" doc:"Use LDAPS for Auto-Discovery"`
	UseMultiForest             bool      `json:"use_multi_forest,omitempty" yaml:"use_multi_forest,omitempty" required:"false" doc:"Allow access for users from trusted domains on other forests."`
	UsePosix                   bool      `json:"use_posix,omitempty" yaml:"use_posix,omitempty" required:"false" doc:"POSIX support"`
	UseTls                     bool      `json:"use_tls,omitempty" yaml:"use_tls,omitempty" required:"false" doc:"Set to true to enable use of TLS to secure communication between VAST Cluster and the LDAP server."`
	UserLoginName              string    `json:"user_login_name,omitempty" yaml:"user_login_name,omitempty" required:"false" doc:"Specifies the attribute used to query Active Directory for the user login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	UsernamePropertyName       string    `json:"username_property_name,omitempty" yaml:"username_property_name,omitempty" required:"false" doc:"The attribute to use for querying users in VMS user-initated user queries. Default is 'name'. Sometimes set to 'cn'"`
}

// -----------------------------------------------------
// MODEL
// -----------------------------------------------------

// LdapModel represents the model data for Ldap operations
// Generated from schema: Ldap
type LdapModel struct {
	AbacReadOnlyValueName      string    `json:"abac_read_only_value_name,omitempty" yaml:"abac_read_only_value_name,omitempty" required:"false" doc:""`
	AbacReadWriteValueName     string    `json:"abac_read_write_value_name,omitempty" yaml:"abac_read_write_value_name,omitempty" required:"false" doc:""`
	ActiveDirectory            string    `json:"active_directory,omitempty" yaml:"active_directory,omitempty" required:"false" doc:""`
	ActiveDirectoryId          int64     `json:"active_directory_id,omitempty" yaml:"active_directory_id,omitempty" required:"false" doc:""`
	AdvancedFilter             string    `json:"advanced_filter,omitempty" yaml:"advanced_filter,omitempty" required:"false" doc:"Manual filters for the BaseDN. This is useful when accounts are distributed across OUs and the baseDN needs to be wide to include all accounts, while there are also accounts that you would like to exclude from user queries."`
	Binddn                     string    `json:"binddn,omitempty" yaml:"binddn,omitempty" required:"false" doc:"Distinguished name of LDAP superuser"`
	Bindpw                     string    `json:"bindpw,omitempty" yaml:"bindpw,omitempty" required:"false" doc:"Password for the LDAP superuser"`
	DomainName                 string    `json:"domain_name,omitempty" yaml:"domain_name,omitempty" required:"false" doc:"FQDN of the domain."`
	DomainsWithPosixAttributes *[]string `json:"domains_with_posix_attributes,omitempty" yaml:"domains_with_posix_attributes,omitempty" required:"false" doc:"Allows to enumerate specific domains for POSIX attributes in case posix_attributes_source is set to SPECIFIC_DOMAINS."`
	GidNumber                  string    `json:"gid_number,omitempty" yaml:"gid_number,omitempty" required:"false" doc:""`
	GroupLoginName             string    `json:"group_login_name,omitempty" yaml:"group_login_name,omitempty" required:"false" doc:"The attribute used to query Active Directory for the group login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	GroupSearchbase            string    `json:"group_searchbase,omitempty" yaml:"group_searchbase,omitempty" required:"false" doc:"Base DN for group queries within the joined domain only. When auto discovery is enabled, group queries outside the joined domain use auto-discovered Base DNs."`
	Guid                       string    `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	Id                         int64     `json:"id,omitempty" yaml:"id,omitempty" required:"false" doc:""`
	IsVmsAuthProvider          bool      `json:"is_vms_auth_provider,omitempty" yaml:"is_vms_auth_provider,omitempty" required:"false" doc:"Enables use of the LDAP for VMS authentication. Two LDAP configurations per cluster can be used for VMS authentication: one with Active Directory and one without."`
	MailPropertyName           string    `json:"mail_property_name,omitempty" yaml:"mail_property_name,omitempty" required:"false" doc:"The attribute to use for the user's email address."`
	MatchUser                  string    `json:"match_user,omitempty" yaml:"match_user,omitempty" required:"false" doc:""`
	Method                     string    `json:"method,omitempty" yaml:"method,omitempty" required:"false" doc:"Bind Authentication Method"`
	MonitorAction              string    `json:"monitor_action,omitempty" yaml:"monitor_action,omitempty" required:"false" doc:"The type of periodic health check that VAST Cluster performs for the LDAP provider. PING (default, less overhead and impact on the provider) = pings the provider. BIND = binds to the provider."`
	Name                       string    `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:""`
	Port                       int64     `json:"port,omitempty" yaml:"port,omitempty" required:"false" doc:"LDAP server port. 389 (LDAP) 636 (LDAPS)"`
	PosixAccount               string    `json:"posix_account,omitempty" yaml:"posix_account,omitempty" required:"false" doc:""`
	PosixAttributesSource      string    `json:"posix_attributes_source,omitempty" yaml:"posix_attributes_source,omitempty" required:"false" doc:"Defines which domains POSIX attributes will be supported from."`
	PosixGroup                 string    `json:"posix_group,omitempty" yaml:"posix_group,omitempty" required:"false" doc:""`
	PosixPrimaryProvider       bool      `json:"posix_primary_provider,omitempty" yaml:"posix_primary_provider,omitempty" required:"false" doc:"POSIX primary provider"`
	QueryGroupsMode            string    `json:"query_groups_mode,omitempty" yaml:"query_groups_mode,omitempty" required:"false" doc:"Query group mode"`
	ReverseLookup              bool      `json:"reverse_lookup,omitempty" yaml:"reverse_lookup,omitempty" required:"false" doc:"Resolve LDAP netgroups into hostnames"`
	Searchbase                 string    `json:"searchbase,omitempty" yaml:"searchbase,omitempty" required:"false" doc:"The Base DN is the starting point the LDAP provider uses when searching for users and groups. If the Group Base DN is configured it will be used instead of the Base DN, for groups only"`
	State                      string    `json:"state,omitempty" yaml:"state,omitempty" required:"false" doc:""`
	SuperAdminGroups           *[]string `json:"super_admin_groups,omitempty" yaml:"super_admin_groups,omitempty" required:"false" doc:"List of groups on the LDAP provider. Members of these groups can log into VMS as cluster admin users."`
	TenantId                   int64     `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Tenant ID"`
	Title                      string    `json:"title,omitempty" yaml:"title,omitempty" required:"false" doc:""`
	TlsCertificate             string    `json:"tls_certificate,omitempty" yaml:"tls_certificate,omitempty" required:"false" doc:""`
	Uid                        string    `json:"uid,omitempty" yaml:"uid,omitempty" required:"false" doc:""`
	UidMember                  string    `json:"uid_member,omitempty" yaml:"uid_member,omitempty" required:"false" doc:""`
	UidMemberValuePropertyName string    `json:"uid_member_value_property_name,omitempty" yaml:"uid_member_value_property_name,omitempty" required:"false" doc:"The attribute which represents the value of the LDAP group's member property."`
	UidNumber                  string    `json:"uid_number,omitempty" yaml:"uid_number,omitempty" required:"false" doc:""`
	Url                        string    `json:"url,omitempty" yaml:"url,omitempty" required:"false" doc:"Comma-separated list of URIs of LDAP servers (Domain Controllers (DCs) in Active Directory), in priority order. The URI with highest priority that has a good health status is used. Specify each URI in the format SCHEME://ADDRESS. ADDRESS can be either a DNS name or an IP address. e.g. ldap://ldap.company.com, ldaps://ldaps.company.com, ldap://192.0.2.2"`
	Urls                       *[]string `json:"urls,omitempty" yaml:"urls,omitempty" required:"false" doc:"Comma-separated list of URIs of LDAP servers (Domain Controllers (DCs) in Active Directory), in priority order. The URI with highest priority that has a good health status is used. Specify each URI in the format SCHEME://ADDRESS. ADDRESS can be either a DNS name or an IP address. e.g. ldap://ldap.company.com, ldaps://ldaps.company.com, ldap://192.0.2.2"`
	UseAutoDiscovery           bool      `json:"use_auto_discovery,omitempty" yaml:"use_auto_discovery,omitempty" required:"false" doc:"When enabled, Active Directory Domain Controllers (DCs) and Active Directory domains are auto discovered. Queries extend beyond the joined domain to all domains in the forest. When disabled, queries are restricted to the joined domain and DCs must be provided in the URLs field."`
	UseLdaps                   bool      `json:"use_ldaps,omitempty" yaml:"use_ldaps,omitempty" required:"false" doc:"Use LDAPS for auto-Discovery. To activate, set use-auto-discovery to true also."`
	UseMultiForest             bool      `json:"use_multi_forest,omitempty" yaml:"use_multi_forest,omitempty" required:"false" doc:"Allow access for users from trusted domains on other forests."`
	UsePosix                   bool      `json:"use_posix,omitempty" yaml:"use_posix,omitempty" required:"false" doc:"POSIX support"`
	UseTls                     bool      `json:"use_tls,omitempty" yaml:"use_tls,omitempty" required:"false" doc:"configure LDAP with TLS"`
	UserLoginName              string    `json:"user_login_name,omitempty" yaml:"user_login_name,omitempty" required:"false" doc:"The attribute used to query Active Directory for the user login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	UsernamePropertyName       string    `json:"username_property_name,omitempty" yaml:"username_property_name,omitempty" required:"false" doc:"Username property name"`
}

// -----------------------------------------------------
// RESOURCE METHODS
// -----------------------------------------------------

// Ldap represents a typed resource for ldap operations
type Ldap struct {
	Untyped *vast_client.VMSRest
}

// Get retrieves a single ldap with typed request/response
func (r *Ldap) Get(req *LdapSearchParams) (*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.Get(params)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// GetWithContext retrieves a single ldap with typed request/response using provided context
func (r *Ldap) GetWithContext(ctx context.Context, req *LdapSearchParams) (*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// GetById retrieves a single ldap by ID
func (r *Ldap) GetById(id any) (*LdapModel, error) {
	record, err := r.Untyped.Ldaps.GetById(id)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// GetByIdWithContext retrieves a single ldap by ID using provided context
func (r *Ldap) GetByIdWithContext(ctx context.Context, id any) (*LdapModel, error) {
	record, err := r.Untyped.Ldaps.GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// List retrieves multiple ldaps with typed request/response
func (r *Ldap) List(req *LdapSearchParams) ([]*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.Ldaps.List(params)
	if err != nil {
		return nil, err
	}

	var response []*LdapModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// ListWithContext retrieves multiple ldaps with typed request/response using provided context
func (r *Ldap) ListWithContext(ctx context.Context, req *LdapSearchParams) ([]*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.Ldaps.ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*LdapModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Create creates a new ldap with typed request/response
func (r *Ldap) Create(req *LdapRequestBody) (*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.Create(params)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// CreateWithContext creates a new ldap with typed request/response using provided context
func (r *Ldap) CreateWithContext(ctx context.Context, req *LdapRequestBody) (*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Update updates an existing ldap with typed request/response
func (r *Ldap) Update(id any, req *LdapRequestBody) (*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.Update(id, params)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// UpdateWithContext updates an existing ldap with typed request/response using provided context
func (r *Ldap) UpdateWithContext(ctx context.Context, id any, req *LdapRequestBody) (*LdapModel, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.UpdateWithContext(ctx, id, params)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Delete deletes a ldap with search parameters
func (r *Ldap) Delete(req *LdapSearchParams) error {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.Ldaps.Delete(params, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteWithContext deletes a ldap with search parameters using provided context
func (r *Ldap) DeleteWithContext(ctx context.Context, req *LdapSearchParams) error {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.Ldaps.DeleteWithContext(ctx, params, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a ldap by ID
func (r *Ldap) DeleteById(id any) error {
	_, err := r.Untyped.Ldaps.DeleteById(id, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteByIdWithContext deletes a ldap by ID using provided context
func (r *Ldap) DeleteByIdWithContext(ctx context.Context, id any) error {
	_, err := r.Untyped.Ldaps.DeleteByIdWithContext(ctx, id, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// Ensure ensures a ldap exists with typed response
func (r *Ldap) Ensure(searchParams *LdapSearchParams, body *LdapRequestBody) (*LdapModel, error) {
	searchParamsConverted, err := vast_client.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := vast_client.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.Ensure(searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// EnsureWithContext ensures a ldap exists with typed response using provided context
func (r *Ldap) EnsureWithContext(ctx context.Context, searchParams *LdapSearchParams, body *LdapRequestBody) (*LdapModel, error) {
	searchParamsConverted, err := vast_client.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := vast_client.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// EnsureByName ensures a ldap exists by name with typed response
func (r *Ldap) EnsureByName(name string, body *LdapRequestBody) (*LdapModel, error) {
	bodyConverted, err := vast_client.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.EnsureByName(name, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// EnsureByNameWithContext ensures a ldap exists by name with typed response using provided context
func (r *Ldap) EnsureByNameWithContext(ctx context.Context, name string, body *LdapRequestBody) (*LdapModel, error) {
	bodyConverted, err := vast_client.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.Ldaps.EnsureByNameWithContext(ctx, name, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response LdapModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a ldap exists
func (r *Ldap) Exists(req *LdapSearchParams) (bool, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.Ldaps.Exists(params)
}

// ExistsWithContext checks if a ldap exists using provided context
func (r *Ldap) ExistsWithContext(ctx context.Context, req *LdapSearchParams) (bool, error) {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.Ldaps.ExistsWithContext(ctx, params)
}

// MustExists checks if a ldap exists and panics if not
func (r *Ldap) MustExists(req *LdapSearchParams) bool {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.Ldaps.MustExists(params)
}

// MustExistsWithContext checks if a ldap exists and panics if not using provided context
func (r *Ldap) MustExistsWithContext(ctx context.Context, req *LdapSearchParams) bool {
	params, err := vast_client.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.Ldaps.MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// RENDERABLE INTERFACE METHODS
// -----------------------------------------------------

// PrettyTable returns a formatted table representation of the LdapModel
func (m *LdapModel) PrettyTable() string {
	return m.toRecord().PrettyTable()
}

// PrettyJson returns a JSON representation of the LdapModel
func (m *LdapModel) PrettyJson(indent ...string) string {
	return m.toRecord().PrettyJson(indent...)
}

// toRecord converts the LdapModel to a Record (map[string]any) with @resourceType
func (m *LdapModel) toRecord() vast_client.Record {
	// Convert struct to map using JSON marshaling
	jsonBytes, err := json.Marshal(m)
	if err != nil {
		return vast_client.Record{"error": fmt.Sprintf("failed to marshal struct: %v", err)}
	}

	var record vast_client.Record
	if err := json.Unmarshal(jsonBytes, &record); err != nil {
		return vast_client.Record{"error": fmt.Sprintf("failed to unmarshal to record: %v", err)}
	}

	// Add resource type using reflection
	record["@resourceType"] = reflect.TypeOf(*m).Name()

	return record
}
