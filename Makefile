# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOGET=$(GOCMD) get
GOMOD=$(GOCMD) mod
GOLINT=golangci-lint
MKDOCS ?= mkdocs
ADDR ?= localhost:8000

# Binary names
BINARY_NAME=go-vast-client
BINARY_UNIX=$(BINARY_NAME)_unix

# Build info
VERSION ?= $(shell git describe --tags --always --dirty)
BUILD_TIME=$(shell date -u '+%Y-%m-%d_%H:%M:%S')
COMMIT=$(shell git rev-parse --short HEAD)

# Directories
EXAMPLES_DIR=examples
COVERAGE_DIR=coverage

.PHONY: all build build-examples test clean deps lint fmt vet coverage help autogen generate-typed generate-untyped verify-autogen

all: clean deps fmt lint test build ## Run all main targets

help: ## Display this help screen
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

# Development
deps: ## Download and install dependencies
	$(GOMOD) download
	$(GOMOD) tidy
	$(GOMOD) verify

fmt: ## Format Go code
	$(GOCMD) fmt ./...

vet: ## Run go vet
	$(GOCMD) vet ./...

lint: ## Run golangci-lint
	$(GOLINT) run

# Testing
test: ## Run tests
	$(GOTEST) -v -race ./...

test-short: ## Run tests with short flag
	$(GOTEST) -v -short ./...

test-coverage: ## Run tests with coverage
	@mkdir -p $(COVERAGE_DIR)
	$(GOTEST) -v -race -coverprofile=$(COVERAGE_DIR)/coverage.out ./...
	$(GOCMD) tool cover -html=$(COVERAGE_DIR)/coverage.out -o $(COVERAGE_DIR)/coverage.html

coverage-report: test-coverage ## Generate and open coverage report
	$(GOCMD) tool cover -func=$(COVERAGE_DIR)/coverage.out
	@echo "Coverage report generated: $(COVERAGE_DIR)/coverage.html"

# Building
build: ## Build the library (test build)
	$(GOBUILD) -v ./...

# Cleaning
clean: ## Clean build artifacts
	$(GOCLEAN)
	rm -rf $(COVERAGE_DIR)
	rm -rf $(EXAMPLES_DIR)/bin

# CI/CD helpers
ci-deps: ## Install CI dependencies
	$(GOCMD) install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

ci-test: ## Run CI tests
	$(GOTEST) -v -race -coverprofile=coverage.out ./...

# Security
security: ## Run security checks
	$(GOCMD) install golang.org/x/vuln/cmd/govulncheck@latest
	govulncheck ./...

# Documentation
docs: ## Generate documentation
	$(GOCMD) doc -all

# Git helpers
tag: ## Create a new git tag (usage: make tag VERSION=v1.0.0)
	@if [ -z "$(VERSION)" ]; then echo "VERSION is required. Usage: make tag VERSION=v1.0.0"; exit 1; fi
	git tag -a $(VERSION) -m "Release $(VERSION)"
	git push origin $(VERSION)

# Check if required tools are installed
check-tools: ## Check if required tools are installed
	@command -v golangci-lint >/dev/null 2>&1 || { echo >&2 "golangci-lint is required but not installed. Run: make ci-deps"; exit 1; }
	@command -v go >/dev/null 2>&1 || { echo >&2 "Go is required but not installed."; exit 1; }

docs-build:
	$(MKDOCS) build --clean --strict

docs-serve:
	$(MKDOCS) serve --dev-addr $(ADDR)

docs-deploy:
	$(MKDOCS) gh-deploy --force

# Code generation
MAKEFILE_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

autogen: ## Generate all typed and untyped resources
	@echo "========================================="
	@echo "Starting code generation..."
	@echo "========================================="
	@$(MAKE) generate-typed
	@echo ""
	@$(MAKE) generate-untyped
	@echo ""
	@echo "========================================="
	@echo "All code generation completed!"
	@echo "========================================="

generate-typed: ## Generate all typed resources from apityped markers
	@echo "Generating typed resources..."
	cd $(MAKEFILE_DIR)codegen && go build -tags tools -o bin/generate-typed-resources ./cmd/generate-typed-resources
	cd $(MAKEFILE_DIR)codegen && ./bin/generate-typed-resources
	@echo "Typed resources generated successfully!"

generate-untyped: ## Generate extra methods for untyped resources from apiuntyped markers
	@echo "Generating untyped extra methods..."
	cd $(MAKEFILE_DIR)codegen && go build -tags tools -o bin/generate-untyped-resources ./cmd/generate-untyped-resources
	cd $(MAKEFILE_DIR)codegen && ./bin/generate-untyped-resources
	@echo "Untyped extra methods generated successfully!"

verify-autogen: ## Verify autogenerated typed resources for common issues
	@$(MAKEFILE_DIR)codegen/misc/verify_autogen.sh $(MAKEFILE_DIR)resources/typed

# OpenAPI conversion targets

ifeq (gen-openapi-tar, $(firstword $(MAKECMDGOALS)))
  runargs := $(wordlist 2, $(words $(MAKECMDGOALS)), $(MAKECMDGOALS))
  $(foreach arg,$(runargs),$(eval $(arg):;@true))
endif

ifeq (validate-api, $(firstword $(MAKECMDGOALS)))
  runargs := $(wordlist 2, $(words $(MAKECMDGOALS)), $(MAKECMDGOALS))
  $(foreach arg,$(runargs),$(eval $(arg):;@true))
endif

# Enhanced OpenAPI conversion with validation and auto-fixes
#
#   This target uses the enhanced Python converter that:
#     - Validates Swagger schemas and identifies common issues
#     - Automatically fixes known problems (null properties, missing types)  
#     - Provides detailed debugging information
#     - Converts to OpenAPI v3 using the Go converter
#     - Creates final outputs: api.json and api.tar.gz
#
#   Usage:
#     make gen-openapi-tar <path> [options]
#
#   Arguments:
#     <path> - Required. Path to the Swagger/OpenAPI YAML file.
#
#   Options:
#     --debug        - Enable detailed debugging output
#     --no-auto-fix  - Disable automatic fixes (validation only)
#     --output-dir   - Custom output directory for intermediate files
#
#   Examples:
#     make gen-openapi-tar ./specs/swagger.yaml
#     make gen-openapi-tar /tmp/vast-openapi.yaml --debug
#     make gen-openapi-tar ./specs/swagger.yaml --no-auto-fix
gen-openapi-tar: ## Convert Swagger/OpenAPI YAML to tarball with validation & auto-fixes
	@set -e; \
	args="$(runargs)"; \
	if [ -z "$$args" ]; then \
		echo "‚ùå Usage: make gen-openapi-tar <path> [options]"; \
		echo "   Example: make gen-openapi-tar /path/to/swagger.yaml --debug"; \
		echo "   Options: --debug --no-auto-fix --output-dir /custom/dir"; \
		exit 1; \
	fi; \
	echo "üöÄ Running enhanced OpenAPI conversion with validation and auto-fixes..."; \
	python3 $(CURDIR)/codegen/misc/convert_swagger.py $$args --dest-dir $(CURDIR); \
	echo "‚úÖ Enhanced conversion completed!"

# Validate Swagger/OpenAPI schema
#
# Usage: make validate-api <path> [options]
#
# Arguments:
#   <path>         - Path to Swagger/OpenAPI YAML or JSON file
#
# Options:
#   --debug        - Enable detailed debugging output
#   --json-output  - Export JSON report to specified file
#
# Examples:
#   make validate-api ./specs/swagger.yaml
#   make validate-api /tmp/api.yaml --debug
#   make validate-api ./api.yaml --json-output report.json
validate-api: ## Validate Swagger/OpenAPI schema with detailed diagnostics
	@set -e; \
	args="$(runargs)"; \
	if [ -z "$$args" ]; then \
		echo "‚ùå Usage: make validate-api <path> [options]"; \
		echo "   Example: make validate-api /path/to/swagger.yaml --debug"; \
		echo "   Options: --debug --json-output <file>"; \
		exit 1; \
	fi; \
	echo "üîç Running Swagger/OpenAPI schema validation..."; \
	python3 $(CURDIR)/codegen/misc/validate_swagger.py $$args; \
	echo "‚úÖ Validation completed!"
