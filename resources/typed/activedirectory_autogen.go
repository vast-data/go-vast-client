// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|UPDATE|DELETE

package typed

import (
	"context"
	"net/http"

	"github.com/vast-data/go-vast-client/core"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// ActiveDirectory represents a typed resource for activedirectory operations
type ActiveDirectory struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// ActiveDirectorySearchParams represents the search parameters for ActiveDirectory operations
type ActiveDirectorySearchParams struct {
	Guid     string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:"GUID"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:""`
	TenantId int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:""`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &ActiveDirectorySearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// ActiveDirectoryRequestBody represents the request body for ActiveDirectory operations
type ActiveDirectoryRequestBody struct {
	AbacReadOnlyValueName       string    `json:"abac_read_only_value_name,omitempty" yaml:"abac_read_only_value_name,omitempty" required:"false" doc:"The attribute to use when querying a provider for a read only attribute access check."`
	AbacReadWriteValueName      string    `json:"abac_read_write_value_name,omitempty" yaml:"abac_read_write_value_name,omitempty" required:"false" doc:"The attribute to use when querying a provider for a read-write attribute access check."`
	Binddn                      string    `json:"binddn,omitempty" yaml:"binddn,omitempty" required:"false" doc:"The bind DN for authenticating to the LDAP domain. You can specify any user account that has read access to the domain."`
	Bindpw                      string    `json:"bindpw,omitempty" yaml:"bindpw,omitempty" required:"false" doc:"The password used with the Bind DN to authenticate to the LDAP server."`
	DomainName                  string    `json:"domain_name,omitempty" yaml:"domain_name,omitempty" required:"false" doc:"The fully qualified domain name (FQDN) of the Active Directory. This parameter is required unless ldap_id is provided."`
	DomainsWithPosixAttributes  *[]string `json:"domains_with_posix_attributes,omitempty" yaml:"domains_with_posix_attributes,omitempty" required:"false" doc:"Allows to enumerate specific domains for POSIX attributes in case posix_attributes_source is set to SPECIFIC_DOMAINS."`
	GidNumber                   string    `json:"gid_number,omitempty" yaml:"gid_number,omitempty" required:"false" doc:"Override 'gidNumber' as the attribute of a group entry that contains the group's GID number. When binding VAST Cluster to AD, you may need to set this to 'gidnumber' (case sensitive)."`
	GroupLoginName              string    `json:"group_login_name,omitempty" yaml:"group_login_name,omitempty" required:"false" doc:"The attribute used to query Active Directory for the group login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	GroupSearchbase             string    `json:"group_searchbase,omitempty" yaml:"group_searchbase,omitempty" required:"false" doc:"Base DN for group queries within the joined domain only. When auto discovery is enabled, group queries outside the joined domain use auto-discovered Base DNs."`
	IsVmsAuthProvider           bool      `json:"is_vms_auth_provider,omitempty" yaml:"is_vms_auth_provider,omitempty" required:"false" doc:"Enables use of the LDAP for VMS authentication. Two LDAP configurations per cluster can be used for VMS authentication: one with Active Directory and one without."`
	LdapId                      string    `json:"ldap_id,omitempty" yaml:"ldap_id,omitempty" required:"false" doc:"ID of the LDAP configuration for binding to the LDAP domain of the Active Directory server. This parameter is required unless domain_name is provided."`
	MaPwdChangeFrequency        string    `json:"ma_pwd_change_frequency,omitempty" yaml:"ma_pwd_change_frequency,omitempty" required:"false" doc:"Machine Account password change frequency."`
	MaPwdUpdateTime             string    `json:"ma_pwd_update_time,omitempty" yaml:"ma_pwd_update_time,omitempty" required:"false" doc:"Machine Account password update time."`
	MachineAccountName          string    `json:"machine_account_name,omitempty" yaml:"machine_account_name,omitempty" required:"false" doc:"The name for the machine object representing the VAST Cluster to be created within the OU."`
	MailPropertyName            string    `json:"mail_property_name,omitempty" yaml:"mail_property_name,omitempty" required:"false" doc:""`
	MatchUser                   string    `json:"match_user,omitempty" yaml:"match_user,omitempty" required:"false" doc:"The attribute to use when querying a provider for a user that matches a user that was already retrieved from another provider. A user entry that contains a matching value in this attribute will be considered the same user as the user previously retrieved."`
	Method                      string    `json:"method,omitempty" yaml:"method,omitempty" required:"false" doc:"The authentication method configured on the LDAP server for authenticating clients."`
	MonitorAction               string    `json:"monitor_action,omitempty" yaml:"monitor_action,omitempty" required:"false" doc:"The type of periodic health check that VAST Cluster performs for the Active Directory provider. PING (default, less overhead and impact on the provider) = pings the provider. BIND = binds to the provider."`
	NtlmEnabled                 bool      `json:"ntlm_enabled,omitempty" yaml:"ntlm_enabled,omitempty" required:"false" doc:"Manages support of NTLM authentication method for SMB protocol."`
	OrganizationalUnit          string    `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" required:"false" doc:"A non default organizational unit (OU) in the Active Directory domain in which to create the machine object. If left empty, the machine object will be created in the default Computers OU."`
	Port                        int64     `json:"port,omitempty" yaml:"port,omitempty" required:"false" doc:"The port of the remote LDAP server. Typical values: 389, 636."`
	PosixAccount                string    `json:"posix_account,omitempty" yaml:"posix_account,omitempty" required:"false" doc:"Override 'posixAccount'as the object class that defines a user entry on the LDAP server. When binding VAST Cluster to AD, set this parameter to 'user' in order for authorization to work properly."`
	PosixAttributesSource       string    `json:"posix_attributes_source,omitempty" yaml:"posix_attributes_source,omitempty" required:"false" doc:"Defines which domains POSIX attributes will be supported from."`
	PosixGroup                  string    `json:"posix_group,omitempty" yaml:"posix_group,omitempty" required:"false" doc:"Override 'posixGroup' as the object class that defines a group entry on the LDAP server. When binding VAST Cluster to AD, set this parameter to 'group' in order for authorization to work properly."`
	PreferredDcList             *[]string `json:"preferred_dc_list,omitempty" yaml:"preferred_dc_list,omitempty" required:"false" doc:"Specify multiple DCs using 'urls' parameter in LDAP configuration."`
	QueryGroupsMode             string    `json:"query_groups_mode,omitempty" yaml:"query_groups_mode,omitempty" required:"false" doc:"A mode setting for how groups are queried: Set to COMPATIBLE to look up user groups using the 'memberOf' and 'memberUid' attributes. Set to RFC2307BIS_ONLY to look up user groups using only the 'memberOf' attribute. Set to RFC2307_ONLY to look up user groups using only the 'memberUid' attribute. Set to NONE not to look up user groups other than by leading GID and primary group SID."`
	QueryPosixAttributesFromGc  bool      `json:"query_posix_attributes_from_gc,omitempty" yaml:"query_posix_attributes_from_gc,omitempty" required:"false" doc:"When set to True - users/groups from non-joined domain POSIX attributes are supported, when set to False - Posix attributes of users/groups from non-joined domain are not supported. As a condition Global catalog needs to be configured to support Posix attributes. (deprecated since 4.6)"`
	ReverseLookup               bool      `json:"reverse_lookup,omitempty" yaml:"reverse_lookup,omitempty" required:"false" doc:"resolve netgroups into hostnames"`
	ScheduledMaPwdChangeEnabled bool      `json:"scheduled_ma_pwd_change_enabled,omitempty" yaml:"scheduled_ma_pwd_change_enabled,omitempty" required:"false" doc:"Enables scheduled Machine Account password change."`
	Searchbase                  string    `json:"searchbase,omitempty" yaml:"searchbase,omitempty" required:"false" doc:"The entry in the LDAP directory tree to use as a starting point for user queries."`
	SmbAllowed                  bool      `json:"smb_allowed,omitempty" yaml:"smb_allowed,omitempty" required:"false" doc:"Indicates if the Active Directory configuration is allowed to serve as a provider for SMB attributes."`
	SuperAdminGroups            *[]string `json:"super_admin_groups,omitempty" yaml:"super_admin_groups,omitempty" required:"false" doc:"List of groups on the Active Directory provider. Members of these groups can log into VMS as cluster admin users."`
	TlsCertificate              string    `json:"tls_certificate,omitempty" yaml:"tls_certificate,omitempty" required:"false" doc:"TLS certificate to use for verifying the remote LDAP server's TLS certificate."`
	Uid                         string    `json:"uid,omitempty" yaml:"uid,omitempty" required:"false" doc:"Override 'uid' as the attribute of a user entry on the LDAP server that contains the user name. When binding VAST Cluster to AD, you may need to set this to 'sAMAccountname'."`
	UidMember                   string    `json:"uid_member,omitempty" yaml:"uid_member,omitempty" required:"false" doc:"Override 'memberUid' as the attribute of a group entry on the LDAP server that contains names of group members. When binding VAST Cluster to AD, you may need to set this to 'memberUID'"`
	UidMemberValuePropertyName  string    `json:"uid_member_value_property_name,omitempty" yaml:"uid_member_value_property_name,omitempty" required:"false" doc:""`
	UidNumber                   string    `json:"uid_number,omitempty" yaml:"uid_number,omitempty" required:"false" doc:"Override 'uidNumber' as the attribute of a user entry on the LDAP server that contains the UID number. Often when binding VAST Cluster to Active Directory this does not need to be set."`
	Url                         string    `json:"url,omitempty" yaml:"url,omitempty" required:"false" doc:"LDAP server URI in the format <scheme>://<address>. <address> can be either a DNS name or an IP address. Example: ldap://ldap.company.com"`
	Urls                        *[]string `json:"urls,omitempty" yaml:"urls,omitempty" required:"false" doc:"Comma separated list of URIs of LDAP servers in the format <scheme>://<address>. The order of listing defines the priority order. The URI with highest priority that has a good health status is used."`
	UseAutoDiscovery            bool      `json:"use_auto_discovery,omitempty" yaml:"use_auto_discovery,omitempty" required:"false" doc:"When enabled, Active Directory Domain Controllers (DCs) and Active Directory domains are auto discovered. Queries extend beyond the joined domain to all domains in the forest. When disabled, queries are restricted to the joined domain and DCs must be provided in the URLs field."`
	UseLdaps                    bool      `json:"use_ldaps,omitempty" yaml:"use_ldaps,omitempty" required:"false" doc:"Use LDAPS for Auto-Discovery"`
	UseMultiForest              bool      `json:"use_multi_forest,omitempty" yaml:"use_multi_forest,omitempty" required:"false" doc:"Allow access for users from trusted domains on other forests."`
	UsePosix                    bool      `json:"use_posix,omitempty" yaml:"use_posix,omitempty" required:"false" doc:"POSIX support"`
	UseTls                      bool      `json:"use_tls,omitempty" yaml:"use_tls,omitempty" required:"false" doc:"Set to true to enable use of TLS to secure communication between VAST Cluster and the LDAP server."`
	UserLoginName               string    `json:"user_login_name,omitempty" yaml:"user_login_name,omitempty" required:"false" doc:"The attribute used to query Active Directory for the user login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	UsernamePropertyName        string    `json:"username_property_name,omitempty" yaml:"username_property_name,omitempty" required:"false" doc:"The attribute to use for querying users in VMS user-initated user queries. Default is 'name'. Sometimes set to 'cn'"`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// ActiveDirectoryDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/ActiveDirectory
type ActiveDirectoryDetailsModel = Component_ActiveDirectory

// ActiveDirectoryUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/ActiveDirectory
type ActiveDirectoryUpsertModel = Component_ActiveDirectory

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple activedirectorys with typed request/response
// summary: List Active Directory Configurations
func (r *ActiveDirectory) List(req *ActiveDirectorySearchParams) ([]*ActiveDirectoryDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple activedirectorys with typed request/response using provided context
// summary: List Active Directory Configurations
func (r *ActiveDirectory) ListWithContext(ctx context.Context, req *ActiveDirectorySearchParams) ([]*ActiveDirectoryDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*ActiveDirectoryDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single activedirectory with typed request/response
// summary: List Active Directory Configurations
func (r *ActiveDirectory) Get(req *ActiveDirectorySearchParams) (*ActiveDirectoryDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single activedirectory with typed request/response using provided context
// summary: List Active Directory Configurations
func (r *ActiveDirectory) GetWithContext(ctx context.Context, req *ActiveDirectorySearchParams) (*ActiveDirectoryDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ActiveDirectoryDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single activedirectory by ID
// summary: Return Active Directory Configuration Details
func (r *ActiveDirectory) GetById(id any) (*ActiveDirectoryDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single activedirectory by ID using provided context
// summary: Return Active Directory Configuration Details
func (r *ActiveDirectory) GetByIdWithContext(ctx context.Context, id any) (*ActiveDirectoryDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response ActiveDirectoryDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new activedirectory with typed request/response
// summary: Create Active Directory Configuration
func (r *ActiveDirectory) Create(req *ActiveDirectoryRequestBody) (*ActiveDirectoryUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new activedirectory with typed request/response using provided context
// summary: Create Active Directory Configuration
func (r *ActiveDirectory) CreateWithContext(ctx context.Context, req *ActiveDirectoryRequestBody) (*ActiveDirectoryUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ActiveDirectoryUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// UPDATE
// -----------------------------------------------------

// Update updates an existing activedirectory with typed request/response
func (r *ActiveDirectory) Update(id any, req *ActiveDirectoryRequestBody) (*ActiveDirectoryUpsertModel, error) {
	return r.UpdateWithContext(r.Untyped.GetCtx(), id, req)
}

// UpdateWithContext updates an existing activedirectory with typed request/response using provided context
func (r *ActiveDirectory) UpdateWithContext(ctx context.Context, id any, req *ActiveDirectoryRequestBody) (*ActiveDirectoryUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].UpdateWithContext(ctx, id, params)
	if err != nil {
		return nil, err
	}

	var response ActiveDirectoryUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a activedirectory with search parameters
//
// Parameters:
//   - skipLdap: Set to true to avoid removing the LDAP server configuration that is attached to the Active Directory configuration.
func (r *ActiveDirectory) Delete(req *ActiveDirectorySearchParams, skipLdap bool) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req, skipLdap)
}

// DeleteWithContext deletes a activedirectory with search parameters using provided context
//
// Parameters:
//   - skipLdap: Set to true to avoid removing the LDAP server configuration that is attached to the Active Directory configuration.
func (r *ActiveDirectory) DeleteWithContext(ctx context.Context, req *ActiveDirectorySearchParams, skipLdap bool) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}

	// Build DELETE query params
	var deleteQueryParams core.Params
	// Build DELETE body params
	deleteBody := core.Params{"skip_ldap": skipLdap}
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, deleteQueryParams, deleteBody)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a activedirectory by ID
// summary: Delete Active Directory configuration
//
// Parameters:
//   - id: Active Directory ID
//   - skipLdap: Set to true to avoid removing the LDAP server configuration that is attached to the Active Directory configuration.
func (r *ActiveDirectory) DeleteById(id any, skipLdap bool) error {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id, skipLdap)
}

// DeleteByIdWithContext deletes a activedirectory by ID using provided context
// summary: Delete Active Directory configuration
//
// Parameters:
//   - id: Active Directory ID
//   - skipLdap: Set to true to avoid removing the LDAP server configuration that is attached to the Active Directory configuration.
func (r *ActiveDirectory) DeleteByIdWithContext(ctx context.Context, id any, skipLdap bool) error {

	// Build DELETE query params
	var deleteQueryParams core.Params
	// Build DELETE body params
	deleteBody := core.Params{"skip_ldap": skipLdap}
	_, err := r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteByIdWithContext(ctx, id, deleteQueryParams, deleteBody)
	if err != nil {
		return err
	}
	return nil
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a activedirectory exists with typed response
func (r *ActiveDirectory) Ensure(searchParams *ActiveDirectorySearchParams, body *ActiveDirectoryRequestBody) (*ActiveDirectoryUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a activedirectory exists with typed response using provided context
func (r *ActiveDirectory) EnsureWithContext(ctx context.Context, searchParams *ActiveDirectorySearchParams, body *ActiveDirectoryRequestBody) (*ActiveDirectoryUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response ActiveDirectoryUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a activedirectory exists
func (r *ActiveDirectory) Exists(req *ActiveDirectorySearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a activedirectory exists using provided context
func (r *ActiveDirectory) ExistsWithContext(ctx context.Context, req *ActiveDirectorySearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a activedirectory exists and panics if not
func (r *ActiveDirectory) MustExists(req *ActiveDirectorySearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a activedirectory exists and panics if not using provided context
func (r *ActiveDirectory) MustExistsWithContext(ctx context.Context, req *ActiveDirectorySearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// ActiveDirectoryIsOperationHealthy_POST_Body represents the request body for ActiveDirectoryIsOperationHealthy
type ActiveDirectoryIsOperationHealthy_POST_Body struct {
	AdminPasswd   string `json:"admin_passwd,omitempty" yaml:"admin_passwd,omitempty" required:"false" doc:"The password for the specified Active Directory admin user."`
	AdminUsername string `json:"admin_username,omitempty" yaml:"admin_username,omitempty" required:"false" doc:"An Active Directory admin user with permission to join the Active Directory server."`
	Enabled       bool   `json:"enabled,omitempty" yaml:"enabled,omitempty" required:"false" doc:"Set to true to join Active Directory. Set to false to leave Active Directory."`
	NtlmEnabled   bool   `json:"ntlm_enabled,omitempty" yaml:"ntlm_enabled,omitempty" required:"false" doc:"Manages support of NTLM authentication method for SMB protocol."`
	SmbAllowed    bool   `json:"smb_allowed,omitempty" yaml:"smb_allowed,omitempty" required:"false" doc:"Indicates if the Active Directory configuration is allowed to serve as a provider for SMB attributes."`
}

// ActiveDirectoryIsOperationHealthy_POST_Model represents the response model for ActiveDirectoryIsOperationHealthy
type ActiveDirectoryIsOperationHealthy_POST_Model struct {
	Warnings *[]string `json:"warnings,omitempty" yaml:"warnings,omitempty" required:"true" doc:""`
}

// ActiveDirectoryIsOperationHealthyWithContext_POST
// method: POST
// url: /activedirectory/{id}/is_operation_healthy/
// summary: Check whether an operation may be successfully performed
func (r *ActiveDirectory) ActiveDirectoryIsOperationHealthyWithContext_POST(ctx context.Context, id any, body *ActiveDirectoryIsOperationHealthy_POST_Body) (*ActiveDirectoryIsOperationHealthy_POST_Model, error) {
	resourcePath := core.BuildResourcePathWithID("activedirectory", id, "is_operation_healthy")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ActiveDirectoryIsOperationHealthy_POST_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ActiveDirectoryIsOperationHealthy_POST
// method: POST
// url: /activedirectory/{id}/is_operation_healthy/
// summary: Check whether an operation may be successfully performed
func (r *ActiveDirectory) ActiveDirectoryIsOperationHealthy_POST(id any, body *ActiveDirectoryIsOperationHealthy_POST_Body) (*ActiveDirectoryIsOperationHealthy_POST_Model, error) {
	return r.ActiveDirectoryIsOperationHealthyWithContext_POST(r.Untyped.GetCtx(), id, body)
}

// ActiveDirectoryRefreshWithContext_PATCH
// method: PATCH
// url: /activedirectory/{id}/refresh/
// summary: Refresh AD
func (r *ActiveDirectory) ActiveDirectoryRefreshWithContext_PATCH(ctx context.Context, id any) error {
	resourcePath := core.BuildResourcePathWithID("activedirectory", id, "refresh")

	var reqParams core.Params
	var reqBody core.Params

	_, err := core.Request[core.EmptyRecord](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	return err

}

// ActiveDirectoryRefresh_PATCH
// method: PATCH
// url: /activedirectory/{id}/refresh/
// summary: Refresh AD
func (r *ActiveDirectory) ActiveDirectoryRefresh_PATCH(id any) error {
	return r.ActiveDirectoryRefreshWithContext_PATCH(r.Untyped.GetCtx(), id)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - Extra method GET /activedirectory/{id}/current_gc/ skipped: GET /activedirectory/{id}/current_gc/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /activedirectory/{id}/dcs/ skipped: GET /activedirectory/{id}/dcs/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /activedirectory/{id}/domains/ skipped: GET /activedirectory/{id}/domains/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /activedirectory/{id}/gcs/ skipped: GET /activedirectory/{id}/gcs/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method POST /activedirectory/{id}/change_machine_account_password/ skipped: POST /activedirectory/{id}/change_machine_account_password/ - No response schema defined in OpenAPI spec. Error: no valid schema found in POST response (200/201/202) for resource /activedirectory/{id}/change_machine_account_password/
