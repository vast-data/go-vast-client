// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: LIST

package typed

import (
	"context"
	"net/http"

	"github.com/vast-data/go-vast-client/core"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// Topic represents a typed resource for topic operations
type Topic struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// TopicSearchParams represents the search parameters for Topic operations
type TopicSearchParams struct {
	CountOnly    bool   `json:"count_only,omitempty" yaml:"count_only,omitempty" required:"false" doc:"Whether to only return count of objects"`
	DatabaseName string `json:"database_name,omitempty" yaml:"database_name,omitempty" required:"false" doc:"Getting list of objects by database_name"`
	Name         string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Getting list of objects by exact match"`
	TenantId     int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Filter by tenant. Specify tenant ID."`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &TopicSearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// TopicDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/TabularTopicHierarchy
type TopicDetailsModel = Component_TabularTopicHierarchy

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple topics with typed request/response
// summary: List Kafka Topics
func (r *Topic) List(req *TopicSearchParams) ([]*TopicDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple topics with typed request/response using provided context
// summary: List Kafka Topics
func (r *Topic) ListWithContext(ctx context.Context, req *TopicSearchParams) ([]*TopicDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*TopicDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single topic with typed request/response
// summary: List Kafka Topics
func (r *Topic) Get(req *TopicSearchParams) (*TopicDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single topic with typed request/response using provided context
// summary: List Kafka Topics
func (r *Topic) GetWithContext(ctx context.Context, req *TopicSearchParams) (*TopicDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response TopicDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a topic exists
func (r *Topic) Exists(req *TopicSearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a topic exists using provided context
func (r *Topic) ExistsWithContext(ctx context.Context, req *TopicSearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a topic exists and panics if not
func (r *Topic) MustExists(req *TopicSearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a topic exists and panics if not using provided context
func (r *Topic) MustExistsWithContext(ctx context.Context, req *TopicSearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// TopicDelete_DELETE_Body represents the request body for TopicDelete
type TopicDelete_DELETE_Body struct {
	DatabaseName   string `json:"database_name,omitempty" yaml:"database_name,omitempty" required:"true" doc:"Name of the Database"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:"Name of the object"`
	SchemaName     string `json:"schema_name,omitempty" yaml:"schema_name,omitempty" required:"true" doc:"Name of the Schema"`
	IsImportsTable bool   `json:"is_imports_table,omitempty" yaml:"is_imports_table,omitempty" required:"false" doc:"Is table actually a sub-table to track imported .parquet files."`
	TenantId       int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Tenant ID"`
}

// TopicDeleteWithContext_DELETE
// method: DELETE
// url: /topics/delete/
// summary: Delete a Kafka Topic
func (r *Topic) TopicDeleteWithContext_DELETE(ctx context.Context, body *TopicDelete_DELETE_Body) error {
	resourcePath := "/topics/delete/"

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return err
	}

	_, err = core.Request[core.EmptyRecord](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// TopicDelete_DELETE
// method: DELETE
// url: /topics/delete/
// summary: Delete a Kafka Topic
func (r *Topic) TopicDelete_DELETE(body *TopicDelete_DELETE_Body) error {
	return r.TopicDeleteWithContext_DELETE(r.Untyped.GetCtx(), body)
}

// TopicShow_GET_Body represents the request body for TopicShow
type TopicShow_GET_Body struct {
	DatabaseName string `json:"database_name,omitempty" yaml:"database_name,omitempty" required:"false" doc:"Getting list of objects by database_name"`
	Name         string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Getting object by exact match"`
}

// TopicShow_GET_Model represents the response model for TopicShow
type TopicShow_GET_Model struct {
	Capacity                    int64  `json:"capacity,omitempty" yaml:"capacity,omitempty" required:"true" doc:"Capacity of the Topic"`
	DatabaseName                string `json:"database_name,omitempty" yaml:"database_name,omitempty" required:"true" doc:"Name of the Database"`
	Name                        string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:"Name of the Topic"`
	NumEvents                   int64  `json:"num_events,omitempty" yaml:"num_events,omitempty" required:"true" doc:"Total number of events"`
	MessageTimestampAfterMaxMs  int64  `json:"message_timestamp_after_max_ms,omitempty" yaml:"message_timestamp_after_max_ms,omitempty" required:"false" doc:"If the message timestamp type is set to ?CreateTime??, this option determines how much later the message timestamp can be than the broker timestamp. If this value is exceeded, the message is rejected."`
	MessageTimestampBeforeMaxMs int64  `json:"message_timestamp_before_max_ms,omitempty" yaml:"message_timestamp_before_max_ms,omitempty" required:"false" doc:"If the message timestamp type is set to ?CreateTime??, this option determines how much earlier the message timestamp can be than the broker timestamp. If this value is exceeded, the message is rejected."`
	MessageTimestampType        string `json:"message_timestamp_type,omitempty" yaml:"message_timestamp_type,omitempty" required:"false" doc:"Determines how the event timestamp is set. CreateTime (default)=The timestamp is based on the time when the event was encountered at the event producer. LogAppendTime=The timestamp is based on the time when the event record was added to the log at the event broker."`
	RetentionMs                 int64  `json:"retention_ms,omitempty" yaml:"retention_ms,omitempty" required:"false" doc:"The amount of time, in milliseconds, to keep an event record in the topic. When the retention period for a record expires, the records is deleted from the topic."`
	TopicPartitions             int64  `json:"topic_partitions,omitempty" yaml:"topic_partitions,omitempty" required:"false" doc:"The number of partitions in the Kafka topic to be created.Each partition can hold up to 1000 topics. The number of partitions in a topic cannot be changed after the topic has been created."`
}

// TopicShowWithContext_GET
// method: GET
// url: /topics/show/
// summary: Show a Kafka Topic
func (r *Topic) TopicShowWithContext_GET(ctx context.Context, params *TopicShow_GET_Body) (*TopicShow_GET_Model, error) {
	resourcePath := "/topics/show/"

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response TopicShow_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// TopicShow_GET
// method: GET
// url: /topics/show/
// summary: Show a Kafka Topic
func (r *Topic) TopicShow_GET(params *TopicShow_GET_Body) (*TopicShow_GET_Model, error) {
	return r.TopicShowWithContext_GET(r.Untyped.GetCtx(), params)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - CREATE operation excluded: POST topics has no response schema and doesn't return 204 NO CONTENT
//   - UPDATE operation excluded: PATCH/PUT /topics/{id}/ has no response schema and doesn't return 204 NO CONTENT
