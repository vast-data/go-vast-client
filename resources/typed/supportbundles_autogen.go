// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|DELETE

package typed

import (
	"context"
	"net/http"
	"time"

	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/resources/untyped"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// SupportBundles represents a typed resource for supportbundles operations
type SupportBundles struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// SupportBundlesSearchParams represents the search parameters for SupportBundles operations
type SupportBundlesSearchParams struct {
	Guid string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	Name string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:""`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &SupportBundlesSearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// SupportBundlesRequestBody represents the request body for SupportBundles operations
type SupportBundlesRequestBody struct {
	AccessKey       string  `json:"access_key,omitempty" yaml:"access_key,omitempty" required:"false" doc:"S3 Bucket access key"`
	Aggregated      bool    `json:"aggregated,omitempty" yaml:"aggregated,omitempty" required:"false" doc:"Saves an aggregated bundle file on the management CNode in addition to the separate bundle files that are saved per node. (deprecated)"`
	AstronArgs      string  `json:"astron_args,omitempty" yaml:"astron_args,omitempty" required:"false" doc:"Arguments for the astron command. Note: times should be in UTC (Use with caution)"`
	BucketName      string  `json:"bucket_name,omitempty" yaml:"bucket_name,omitempty" required:"false" doc:"S3 Bucket for upload"`
	BucketSubdir    string  `json:"bucket_subdir,omitempty" yaml:"bucket_subdir,omitempty" required:"false" doc:"Sub-Directory in support bucket"`
	CnodeIds        string  `json:"cnode_ids,omitempty" yaml:"cnode_ids,omitempty" required:"false" doc:"Collect from specific CNodes. Specify as a comma separated array of CNode IDs. If not specified, logs are collected from all CNodes."`
	CnodesOnly      bool    `json:"cnodes_only,omitempty" yaml:"cnodes_only,omitempty" required:"false" doc:"Collect logs from CNodes only"`
	DeleteAfterSend bool    `json:"delete_after_send,omitempty" yaml:"delete_after_send,omitempty" required:"false" doc:"Delete bundle immediately after successfully uploading"`
	DnodeIds        string  `json:"dnode_ids,omitempty" yaml:"dnode_ids,omitempty" required:"false" doc:"Collect from specific DNodes. Specify as a comma separated array of DNode IDs. If not specified, logs are collected from all DNodes."`
	DnodesOnly      bool    `json:"dnodes_only,omitempty" yaml:"dnodes_only,omitempty" required:"false" doc:"Collect logs from DNodes only"`
	EndTime         string  `json:"end_time,omitempty" yaml:"end_time,omitempty" required:"false" doc:"End time of logs in UTC+3"`
	HubbleArgs      string  `json:"hubble_args,omitempty" yaml:"hubble_args,omitempty" required:"false" doc:"Arguments for the hubble command. Note: times should be in UTC (Use with caution)"`
	Level           string  `json:"level,omitempty" yaml:"level,omitempty" required:"false" doc:"Bundle level e.g. small, medium, large"`
	LunaArgs        string  `json:"luna_args,omitempty" yaml:"luna_args,omitempty" required:"false" doc:"Arguments for the luna analyzing tool"`
	MaxSize         float32 `json:"max_size,omitempty" yaml:"max_size,omitempty" required:"false" doc:"Maximum data limit to apply to the collection of binary trace files, in GB, per node."`
	MdToolAddresses string  `json:"md_tool_addresses,omitempty" yaml:"md_tool_addresses,omitempty" required:"false" doc:"A comma separated list of block addresses to send to md_tool_cli"`
	MdToolHandles   string  `json:"md_tool_handles,omitempty" yaml:"md_tool_handles,omitempty" required:"false" doc:"A comma separated list of handles to send to md_tool_cli"`
	Obfuscated      bool    `json:"obfuscated,omitempty" yaml:"obfuscated,omitempty" required:"false" doc:"Converts all bundled objects to text and obfuscates them. Any data that cannot be converted to text is not included in the bundle. The following types of information are replaced with a non-reversible hash: file and directory names, IP addresses, host names, user names, passwords, MAC addresses."`
	Path            string  `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:"Bundle path"`
	Prefix          string  `json:"prefix,omitempty" yaml:"prefix,omitempty" required:"false" doc:"Specify an identifying label to include in the bundle file name."`
	Preset          string  `json:"preset,omitempty" yaml:"preset,omitempty" required:"false" doc:"A predefined preset bundle"`
	SecretKey       string  `json:"secret_key,omitempty" yaml:"secret_key,omitempty" required:"false" doc:"S3 Bucket secret key"`
	SendNow         bool    `json:"send_now,omitempty" yaml:"send_now,omitempty" required:"false" doc:"Upload Support Bundle immediately after creation"`
	StartTime       string  `json:"start_time,omitempty" yaml:"start_time,omitempty" required:"false" doc:"Start time of logs in UTC+3"`
	TcpdumpArgs     string  `json:"tcpdump_args,omitempty" yaml:"tcpdump_args,omitempty" required:"false" doc:"Additional arguments for running tcpdump"`
	Text            bool    `json:"text,omitempty" yaml:"text,omitempty" required:"false" doc:"Convert all bundled objects to a textual format. Any data that cannot be converted to text is not included in the bundle."`
	UploadViaVms    bool    `json:"upload_via_vms,omitempty" yaml:"upload_via_vms,omitempty" required:"false" doc:"If true, upload non-aggregated Support Bundle via VMS. Otherwise, upload from each node."`
	VippoolIds      string  `json:"vippool_ids,omitempty" yaml:"vippool_ids,omitempty" required:"false" doc:"Collect support bundle from CNodes in these vip-pools IDs"`
	VolumeSize      float64 `json:"volume_size,omitempty" yaml:"volume_size,omitempty" required:"false" doc:"Enables streaming. Maximum size of slice of support data of category that supports slicing, GiB."`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// SupportBundlesDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/SupportBundle
type SupportBundlesDetailsModel = Component_SupportBundle

// SupportBundlesUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/AsyncSupportBundle
type SupportBundlesUpsertModel = Component_AsyncSupportBundle

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple supportbundless with typed request/response
// summary: List Support Bundles
func (r *SupportBundles) List(req *SupportBundlesSearchParams) ([]*SupportBundlesDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple supportbundless with typed request/response using provided context
// summary: List Support Bundles
func (r *SupportBundles) ListWithContext(ctx context.Context, req *SupportBundlesSearchParams) ([]*SupportBundlesDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*SupportBundlesDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single supportbundles with typed request/response
// summary: List Support Bundles
func (r *SupportBundles) Get(req *SupportBundlesSearchParams) (*SupportBundlesDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single supportbundles with typed request/response using provided context
// summary: List Support Bundles
func (r *SupportBundles) GetWithContext(ctx context.Context, req *SupportBundlesSearchParams) (*SupportBundlesDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response SupportBundlesDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single supportbundles by ID
// summary: Return Details of a Support Bundle
func (r *SupportBundles) GetById(id any) (*SupportBundlesDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single supportbundles by ID using provided context
// summary: Return Details of a Support Bundle
func (r *SupportBundles) GetByIdWithContext(ctx context.Context, id any) (*SupportBundlesDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response SupportBundlesDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new supportbundles with typed request/response
// summary: Create a Support Bundle
func (r *SupportBundles) Create(req *SupportBundlesRequestBody) (*SupportBundlesUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new supportbundles with typed request/response using provided context
// summary: Create a Support Bundle
func (r *SupportBundles) CreateWithContext(ctx context.Context, req *SupportBundlesRequestBody) (*SupportBundlesUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response SupportBundlesUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a supportbundles with search parameters
func (r *SupportBundles) Delete(req *SupportBundlesSearchParams) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req)
}

// DeleteWithContext deletes a supportbundles with search parameters using provided context
func (r *SupportBundles) DeleteWithContext(ctx context.Context, req *SupportBundlesSearchParams) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a supportbundles by ID
// summary: Delete a Support Bundle
//
// Parameters:
//   - id: Support Bundle ID
func (r *SupportBundles) DeleteById(id any) error {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id)
}

// DeleteByIdWithContext deletes a supportbundles by ID using provided context
// summary: Delete a Support Bundle
//
// Parameters:
//   - id: Support Bundle ID
func (r *SupportBundles) DeleteByIdWithContext(ctx context.Context, id any) error {
	_, err := r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteByIdWithContext(ctx, id, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a supportbundles exists with typed response
func (r *SupportBundles) Ensure(searchParams *SupportBundlesSearchParams, body *SupportBundlesRequestBody) (*SupportBundlesUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a supportbundles exists with typed response using provided context
func (r *SupportBundles) EnsureWithContext(ctx context.Context, searchParams *SupportBundlesSearchParams, body *SupportBundlesRequestBody) (*SupportBundlesUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response SupportBundlesUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a supportbundles exists
func (r *SupportBundles) Exists(req *SupportBundlesSearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a supportbundles exists using provided context
func (r *SupportBundles) ExistsWithContext(ctx context.Context, req *SupportBundlesSearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a supportbundles exists and panics if not
func (r *SupportBundles) MustExists(req *SupportBundlesSearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a supportbundles exists and panics if not using provided context
func (r *SupportBundles) MustExistsWithContext(ctx context.Context, req *SupportBundlesSearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// SupportBundlesUpload_PATCH_Body represents the request body for SupportBundlesUpload
type SupportBundlesUpload_PATCH_Body struct {
	AccessKey    string `json:"access_key,omitempty" yaml:"access_key,omitempty" required:"false" doc:"S3 Bucket access key"`
	BucketName   string `json:"bucket_name,omitempty" yaml:"bucket_name,omitempty" required:"false" doc:"S3 Bucket for upload"`
	BucketSubdir string `json:"bucket_subdir,omitempty" yaml:"bucket_subdir,omitempty" required:"false" doc:"Subdirectory in support bucket"`
	SecretKey    string `json:"secret_key,omitempty" yaml:"secret_key,omitempty" required:"false" doc:"S3 Bucket secret key"`
	UploadViaVms bool   `json:"upload_via_vms,omitempty" yaml:"upload_via_vms,omitempty" required:"false" doc:"If true, upload non-aggregated Support Bundle via VMS. Otherwise, upload from each node."`
}

// SupportBundlesUploadWithContext_PATCH
// method: PATCH
// url: /supportbundles/{id}/upload/
// summary: Upload Support Bundle to AWS S3.
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *SupportBundles) SupportBundlesUploadWithContext_PATCH(ctx context.Context, id any, body *SupportBundlesUpload_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("supportbundles", id, "upload")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	return untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)

}

// SupportBundlesUpload_PATCH
// method: PATCH
// url: /supportbundles/{id}/upload/
// summary: Upload Support Bundle to AWS S3.
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *SupportBundles) SupportBundlesUpload_PATCH(id any, body *SupportBundlesUpload_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.SupportBundlesUploadWithContext_PATCH(r.Untyped.GetCtx(), id, body, waitTimeout)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - Extra method GET /supportbundles/{id}/download/ skipped: GET /supportbundles/{id}/download/ - No response schema defined in OpenAPI spec. Error: GET response missing or malformed schema
//   - UPDATE operation excluded: PATCH/PUT /supportbundles/{id}/ has no response schema and doesn't return 204 NO CONTENT
