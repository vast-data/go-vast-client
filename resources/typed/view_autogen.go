// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|DELETE

package typed

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/resources/untyped"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// View represents a typed resource for view operations
type View struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// ViewSearchParams represents the search parameters for View operations
type ViewSearchParams struct {
	Alias    string `json:"alias,omitempty" yaml:"alias,omitempty" required:"false" doc:"Filter by NFS export alias"`
	Bucket   string `json:"bucket,omitempty" yaml:"bucket,omitempty" required:"false" doc:"Limit response by S3 bucket name"`
	Guid     string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Filter by View name"`
	Nqn      string `json:"nqn,omitempty" yaml:"nqn,omitempty" required:"false" doc:"NVMe Qualified Name to filter by."`
	Path     string `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:"Filter by Element Store path"`
	Share    string `json:"share,omitempty" yaml:"share,omitempty" required:"false" doc:"Filter by share name"`
	TenantId int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Filter by tenant. Specify tenant ID."`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &ViewSearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// ViewRequestBody_BucketLogging represents a nested type for request body
type ViewRequestBody_BucketLogging struct {
	DestinationId int64  `json:"destination_id,omitempty" yaml:"destination_id,omitempty" required:"true" doc:"Specifies a view ID as the destination bucket for S3 bucket logging. The specified view must have the S3 bucket protocol enabled, must be on the same tenant as the view itself (the source view), must have the same bucket owner, and cannot be the same view as the source view. It also must not have S3 object locking enabled. In bucket logging, a log entry is created in AWS log format for each request made to the source bucket. The log entries are periodically uploaded to the destination bucket. Configuring destination_id enables S3 bucket logging for the view."`
	KeyFormat     string `json:"key_format,omitempty" yaml:"key_format,omitempty" required:"false" doc:"The format for the S3 bucket logging object keys. SIMPLE_PREFIX=[DestinationPrefix][YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString], PARTITIONED_PREFIX_EVENT_TIME=[DestinationPrefix][SourceUsername]/[SourceBucket]/[YYYY]/[MM]/[DD]/[YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString] where the partitioning is done based on the time when the logged events occurred, PARTITIONED_PREFIX_DELIVERY_TIME=[DestinationPrefix][SourceUsername]/[SourceBucket]/[YYYY]/[MM]/[DD]/[YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString] where the partitioning is done based on the time when the log object has been delivered to the destination bucket. Default: SIMPLE_PREFIX"`
	Prefix        string `json:"prefix,omitempty" yaml:"prefix,omitempty" required:"false" doc:"Specifies a prefix to be prepended to each key of a log object uploaded to the destination bucket. This prefix can be used to categorize log objects; for example, if you use the same destination bucket for multiple source buckets. The prefix can be up to 128 characters and must follow S3 object naming rules."`
}

// ViewRequestBody_CreateDirAclItem represents a nested type for request body
type ViewRequestBody_CreateDirAclItem struct {
	Grantee   string `json:"grantee,omitempty" yaml:"grantee,omitempty" required:"true" doc:"type of grantee"`
	Perm      string `json:"perm,omitempty" yaml:"perm,omitempty" required:"true" doc:"The type of permission to grant to the grantee"`
	GroupType string `json:"group_type,omitempty" yaml:"group_type,omitempty" required:"false" doc:""`
	SidStr    string `json:"sid_str,omitempty" yaml:"sid_str,omitempty" required:"false" doc:"SID attribute of grantee. Specify this attribute or another for the grantee."`
	UidOrGid  string `json:"uid_or_gid,omitempty" yaml:"uid_or_gid,omitempty" required:"false" doc:"UID of user type grantee or GID of group type grantee. Specify this attribute or another attribute for the grantee."`
	VidOrVaid string `json:"vid_or_vaid,omitempty" yaml:"vid_or_vaid,omitempty" required:"false" doc:"VID of user type grantee or VAID of group type grantee. This is a VAST user or group attribute. Specify this attribute or another attribute for the guarantee."`
}

// ViewRequestBody_EventNotificationsItem represents a nested type for request body
type ViewRequestBody_EventNotificationsItem struct {
	BrokerId     int64     `json:"broker_id,omitempty" yaml:"broker_id,omitempty" required:"false" doc:"Event broker ID"`
	Name         string    `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Event unique name"`
	PrefixFilter string    `json:"prefix_filter,omitempty" yaml:"prefix_filter,omitempty" required:"false" doc:"Event prefix filter"`
	SuffixFilter string    `json:"suffix_filter,omitempty" yaml:"suffix_filter,omitempty" required:"false" doc:"Event suffix filter"`
	Topic        string    `json:"topic,omitempty" yaml:"topic,omitempty" required:"false" doc:"Event topic"`
	Triggers     *[]string `json:"triggers,omitempty" yaml:"triggers,omitempty" required:"false" doc:"Event triggers"`
}

// ViewRequestBody_UserImpersonation represents a nested type for request body
type ViewRequestBody_UserImpersonation struct {
	Enabled        bool   `json:"enabled,omitempty" yaml:"enabled,omitempty" required:"false" doc:"True if user impersonation is enabled"`
	Identifier     string `json:"identifier,omitempty" yaml:"identifier,omitempty" required:"false" doc:"Identifier of the user to impersonate"`
	IdentifierType string `json:"identifier_type,omitempty" yaml:"identifier_type,omitempty" required:"false" doc:"The identifier type of the specified identifier."`
	LoginName      string `json:"login_name,omitempty" yaml:"login_name,omitempty" required:"false" doc:"Full username of user to impersonate, including domain name"`
	Username       string `json:"username,omitempty" yaml:"username,omitempty" required:"false" doc:"The username of the user to impersonate"`
}

// ViewRequestBody represents the request body for View operations
type ViewRequestBody struct {
	Path                          string                                    `json:"path,omitempty" yaml:"path,omitempty" required:"true" doc:"The full Element Store path to from the top level of the storage system on the cluster to the location that you want to expose. Begin with '/'. Do not include a trailing slash."`
	PolicyId                      int64                                     `json:"policy_id,omitempty" yaml:"policy_id,omitempty" required:"true" doc:"Every view must be attached to one view policy, which specifies further configurations. Specify by view policy ID which view policy should be used for the view."`
	AbacTags                      *[]string                                 `json:"abac_tags,omitempty" yaml:"abac_tags,omitempty" required:"false" doc:"list of ABAC tags"`
	AbeMaxDepth                   int64                                     `json:"abe_max_depth,omitempty" yaml:"abe_max_depth,omitempty" required:"false" doc:"Restricts ABE to a specified path depth. For example, if max depth is 3, ABE does not affect paths deeper than three levels. If not specified, ABE affects all path depths."`
	AbeProtocols                  *[]string                                 `json:"abe_protocols,omitempty" yaml:"abe_protocols,omitempty" required:"false" doc:"The protocols for which Access-Based Enumeration (ABE) is enabled"`
	Alias                         string                                    `json:"alias,omitempty" yaml:"alias,omitempty" required:"false" doc:"Relevant if NFS is included in the protocols array. An alias for the mount path of an NFSv3 export. The alias must begin with a forward slash ('/') and must consist of only ASCII characters. If specified, the alias that can be used by NFSv3 clients to mount the view."`
	AllowAnonymousAccess          bool                                      `json:"allow_anonymous_access,omitempty" yaml:"allow_anonymous_access,omitempty" required:"false" doc:"not in use"`
	AllowS3AnonymousAccess        bool                                      `json:"allow_s3_anonymous_access,omitempty" yaml:"allow_s3_anonymous_access,omitempty" required:"false" doc:"Allow S3 anonymous access to S3 bucket. If true, anonymous requests are granted provided that the object ACL grants access to the All Users group (in S3 Native security flavor) or the permission mode bits on the requested file and directory path grant access permission to 'others' (in NFS security flavor)."`
	AutoCommit                    string                                    `json:"auto_commit,omitempty" yaml:"auto_commit,omitempty" required:"false" doc:"Applicable if locking is enabled. Sets the auto-commit time for files that are locked automatically. These files are locked automatically after the auto-commit period elapses from the time the file is saved. Files locked automatically are locked for the default-retention-period, after which they are unlocked. Specify as an integer value followed by a letter for the unit (h - hours, d - days, y - years). Example: 2h (2 hours)."`
	Bucket                        string                                    `json:"bucket,omitempty" yaml:"bucket,omitempty" required:"false" doc:"A name for the S3 bucket name. Must be specified if S3 bucket is specified in protocols."`
	BucketCreators                *[]string                                 `json:"bucket_creators,omitempty" yaml:"bucket_creators,omitempty" required:"false" doc:"For S3 endpoint views, specify a list of users, by user name, whose bucket create requests use this view. Any request to create an S3 bucket that is sent by S3 API by a specified user will use this S3 Endpoint view. Users should not be specified as bucket creators in more than one S3 Endpoint view. Naming a user as a bucket creator in two S3 Endpoint views will fail the creation of the view with an error."`
	BucketCreatorsGroups          *[]string                                 `json:"bucket_creators_groups,omitempty" yaml:"bucket_creators_groups,omitempty" required:"false" doc:"For S3 endpoint views, specify a list of groups, by group name, whose bucket create requests use this view. Any request to create an S3 bucket that is sent by S3 API by a user who belongs to a group listed here will use this S3 Endpoint view. Take extra care not to duplicate bucket creators through groups: If you specify a group as a bucket creator group in one view and you also specify a user who belongs to that group as a bucket creator user in another view, view creation will not fail. Yet, there is a conflict between the two configurations and the selection of a view for configuring the user's buckets is not predictable."`
	BucketLogging                 ViewRequestBody_BucketLogging             `json:"bucket_logging,omitempty" yaml:"bucket_logging,omitempty" required:"false" doc:""`
	BucketOwner                   string                                    `json:"bucket_owner,omitempty" yaml:"bucket_owner,omitempty" required:"false" doc:"Specifies a user to be the bucket owner. Specify as user name. Must be specified if S3 Bucket is included in protocols."`
	BucketOwnerType               string                                    `json:"bucket_owner_type,omitempty" yaml:"bucket_owner_type,omitempty" required:"false" doc:""`
	ClusterId                     int64                                     `json:"cluster_id,omitempty" yaml:"cluster_id,omitempty" required:"false" doc:"Cluster ID"`
	CreateDir                     bool                                      `json:"create_dir,omitempty" yaml:"create_dir,omitempty" required:"false" doc:"Create a directory at the specified path. Set to true if the specified path does not exist."`
	CreateDirAcl                  *[]ViewRequestBody_CreateDirAclItem       `json:"create_dir_acl,omitempty" yaml:"create_dir_acl,omitempty" required:"false" doc:"Define ACL for the newly created dir"`
	CreateDirMode                 int64                                     `json:"create_dir_mode,omitempty" yaml:"create_dir_mode,omitempty" required:"false" doc:"Unix permissions mode for the new dir"`
	DefaultRetentionPeriod        string                                    `json:"default_retention_period,omitempty" yaml:"default_retention_period,omitempty" required:"false" doc:"Relevant if locking is enabled. Required if s3_locks_retention_mode is set to governance or compliance. Specifies a default retention period for objects in the bucket. If set, object versions that are placed in the bucket are automatically protected with the specified retention lock. Otherwise, by default, each object version has no automatic protection but can be configured with a retention period or legal hold. Specify as an integer followed by h for hours, d for days, m for months, or y for years. For example: 2d or 1y."`
	EventNotifications            *[]ViewRequestBody_EventNotificationsItem `json:"event_notifications,omitempty" yaml:"event_notifications,omitempty" required:"false" doc:""`
	FilesRetentionMode            string                                    `json:"files_retention_mode,omitempty" yaml:"files_retention_mode,omitempty" required:"false" doc:"Applicable if locking is enabled. The retention mode for new files. For views enabled for NFSv3 or SMB, if locking is enabled, files_retention_mode must be set to GOVERNANCE or COMPLIANCE. If the view is enabled for S3 and not for NFSv3 or SMB, files_retention_mode can be set to NONE. If GOVERNANCE, locked files cannot be deleted or changed. The Retention settings can be shortened or extended by users with sufficient permissions. If COMPLIANCE, locked files cannot be deleted or changed. Retention settings can be extended, but not shortened, by users with sufficient permissions. If NONE (S3 only), the retention mode is not set for the view; it is set individually for each object."`
	IndestructibleObjectDuration  int64                                     `json:"indestructible_object_duration,omitempty" yaml:"indestructible_object_duration,omitempty" required:"false" doc:"Retention period for objects, in days. Each object in the bucket is protected from deletion, overwriting, renaming and metadata changes for the specified number of days after its creation date."`
	InheritAcl                    bool                                      `json:"inherit_acl,omitempty" yaml:"inherit_acl,omitempty" required:"false" doc:"Indicates whether the directory should inherit ACLs from its parent directory"`
	IsDefaultSubsystem            bool                                      `json:"is_default_subsystem,omitempty" yaml:"is_default_subsystem,omitempty" required:"false" doc:"Set to true to set view to be the default subsystem for block storage. There can be up to one default subsystem per tenant. The default subsystem is the default view selected when creating a block volume if no view is specified."`
	IsIndestructibleObjectEnabled bool                                      `json:"is_indestructible_object_enabled,omitempty" yaml:"is_indestructible_object_enabled,omitempty" required:"false" doc:"Set to true to enable indestructible object mode on the view. This is supported only if S3 is the only specified protocol. Other limitations also apply."`
	IsKafkaEncryptedConnAllowed   bool                                      `json:"is_kafka_encrypted_conn_allowed,omitempty" yaml:"is_kafka_encrypted_conn_allowed,omitempty" required:"false" doc:"True if encrypted connection is allowed for Kafka"`
	IsKafkaUnencryptedConnAllowed bool                                      `json:"is_kafka_unencrypted_conn_allowed,omitempty" yaml:"is_kafka_unencrypted_conn_allowed,omitempty" required:"false" doc:"True if unencrypted connection is allowed for Kafka"`
	IsSeamless                    bool                                      `json:"is_seamless,omitempty" yaml:"is_seamless,omitempty" required:"false" doc:"Supports seamless failover between replication peers by syncing file handles between the view and remote views on the replicated path on replication peers. This enables NFSv3 client users to retain the same mount point to the view in the event of a failover of the view path to a replication peer. This feature enables NFSv3 client users to retain the same mount point to the view in the event of a failover of the view path to a replication peer. Enabling this option may cause overhead and should only be enabled when the use case is relevant. To complete the configuration for seamless failover between any two peers, a seamless view must be created on each peer."`
	KafkaEncryptedAuthMechanism   string                                    `json:"kafka_encrypted_auth_mechanism,omitempty" yaml:"kafka_encrypted_auth_mechanism,omitempty" required:"false" doc:"Authentication mechanism for encrypted connection"`
	KafkaFirstJoinGroupTimeoutSec int64                                     `json:"kafka_first_join_group_timeout_sec,omitempty" yaml:"kafka_first_join_group_timeout_sec,omitempty" required:"false" doc:"Kafka first join group timeout, in seconds"`
	KafkaIsAuthorizationRequired  bool                                      `json:"kafka_is_authorization_required,omitempty" yaml:"kafka_is_authorization_required,omitempty" required:"false" doc:"True if authorization is required for Kafka"`
	KafkaRejoinGroupTimeoutSec    int64                                     `json:"kafka_rejoin_group_timeout_sec,omitempty" yaml:"kafka_rejoin_group_timeout_sec,omitempty" required:"false" doc:"Kafka rejoin group timeout, in seconds"`
	KafkaUnencryptedAuthMechanism string                                    `json:"kafka_unencrypted_auth_mechanism,omitempty" yaml:"kafka_unencrypted_auth_mechanism,omitempty" required:"false" doc:"Authentication mechanism for unencrypted connection"`
	KafkaVipPools                 *[]int64                                  `json:"kafka_vip_pools,omitempty" yaml:"kafka_vip_pools,omitempty" required:"false" doc:"For Kafka-enabled views, an array of IDs of Virtual IP pools used to access event topics exposed by the view. The specified virtual IP pool must belong to the same tenant as the Kafka-enabled view. Must also not be a virtual IP pool that is excluded by the view policy's virtual IP pool association."`
	Locking                       bool                                      `json:"locking,omitempty" yaml:"locking,omitempty" required:"false" doc:"Set to true to enable object locking on a view. Object locking cannot be disabled after the view is created. Must be true if s3_versioning is true."`
	MaxRetentionPeriod            string                                    `json:"max_retention_period,omitempty" yaml:"max_retention_period,omitempty" required:"false" doc:"Applicable if locking is enabled. Sets a maximum retention period for files that are locked in the view. Files cannot be locked for longer than this period, whether they are locked manually (by setting the atime) or automatically, using auto-commit. Specify as an integer value followed by a letter for the unit (m - minutes, h - hours, d - days, y - years). Example: 2y (2 years)."`
	MinRetentionPeriod            string                                    `json:"min_retention_period,omitempty" yaml:"min_retention_period,omitempty" required:"false" doc:"Applicable if locking is enabled. Sets a minimum retention period for files that are locked in the view. Files cannot be locked for less than this period, whether locked manually (by setting the atime) or automatically, using auto-commit. Specify as an integer value followed by a letter for the unit (h - hours, d - days, m - months, y - years). Example: 1d (1 day)."`
	Name                          string                                    `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"A name for the view"`
	NfsInteropFlags               string                                    `json:"nfs_interop_flags,omitempty" yaml:"nfs_interop_flags,omitempty" required:"false" doc:"Indicates whether the view should support simultaneous access to NFS3/NFS4/SMB protocols."`
	Owner                         string                                    `json:"owner,omitempty" yaml:"owner,omitempty" required:"false" doc:"The owner of the folder. Specify the owner using the attribute type set by owner_type. You can specify a group as the owner, as supported by SMB. To enable setting a group as the owner, set owner_is_group=true. In all cases, set owning_group also."`
	OwnerIsGroup                  bool                                      `json:"owner_is_group,omitempty" yaml:"owner_is_group,omitempty" required:"false" doc:"Set to true if passing a group as the owner of the folder. This feature is used to enable setting a group as the owner, as supported by SMB."`
	OwnerType                     string                                    `json:"owner_type,omitempty" yaml:"owner_type,omitempty" required:"false" doc:"The type of attribute used to specify owner."`
	OwningGroup                   string                                    `json:"owning_group,omitempty" yaml:"owning_group,omitempty" required:"false" doc:"The owning group of the folder."`
	OwningGroupType               string                                    `json:"owning_group_type,omitempty" yaml:"owning_group_type,omitempty" required:"false" doc:"The type of attribute to use to specify the owning group of the folder."`
	Protocols                     *[]string                                 `json:"protocols,omitempty" yaml:"protocols,omitempty" required:"false" doc:"Protocols enabled for access to the view. 'NFS' enables access from NFS version 3, 'NFS4' enables access from NFS version 4.1 and 4.2, S3' creates an S3 bucket on the view, 'ENDPOINT' creates an S3 endpoint, used as template for views created via S3 RPCs, DATABASE exposes the view as a VAST database. KAFKA enables events related to elements on the view path to be published to the VAST Event Broker. BLOCK exposes the view as a block storage subsystem."`
	QosPolicy                     string                                    `json:"qos_policy,omitempty" yaml:"qos_policy,omitempty" required:"false" doc:"QoS Policy"`
	QosPolicyId                   int64                                     `json:"qos_policy_id,omitempty" yaml:"qos_policy_id,omitempty" required:"false" doc:"Associates a QoS policy with the view."`
	S3LocksRetentionMode          string                                    `json:"s3_locks_retention_mode,omitempty" yaml:"s3_locks_retention_mode,omitempty" required:"false" doc:"The retention mode for new object versions stored in this bucket. You can override this if you upload a new object version with an explicit retention mode and period."`
	S3ObjectOwnershipRule         string                                    `json:"s3_object_ownership_rule,omitempty" yaml:"s3_object_ownership_rule,omitempty" required:"false" doc:""`
	S3UnverifiedLookup            bool                                      `json:"s3_unverified_lookup,omitempty" yaml:"s3_unverified_lookup,omitempty" required:"false" doc:"S3 Unverified Lookup"`
	S3Versioning                  bool                                      `json:"s3_versioning,omitempty" yaml:"s3_versioning,omitempty" required:"false" doc:"Enable S3 Versioning if S3 bucket. Versioning cannot be disabled after the view is created."`
	SelectForLiveMonitoring       bool                                      `json:"select_for_live_monitoring,omitempty" yaml:"select_for_live_monitoring,omitempty" required:"false" doc:"Enables live monitoring on the view. Live monitoring can be enabled for up to ten views at one time. Analytics data for views is polled every 5 minutes by default and every 10 seconds with live monitoring."`
	Share                         string                                    `json:"share,omitempty" yaml:"share,omitempty" required:"false" doc:"SMB share name. Must be specified if SMB is specified in protocols."`
	SmbEncryptionState            string                                    `json:"smb_encryption_state,omitempty" yaml:"smb_encryption_state,omitempty" required:"false" doc:"Defines the encryption level for SMB"`
	TenantId                      int64                                     `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Associates the specified tenant with the view."`
	UserImpersonation             ViewRequestBody_UserImpersonation         `json:"user_impersonation,omitempty" yaml:"user_impersonation,omitempty" required:"false" doc:""`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// ViewDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/View
type ViewDetailsModel = Component_View

// ViewUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/View
type ViewUpsertModel = Component_View

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple views with typed request/response
// summary: List Views
func (r *View) List(req *ViewSearchParams) ([]*ViewDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple views with typed request/response using provided context
// summary: List Views
func (r *View) ListWithContext(ctx context.Context, req *ViewSearchParams) ([]*ViewDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*ViewDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single view with typed request/response
// summary: List Views
func (r *View) Get(req *ViewSearchParams) (*ViewDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single view with typed request/response using provided context
// summary: List Views
func (r *View) GetWithContext(ctx context.Context, req *ViewSearchParams) (*ViewDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ViewDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single view by ID
// summary: Return Details of a View
func (r *View) GetById(id any) (*ViewDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single view by ID using provided context
// summary: Return Details of a View
func (r *View) GetByIdWithContext(ctx context.Context, id any) (*ViewDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response ViewDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new view with typed request/response
// summary: Create View
func (r *View) Create(req *ViewRequestBody) (*ViewUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new view with typed request/response using provided context
// summary: Create View
func (r *View) CreateWithContext(ctx context.Context, req *ViewRequestBody) (*ViewUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ViewUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a view with search parameters
//
// Parameters:
//   - force: Force View removal
func (r *View) Delete(req *ViewSearchParams, force bool) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req, force)
}

// DeleteWithContext deletes a view with search parameters using provided context
//
// Parameters:
//   - force: Force View removal
func (r *View) DeleteWithContext(ctx context.Context, req *ViewSearchParams, force bool) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}

	// Build DELETE query params
	deleteQueryParams := core.Params{"force": force}
	// Build DELETE body params
	var deleteBody core.Params
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, deleteQueryParams, deleteBody)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a view by ID
// summary: Delete View
//
// Parameters:
//   - id: View ID
//   - force: Force View removal
func (r *View) DeleteById(id any, force bool) error {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id, force)
}

// DeleteByIdWithContext deletes a view by ID using provided context
// summary: Delete View
//
// Parameters:
//   - id: View ID
//   - force: Force View removal
func (r *View) DeleteByIdWithContext(ctx context.Context, id any, force bool) error {

	// Build DELETE query params
	deleteQueryParams := core.Params{"force": force}
	// Build DELETE body params
	var deleteBody core.Params
	_, err := r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteByIdWithContext(ctx, id, deleteQueryParams, deleteBody)
	if err != nil {
		return err
	}
	return nil
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a view exists with typed response
func (r *View) Ensure(searchParams *ViewSearchParams, body *ViewRequestBody) (*ViewUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a view exists with typed response using provided context
func (r *View) EnsureWithContext(ctx context.Context, searchParams *ViewSearchParams, body *ViewRequestBody) (*ViewUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response ViewUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a view exists
func (r *View) Exists(req *ViewSearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a view exists using provided context
func (r *View) ExistsWithContext(ctx context.Context, req *ViewSearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a view exists and panics if not
func (r *View) MustExists(req *ViewSearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a view exists and panics if not using provided context
func (r *View) MustExistsWithContext(ctx context.Context, req *ViewSearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// ViewCheckPermissionsTemplatesModel_TemplateDirPath represents a nested type for View extra method response
type ViewCheckPermissionsTemplatesModel_TemplateDirPath struct {
	Path string                                                  `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:"Path to the template directory"`
	Stat ViewCheckPermissionsTemplatesModel_TemplateDirPath_Stat `json:"stat,omitempty" yaml:"stat,omitempty" required:"false" doc:""`
}

// ViewCheckPermissionsTemplatesModel_TemplateDirPath_Stat represents a nested type for View extra method response
type ViewCheckPermissionsTemplatesModel_TemplateDirPath_Stat struct {
	HasDefaultAcl bool   `json:"has_default_acl,omitempty" yaml:"has_default_acl,omitempty" required:"false" doc:"True if the directory has default ACL. When performing bulk permission update without specifying a template file, the template directory must have default ACL."`
	IsDirectory   bool   `json:"is_directory,omitempty" yaml:"is_directory,omitempty" required:"false" doc:"True if the path is a directory path"`
	OwningGid     int64  `json:"owning_gid,omitempty" yaml:"owning_gid,omitempty" required:"false" doc:"Owning group's gid"`
	OwningGroup   string `json:"owning_group,omitempty" yaml:"owning_group,omitempty" required:"false" doc:"Owning group's group name"`
	OwningUid     int64  `json:"owning_uid,omitempty" yaml:"owning_uid,omitempty" required:"false" doc:"Owning user's uid"`
	OwningUser    string `json:"owning_user,omitempty" yaml:"owning_user,omitempty" required:"false" doc:"Owning user's user name"`
}

// ViewCheckPermissionsTemplatesModel_TemplateFilePath represents a nested type for View extra method response
type ViewCheckPermissionsTemplatesModel_TemplateFilePath struct {
	Path string                                                   `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:"Path to the template file"`
	Stat ViewCheckPermissionsTemplatesModel_TemplateFilePath_Stat `json:"stat,omitempty" yaml:"stat,omitempty" required:"false" doc:""`
}

// ViewCheckPermissionsTemplatesModel_TemplateFilePath_Stat represents a nested type for View extra method response
type ViewCheckPermissionsTemplatesModel_TemplateFilePath_Stat struct {
	HasDefaultAcl string `json:"has_default_acl,omitempty" yaml:"has_default_acl,omitempty" required:"false" doc:"N/A, reflects if the object has default ACL"`
	IsDirectory   string `json:"is_directory,omitempty" yaml:"is_directory,omitempty" required:"false" doc:"False if the path is a file path and not a directory"`
	OwningGid     string `json:"owning_gid,omitempty" yaml:"owning_gid,omitempty" required:"false" doc:"Owning group's gid"`
	OwningGroup   string `json:"owning_group,omitempty" yaml:"owning_group,omitempty" required:"false" doc:"Owning group's group name"`
	OwningUid     string `json:"owning_uid,omitempty" yaml:"owning_uid,omitempty" required:"false" doc:"Owning user's uid"`
	OwningUser    string `json:"owning_user,omitempty" yaml:"owning_user,omitempty" required:"false" doc:"Owning user's user name"`
}

// ViewCloseSmbHandleModel_FileHandle represents a nested type for View extra method response
type ViewCloseSmbHandleModel_FileHandle struct {
	CloneId                   string `json:"clone_id,omitempty" yaml:"clone_id,omitempty" required:"false" doc:""`
	DeletePending             string `json:"delete_pending,omitempty" yaml:"delete_pending,omitempty" required:"false" doc:""`
	Ehandle                   string `json:"ehandle,omitempty" yaml:"ehandle,omitempty" required:"false" doc:""`
	HasAnyLease               string `json:"has_any_lease,omitempty" yaml:"has_any_lease,omitempty" required:"false" doc:""`
	LeaseBreakInProgress      string `json:"lease_break_in_progress,omitempty" yaml:"lease_break_in_progress,omitempty" required:"false" doc:""`
	Nfs4Only                  string `json:"nfs4_only,omitempty" yaml:"nfs4_only,omitempty" required:"false" doc:""`
	NumberOpenProtocolHandles int64  `json:"number_open_protocol_handles,omitempty" yaml:"number_open_protocol_handles,omitempty" required:"false" doc:""`
	StreamKey                 string `json:"stream_key,omitempty" yaml:"stream_key,omitempty" required:"false" doc:"Global access path ID"`
}

// ViewCloseSmbHandleModel_OpenProtocolHandlesItem represents a nested type for View extra method response
type ViewCloseSmbHandleModel_OpenProtocolHandlesItem struct {
	AccessMask        *[]string `json:"access_mask,omitempty" yaml:"access_mask,omitempty" required:"false" doc:""`
	AccessMaskDisplay string    `json:"access_mask_display,omitempty" yaml:"access_mask_display,omitempty" required:"false" doc:"Human readable access mask string values"`
	ClientIp          string    `json:"client_ip,omitempty" yaml:"client_ip,omitempty" required:"false" doc:""`
	FileMode          string    `json:"file_mode,omitempty" yaml:"file_mode,omitempty" required:"false" doc:""`
	HasLease          string    `json:"has_lease,omitempty" yaml:"has_lease,omitempty" required:"false" doc:""`
	IsNfsExpirable    string    `json:"is_nfs_expirable,omitempty" yaml:"is_nfs_expirable,omitempty" required:"false" doc:""`
	Nfs4Seqid         string    `json:"nfs4_seqid,omitempty" yaml:"nfs4_seqid,omitempty" required:"false" doc:""`
	NfsExpirationTime string    `json:"nfs_expiration_time,omitempty" yaml:"nfs_expiration_time,omitempty" required:"false" doc:""`
	ProtoType         string    `json:"proto_type,omitempty" yaml:"proto_type,omitempty" required:"false" doc:""`
	SessionId         string    `json:"session_id,omitempty" yaml:"session_id,omitempty" required:"false" doc:""`
	ShareAccess       string    `json:"share_access,omitempty" yaml:"share_access,omitempty" required:"false" doc:""`
	UniqueId          string    `json:"unique_id,omitempty" yaml:"unique_id,omitempty" required:"false" doc:""`
	Username          string    `json:"username,omitempty" yaml:"username,omitempty" required:"false" doc:""`
}

// ViewListOpenSmbHandlesModel_FileHandle represents a nested type for View extra method response
type ViewListOpenSmbHandlesModel_FileHandle struct {
	CloneId                   string `json:"clone_id,omitempty" yaml:"clone_id,omitempty" required:"false" doc:""`
	DeletePending             string `json:"delete_pending,omitempty" yaml:"delete_pending,omitempty" required:"false" doc:""`
	Ehandle                   string `json:"ehandle,omitempty" yaml:"ehandle,omitempty" required:"false" doc:""`
	HasAnyLease               string `json:"has_any_lease,omitempty" yaml:"has_any_lease,omitempty" required:"false" doc:""`
	LeaseBreakInProgress      string `json:"lease_break_in_progress,omitempty" yaml:"lease_break_in_progress,omitempty" required:"false" doc:""`
	Nfs4Only                  string `json:"nfs4_only,omitempty" yaml:"nfs4_only,omitempty" required:"false" doc:""`
	NumberOpenProtocolHandles int64  `json:"number_open_protocol_handles,omitempty" yaml:"number_open_protocol_handles,omitempty" required:"false" doc:""`
	StreamKey                 string `json:"stream_key,omitempty" yaml:"stream_key,omitempty" required:"false" doc:"Global access path ID"`
}

// ViewListOpenSmbHandlesModel_OpenProtocolHandlesItem represents a nested type for View extra method response
type ViewListOpenSmbHandlesModel_OpenProtocolHandlesItem struct {
	AccessMask        *[]string `json:"access_mask,omitempty" yaml:"access_mask,omitempty" required:"false" doc:""`
	AccessMaskDisplay string    `json:"access_mask_display,omitempty" yaml:"access_mask_display,omitempty" required:"false" doc:"Human readable access mask string values"`
	ClientIp          string    `json:"client_ip,omitempty" yaml:"client_ip,omitempty" required:"false" doc:""`
	FileMode          string    `json:"file_mode,omitempty" yaml:"file_mode,omitempty" required:"false" doc:""`
	HasLease          string    `json:"has_lease,omitempty" yaml:"has_lease,omitempty" required:"false" doc:""`
	IsNfsExpirable    string    `json:"is_nfs_expirable,omitempty" yaml:"is_nfs_expirable,omitempty" required:"false" doc:""`
	Nfs4Seqid         string    `json:"nfs4_seqid,omitempty" yaml:"nfs4_seqid,omitempty" required:"false" doc:""`
	NfsExpirationTime string    `json:"nfs_expiration_time,omitempty" yaml:"nfs_expiration_time,omitempty" required:"false" doc:""`
	ProtoType         string    `json:"proto_type,omitempty" yaml:"proto_type,omitempty" required:"false" doc:""`
	SessionId         string    `json:"session_id,omitempty" yaml:"session_id,omitempty" required:"false" doc:""`
	ShareAccess       string    `json:"share_access,omitempty" yaml:"share_access,omitempty" required:"false" doc:""`
	UniqueId          string    `json:"unique_id,omitempty" yaml:"unique_id,omitempty" required:"false" doc:""`
	Username          string    `json:"username,omitempty" yaml:"username,omitempty" required:"false" doc:""`
}

// ViewListSeamlessPeersItem represents a nested type for View extra method response
type ViewListSeamlessPeersItem struct {
	FailureReason  string `json:"failure_reason,omitempty" yaml:"failure_reason,omitempty" required:"false" doc:"Reason of failure during getting seamless info from the remote"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Name of seamless replication peer"`
	RemotePeerName string `json:"remote_peer_name,omitempty" yaml:"remote_peer_name,omitempty" required:"false" doc:"Remote peer name"`
	Status         string `json:"status,omitempty" yaml:"status,omitempty" required:"false" doc:"The seamless status of the remote peer."`
	TenantGuid     string `json:"tenant_guid,omitempty" yaml:"tenant_guid,omitempty" required:"false" doc:"Globally unique identifier for the remote tenant"`
	TenantName     string `json:"tenant_name,omitempty" yaml:"tenant_name,omitempty" required:"false" doc:"Remote tenant name"`
	ViewName       string `json:"view_name,omitempty" yaml:"view_name,omitempty" required:"false" doc:"Remote view name"`
	ViewPath       string `json:"view_path,omitempty" yaml:"view_path,omitempty" required:"false" doc:"Remote view path"`
}

// ViewCheckPermissionsTemplates_POST_Body represents the request body for ViewCheckPermissionsTemplates
type ViewCheckPermissionsTemplates_POST_Body struct {
	TargetPath       string `json:"target_path,omitempty" yaml:"target_path,omitempty" required:"true" doc:"Target dir path"`
	TemplateDirPath  string `json:"template_dir_path,omitempty" yaml:"template_dir_path,omitempty" required:"true" doc:"Template dir path"`
	TemplateViewId   int64  `json:"template_view_id,omitempty" yaml:"template_view_id,omitempty" required:"true" doc:"Template view ID"`
	TemplateFilePath string `json:"template_file_path,omitempty" yaml:"template_file_path,omitempty" required:"false" doc:"Template file path"`
}

// ViewCheckPermissionsTemplates_POST_Model represents the response model for ViewCheckPermissionsTemplates
type ViewCheckPermissionsTemplates_POST_Model struct {
	TemplateDirPath  ViewCheckPermissionsTemplatesModel_TemplateDirPath  `json:"template_dir_path,omitempty" yaml:"template_dir_path,omitempty" required:"false" doc:""`
	TemplateFilePath ViewCheckPermissionsTemplatesModel_TemplateFilePath `json:"template_file_path,omitempty" yaml:"template_file_path,omitempty" required:"false" doc:""`
}

// ViewCheckPermissionsTemplatesWithContext_POST
// method: POST
// url: /views/{id}/check_permissions_templates/
// summary: Check Permissions Templates Before Bulk Permission Update
func (r *View) ViewCheckPermissionsTemplatesWithContext_POST(ctx context.Context, id any, body *ViewCheckPermissionsTemplates_POST_Body) (*ViewCheckPermissionsTemplates_POST_Model, error) {
	resourcePath := core.BuildResourcePathWithID("views", id, "check_permissions_templates")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ViewCheckPermissionsTemplates_POST_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ViewCheckPermissionsTemplates_POST
// method: POST
// url: /views/{id}/check_permissions_templates/
// summary: Check Permissions Templates Before Bulk Permission Update
func (r *View) ViewCheckPermissionsTemplates_POST(id any, body *ViewCheckPermissionsTemplates_POST_Body) (*ViewCheckPermissionsTemplates_POST_Model, error) {
	return r.ViewCheckPermissionsTemplatesWithContext_POST(r.Untyped.GetCtx(), id, body)
}

// ViewCloseSmbHandle_DELETE_Model represents the response model for ViewCloseSmbHandle
type ViewCloseSmbHandle_DELETE_Model struct {
	Error               string                                             `json:"error,omitempty" yaml:"error,omitempty" required:"false" doc:""`
	FileHandle          ViewCloseSmbHandleModel_FileHandle                 `json:"file_handle,omitempty" yaml:"file_handle,omitempty" required:"false" doc:""`
	OpenProtocolHandles *[]ViewCloseSmbHandleModel_OpenProtocolHandlesItem `json:"open_protocol_handles,omitempty" yaml:"open_protocol_handles,omitempty" required:"false" doc:""`
}

// ViewCloseSmbHandleWithContext_DELETE
// method: DELETE
// url: /views/close_smb_handle/
// summary: Close open SMB filehandles
func (r *View) ViewCloseSmbHandleWithContext_DELETE(ctx context.Context) (*ViewCloseSmbHandle_DELETE_Model, error) {
	resourcePath := "/views/close_smb_handle/"

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ViewCloseSmbHandle_DELETE_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ViewCloseSmbHandle_DELETE
// method: DELETE
// url: /views/close_smb_handle/
// summary: Close open SMB filehandles
func (r *View) ViewCloseSmbHandle_DELETE() (*ViewCloseSmbHandle_DELETE_Model, error) {
	return r.ViewCloseSmbHandleWithContext_DELETE(r.Untyped.GetCtx())
}

// ViewLegalHold_GET_Body represents the request body for ViewLegalHold
type ViewLegalHold_GET_Body struct {
	LegalHoldPath string `json:"legal_hold_path,omitempty" yaml:"legal_hold_path,omitempty" required:"false" doc:"Path to get legal hold"`
}

// ViewLegalHold_GET_Model represents the response model for ViewLegalHold
type ViewLegalHold_GET_Model struct {
	Value string `json:"value,omitempty" yaml:"value,omitempty" required:"false" doc:"Legal hold value"`
}

// ViewLegalHoldWithContext_GET
// method: GET
// url: /views/{id}/legal_hold/
// summary: Get legal hold
func (r *View) ViewLegalHoldWithContext_GET(ctx context.Context, id any, params *ViewLegalHold_GET_Body) (*ViewLegalHold_GET_Model, error) {
	resourcePath := core.BuildResourcePathWithID("views", id, "legal_hold")

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ViewLegalHold_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ViewLegalHold_GET
// method: GET
// url: /views/{id}/legal_hold/
// summary: Get legal hold
func (r *View) ViewLegalHold_GET(id any, params *ViewLegalHold_GET_Body) (*ViewLegalHold_GET_Model, error) {
	return r.ViewLegalHoldWithContext_GET(r.Untyped.GetCtx(), id, params)
}

// ViewListOpenSmbHandles_GET_Body represents the request body for ViewListOpenSmbHandles
type ViewListOpenSmbHandles_GET_Body struct {
	FilePath   string `json:"file_path,omitempty" yaml:"file_path,omitempty" required:"false" doc:"File path"`
	TenantGuid string `json:"tenant_guid,omitempty" yaml:"tenant_guid,omitempty" required:"false" doc:"Tenant GUID"`
}

// ViewListOpenSmbHandles_GET_Model represents the response model for ViewListOpenSmbHandles
type ViewListOpenSmbHandles_GET_Model struct {
	Error               string                                                 `json:"error,omitempty" yaml:"error,omitempty" required:"false" doc:""`
	FileHandle          ViewListOpenSmbHandlesModel_FileHandle                 `json:"file_handle,omitempty" yaml:"file_handle,omitempty" required:"false" doc:""`
	OpenProtocolHandles *[]ViewListOpenSmbHandlesModel_OpenProtocolHandlesItem `json:"open_protocol_handles,omitempty" yaml:"open_protocol_handles,omitempty" required:"false" doc:""`
}

// ViewListOpenSmbHandlesWithContext_GET
// method: GET
// url: /views/list_open_smb_handles/
// summary: Query open SMB filehandles
func (r *View) ViewListOpenSmbHandlesWithContext_GET(ctx context.Context, params *ViewListOpenSmbHandles_GET_Body) (*ViewListOpenSmbHandles_GET_Model, error) {
	resourcePath := "/views/list_open_smb_handles/"

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ViewListOpenSmbHandles_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ViewListOpenSmbHandles_GET
// method: GET
// url: /views/list_open_smb_handles/
// summary: Query open SMB filehandles
func (r *View) ViewListOpenSmbHandles_GET(params *ViewListOpenSmbHandles_GET_Body) (*ViewListOpenSmbHandles_GET_Model, error) {
	return r.ViewListOpenSmbHandlesWithContext_GET(r.Untyped.GetCtx(), params)
}

// ViewListSeamlessPeers_GET_Body represents the request body for ViewListSeamlessPeers
type ViewListSeamlessPeers_GET_Body struct {
	FilePath   string `json:"file_path,omitempty" yaml:"file_path,omitempty" required:"false" doc:"File path"`
	TenantGuid string `json:"tenant_guid,omitempty" yaml:"tenant_guid,omitempty" required:"false" doc:"Tenant's globally unique identifier"`
}

// ViewListSeamlessPeersWithContext_GET
// method: GET
// url: /views/list_seamless_peers/
// summary: Get a list of available seamless peers
func (r *View) ViewListSeamlessPeersWithContext_GET(ctx context.Context, params *ViewListSeamlessPeers_GET_Body) ([]ViewListSeamlessPeersItem, error) {
	resourcePath := "/views/list_seamless_peers/"

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.RecordSet](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}
	// Convert RecordSet ([]core.Record) to typed array ([]ViewListSeamlessPeersItem)
	result := make([]ViewListSeamlessPeersItem, len(record))
	for i, item := range record {
		if err := item.Fill(&result[i]); err != nil {
			return nil, fmt.Errorf("failed to unmarshal array item %d: %w", i, err)
		}
	}
	return result, nil

}

// ViewListSeamlessPeers_GET
// method: GET
// url: /views/list_seamless_peers/
// summary: Get a list of available seamless peers
func (r *View) ViewListSeamlessPeers_GET(params *ViewListSeamlessPeers_GET_Body) ([]ViewListSeamlessPeersItem, error) {
	return r.ViewListSeamlessPeersWithContext_GET(r.Untyped.GetCtx(), params)
}

// ViewPermissionsRepairWithContext_DELETE
// method: DELETE
// url: /views/{id}/permissions_repair/
// summary: Stop Bulk Permission Update
func (r *View) ViewPermissionsRepairWithContext_DELETE(ctx context.Context, id any) error {
	resourcePath := core.BuildResourcePathWithID("views", id, "permissions_repair")

	var reqParams core.Params
	var reqBody core.Params

	_, err := core.Request[core.EmptyRecord](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// ViewPermissionsRepair_DELETE
// method: DELETE
// url: /views/{id}/permissions_repair/
// summary: Stop Bulk Permission Update
func (r *View) ViewPermissionsRepair_DELETE(id any) error {
	return r.ViewPermissionsRepairWithContext_DELETE(r.Untyped.GetCtx(), id)
}

// ViewPermissionsRepair_POST_Body represents the request body for ViewPermissionsRepair
type ViewPermissionsRepair_POST_Body struct {
	TargetPath       string `json:"target_path,omitempty" yaml:"target_path,omitempty" required:"true" doc:"Path to the directory where the files and directories that you want to update permissions for reside."`
	TemplateDirPath  string `json:"template_dir_path,omitempty" yaml:"template_dir_path,omitempty" required:"true" doc:"Path to the directory to retrieve permissions from and apply to the target path."`
	TemplateViewId   int64  `json:"template_view_id,omitempty" yaml:"template_view_id,omitempty" required:"true" doc:"The ID of a view that exposes template_dir_path. The view must be on the same tenant as the target path."`
	TemplateFilePath string `json:"template_file_path,omitempty" yaml:"template_file_path,omitempty" required:"false" doc:"Path to a file under template_dir_path that you want to use as a template for file permissions. If specified, permissions of target files are overwritten with those of the template file and permissions of target directories are overwritten with those of the template directory. If not specified, permissions and ownership attributes of the target directory are overwritten with those of the template directory, and nested directories and files inherit permissions and ownership attributes from their parent. In this case, the template directory must have a default ACL."`
}

// ViewPermissionsRepairWithContext_POST
// method: POST
// url: /views/{id}/permissions_repair/
// summary: Start Bulk Permission Update
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *View) ViewPermissionsRepairWithContext_POST(ctx context.Context, id any, body *ViewPermissionsRepair_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("views", id, "permissions_repair")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}
	// Create async task from result
	task := untyped.NewAsyncResult(ctx, result.RecordID(), r.Untyped)
	// If waitTimeout is 0, return task immediately without waiting (async background operation)
	if waitTimeout == 0 {
		return task, nil
	}
	// Wait for task completion with the specified timeout
	if _, err := task.Wait(waitTimeout); err != nil {
		return task, err
	}
	return task, nil

}

// ViewPermissionsRepair_POST
// method: POST
// url: /views/{id}/permissions_repair/
// summary: Start Bulk Permission Update
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *View) ViewPermissionsRepair_POST(id any, body *ViewPermissionsRepair_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ViewPermissionsRepairWithContext_POST(r.Untyped.GetCtx(), id, body, waitTimeout)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - Extra method PATCH /views/{id}/legal_hold/ skipped: PATCH /views/{id}/legal_hold/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /views/{id}/legal_hold/
//   - UPDATE operation excluded: PATCH/PUT /views/{id}/ has no response schema and doesn't return 204 NO CONTENT
