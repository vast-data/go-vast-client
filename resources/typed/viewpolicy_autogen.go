// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|DELETE

package typed

import (
	"context"
	"net/http"

	"github.com/vast-data/go-vast-client/core"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// ViewPolicy represents a typed resource for viewpolicy operations
type ViewPolicy struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// ViewPolicySearchParams represents the search parameters for ViewPolicy operations
type ViewPolicySearchParams struct {
	AppleSid                 bool   `json:"apple_sid,omitempty" yaml:"apple_sid,omitempty" required:"false" doc:"apple sid"`
	AtimeFrequency           string `json:"atime_frequency,omitempty" yaml:"atime_frequency,omitempty" required:"false" doc:"Filter by atime frequency."`
	Guid                     string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:"Globally unique identifier"`
	Name                     string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Filter by name."`
	NfsReturnOpenPermissions bool   `json:"nfs_return_open_permissions,omitempty" yaml:"nfs_return_open_permissions,omitempty" required:"false" doc:"Filter by enabled nfs-return-open-permissions flag"`
	ServesTenant             string `json:"serves_tenant,omitempty" yaml:"serves_tenant,omitempty" required:"false" doc:"Filter by served tenants. Accepts tenant ID or \"all\" for all served tenants."`
	SmbDirectoryMode         int64  `json:"smb_directory_mode,omitempty" yaml:"smb_directory_mode,omitempty" required:"false" doc:"Filter by smb_directory_mode. smb_directory_mode is the default unix permission bits applied to directories created by SMB clients. It is relevant only to views that are exposed to both SMB and NFS access protocols and have NFS security flavor."`
	SmbFileMode              int64  `json:"smb_file_mode,omitempty" yaml:"smb_file_mode,omitempty" required:"false" doc:"Filter by smb_file_mode. smb_file_mode is the default unix permission bits applied to files created by SMB clients. It is relevant only to views that are exposed to both SMB and NFS access protocols and have NFS security flavor."`
	TenantId                 int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Filter by tenant. Specify tenant ID."`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &ViewPolicySearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// ViewPolicyRequestBody represents the request body for ViewPolicy operations
type ViewPolicyRequestBody struct {
	Name                               string            `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:""`
	AccessFlavor                       string            `json:"access_flavor,omitempty" yaml:"access_flavor,omitempty" required:"false" doc:"Applicable with MIXED_LAST_WINS security flavor (Access can be set via NFSv3 regardless of this option)"`
	AllowedCharacters                  string            `json:"allowed_characters,omitempty" yaml:"allowed_characters,omitempty" required:"false" doc:"Specifies the policy for which characters are allowed in file names."`
	AppleSid                           bool              `json:"apple_sid,omitempty" yaml:"apple_sid,omitempty" required:"false" doc:"For use when connecting from Mac clients to SMB shares, this option enables Security IDs (SIDs) to be returned in Apple compatible representation."`
	AtimeFrequency                     string            `json:"atime_frequency,omitempty" yaml:"atime_frequency,omitempty" required:"false" doc:"Frequency for updating the atime attribute of NFS files. atime is updated on read operations if the difference between the current time and the file's atime value is greater than the atime frequency. For example: 300 or 00:00:30 seconds is supported. Zero value is not supported. Default: 3600"`
	AuthSource                         string            `json:"auth_source,omitempty" yaml:"auth_source,omitempty" required:"false" doc:"Specifies which source is trusted for the user's group memberships, when users' access to the view is authorized."`
	ClusterId                          int64             `json:"cluster_id,omitempty" yaml:"cluster_id,omitempty" required:"false" doc:""`
	DisableHandleLease                 bool              `json:"disable_handle_lease,omitempty" yaml:"disable_handle_lease,omitempty" required:"false" doc:""`
	DisableReadLease                   bool              `json:"disable_read_lease,omitempty" yaml:"disable_read_lease,omitempty" required:"false" doc:""`
	DisableWriteLease                  bool              `json:"disable_write_lease,omitempty" yaml:"disable_write_lease,omitempty" required:"false" doc:""`
	EnableAccessToSnapshotDirInSubdirs bool              `json:"enable_access_to_snapshot_dir_in_subdirs,omitempty" yaml:"enable_access_to_snapshot_dir_in_subdirs,omitempty" required:"false" doc:"Specifies whether to make the .snapshot directory accessible in subdirectories of the View."`
	EnableVisibilityOfSnapshotDir      bool              `json:"enable_visibility_of_snapshot_dir,omitempty" yaml:"enable_visibility_of_snapshot_dir,omitempty" required:"false" doc:"Specifies whether to make the .snapshot directory visible in subdirectories of the View."`
	ExposeIdInFsid                     bool              `json:"expose_id_in_fsid,omitempty" yaml:"expose_id_in_fsid,omitempty" required:"false" doc:""`
	Flavor                             string            `json:"flavor,omitempty" yaml:"flavor,omitempty" required:"false" doc:"Specifies the security flavor, which determines how file and directory permissions are applied in multiprotocol views."`
	GidInheritance                     string            `json:"gid_inheritance,omitempty" yaml:"gid_inheritance,omitempty" required:"false" doc:"Specifies how files receive their owning group when they are created."`
	InheritParentModeBits              bool              `json:"inherit_parent_mode_bits,omitempty" yaml:"inherit_parent_mode_bits,omitempty" required:"false" doc:"Enable NFS behavior of inheriting POSIX settings from the parent directory versus configured values."`
	IsS3DefaultPolicy                  bool              `json:"is_s3_default_policy,omitempty" yaml:"is_s3_default_policy,omitempty" required:"false" doc:"Specifies whether to make the view policy the default policy used for S3 endpoint views."`
	NfsAllSquash                       *[]string         `json:"nfs_all_squash,omitempty" yaml:"nfs_all_squash,omitempty" required:"false" doc:"Specify which NFS client hosts have all squash. With all squash, all client users are mapped to nobody for all file and folder management operations on the export. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	NfsCaseInsensitive                 bool              `json:"nfs_case_insensitive,omitempty" yaml:"nfs_case_insensitive,omitempty" required:"false" doc:"Force case insensitivity for NFSv3 and NFSv4"`
	NfsEnforceTls                      bool              `json:"nfs_enforce_tls,omitempty" yaml:"nfs_enforce_tls,omitempty" required:"false" doc:"Accept NFSv3 and NFSv4 client mounts only if they are TLS-encrypted. Use only with Minimal Protection Level set to System or None."`
	NfsEnforceTlsRelaxed               bool              `json:"nfs_enforce_tls_relaxed,omitempty" yaml:"nfs_enforce_tls_relaxed,omitempty" required:"false" doc:"Whether to relax TLS enforcement by not requiring TLS for auxiliary NFSv3 sub-protocols | (MOUNT, NLM, NSM, RQUOTA, NFSACL)"`
	NfsMinimalProtectionLevel          string            `json:"nfs_minimal_protection_level,omitempty" yaml:"nfs_minimal_protection_level,omitempty" required:"false" doc:"For a policy intended for use with NFSv4-enabled views, sets the Minimal Protection Level for NFSv4 client mounts: 'KRB_AUTH_ONLY' allows client mounts with Kerberos authentication only (using the RPCSEC_GSS authentication service), 'SYSTEM' allows client mounts using either the AUTH_SYS RCP security flavor (the traditional default NFS authentication scheme) or with Kerberos authentication, 'NONE' (default) allows client mounts with the AUTH_NONE (anonymous access), or AUTH_SYS RCP security flavors, or with Kerberos authentication."`
	NfsNoSquash                        *[]string         `json:"nfs_no_squash,omitempty" yaml:"nfs_no_squash,omitempty" required:"false" doc:"Specify which NFS client hosts have no squash. With no squash, all operations are supported. Use this option if you trust the root user not to perform operations that will corrupt data. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	NfsPosixAcl                        bool              `json:"nfs_posix_acl,omitempty" yaml:"nfs_posix_acl,omitempty" required:"false" doc:"Enables full support of extended POSIX Access Control Lists (ACL)."`
	NfsReadOnly                        *[]string         `json:"nfs_read_only,omitempty" yaml:"nfs_read_only,omitempty" required:"false" doc:"Specify which NFS client hosts can access the view with read-only access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	NfsReadWrite                       *[]string         `json:"nfs_read_write,omitempty" yaml:"nfs_read_write,omitempty" required:"false" doc:"Specify which NFS client hosts can access the view with read-write access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	NfsReturnOpenPermissions           bool              `json:"nfs_return_open_permissions,omitempty" yaml:"nfs_return_open_permissions,omitempty" required:"false" doc:"If enabled for NFS-exposed views, the NFS server unilaterally returns open (777) permission for all files and directories when responding to client side access checks."`
	NfsRootSquash                      *[]string         `json:"nfs_root_squash,omitempty" yaml:"nfs_root_squash,omitempty" required:"false" doc:"Specify which NFS client hosts have root squash. With root squash, the root user is mapped to nobody for all file and folder management operations on the export. This enables you to prevent the strongest super user from corrupting all user data on the VAST Cluster. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	PathLength                         string            `json:"path_length,omitempty" yaml:"path_length,omitempty" required:"false" doc:"Specifies the policy for limiting file path component name length."`
	PermissionPerVipPool               map[string]string `json:"permission_per_vip_pool,omitempty" yaml:"permission_per_vip_pool,omitempty" required:"false" doc:"VIP pools permissions map - {vippool_id: permission}. Example - {1: 'RW'}."`
	Protocols                          *[]string         `json:"protocols,omitempty" yaml:"protocols,omitempty" required:"false" doc:"Array of protocols to audit"`
	ReadOnly                           *[]string         `json:"read_only,omitempty" yaml:"read_only,omitempty" required:"false" doc:"Specify which NFS client hosts can access the view with read-only access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	ReadWrite                          *[]string         `json:"read_write,omitempty" yaml:"read_write,omitempty" required:"false" doc:"Specify which NFS client hosts can access the view with read-write access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	S3FlavorAllowFreeListing           bool              `json:"s3_flavor_allow_free_listing,omitempty" yaml:"s3_flavor_allow_free_listing,omitempty" required:"false" doc:"Allow NFS clients freely list bucket views and their subdirectories, regardless of individual object permissions."`
	S3FlavorDetectFullPathname         bool              `json:"s3_flavor_detect_full_pathname,omitempty" yaml:"s3_flavor_detect_full_pathname,omitempty" required:"false" doc:"When this flag is enabled in S3 flavor, NFS access to objects is determined based on the full resource names specified in the identity policies. When disabled, only the bucket name is compared to the identity policy."`
	S3ReadOnly                         *[]string         `json:"s3_read_only,omitempty" yaml:"s3_read_only,omitempty" required:"false" doc:"Specify which S3 client hosts can access the view with read-only access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	S3ReadWrite                        *[]string         `json:"s3_read_write,omitempty" yaml:"s3_read_write,omitempty" required:"false" doc:"Specify which S3 client hosts can access the view with read-write access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	S3SpecialCharsSupport              bool              `json:"s3_special_chars_support,omitempty" yaml:"s3_special_chars_support,omitempty" required:"false" doc:"This will enable object names that contain “//“ or “/../“ and are incompatible with other protocols"`
	S3Visibility                       *[]string         `json:"s3_visibility,omitempty" yaml:"s3_visibility,omitempty" required:"false" doc:"Users with permission to list buckets that are created using this policy even if they do not have permission to access those buckets."`
	S3VisibilityGroups                 *[]string         `json:"s3_visibility_groups,omitempty" yaml:"s3_visibility_groups,omitempty" required:"false" doc:"Users with permission to list buckets that are created using this policy even if they do not have permission to access those buckets."`
	SmbDirectoryMode                   int64             `json:"smb_directory_mode,omitempty" yaml:"smb_directory_mode,omitempty" required:"false" doc:"For multiprotocol views, if the security flavor is NFS, this parameter sets default unix permission bits for directories created by SMB clients. Use three digit numeric notation, each digit representing the user, group and others compontents of the permissions, in that order. Each digit is the sum of the read bit, write bit and execute bit. If reading is permitted, the read bit adds 4 to the component. If writing is permitted, the write bit adds 2 to the component. If execution is permitted, the execute bit adds 1 to the component."`
	SmbFileMode                        int64             `json:"smb_file_mode,omitempty" yaml:"smb_file_mode,omitempty" required:"false" doc:"For multiprotocol views, if the security flavor is NFS, this parameter sets default unix permission bits for files created by SMB clients. Use three digit numeric notation, each digit representing the user, group and others compontents of the permissions, in that order. Each digit is the sum of the read bit, write bit and execute bit. If reading is permitted, the read bit adds 4 to the component. If writing is permitted, the write bit adds 2 to the component. If execution is permitted, the execute bit adds 1 to the component."`
	SmbIsCa                            bool              `json:"smb_is_ca,omitempty" yaml:"smb_is_ca,omitempty" required:"false" doc:"When enabled, the SMB share exposed by the view is set as continuously available, which allows SMB3 clients to request use of persistent file handles and keep their connections to this share in case of a failover event."`
	SmbReadOnly                        *[]string         `json:"smb_read_only,omitempty" yaml:"smb_read_only,omitempty" required:"false" doc:"Specify which SMB client hosts can access the view with read-only access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	SmbReadWrite                       *[]string         `json:"smb_read_write,omitempty" yaml:"smb_read_write,omitempty" required:"false" doc:"Specify which SMB client hosts can access the view with read-write access. Specify array of hosts separated by commas. Each host can be specified as an IP address, a netgroup key beginning with @, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address."`
	TenantId                           int64             `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Tenant ID"`
	TrashAccess                        *[]string         `json:"trash_access,omitempty" yaml:"trash_access,omitempty" required:"false" doc:"Specify which NFS client hosts can access the trash folder. Specify array of hosts separated by commas. Each host can be specified as an IP address, a CIDR subnet or a range of IPs indicated by an IP address with a * as a wildcard in place of any of the 8-bit fields in the IP address. Trash folder access must also be enabled for the cluster."`
	Use32bitFileid                     bool              `json:"use_32bit_fileid,omitempty" yaml:"use_32bit_fileid,omitempty" required:"false" doc:"Sets the VAST Cluster's NFS server to use 32bit file IDs. This setting supports legacy 32-bit applications running over NFS."`
	UseAuthProvider                    bool              `json:"use_auth_provider,omitempty" yaml:"use_auth_provider,omitempty" required:"false" doc:"Not in use"`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// ViewPolicyDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/ViewPolicy
type ViewPolicyDetailsModel = Component_ViewPolicy

// ViewPolicyUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/ViewPolicy
type ViewPolicyUpsertModel = Component_ViewPolicy

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple viewpolicys with typed request/response
// summary: List View Policies
func (r *ViewPolicy) List(req *ViewPolicySearchParams) ([]*ViewPolicyDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple viewpolicys with typed request/response using provided context
// summary: List View Policies
func (r *ViewPolicy) ListWithContext(ctx context.Context, req *ViewPolicySearchParams) ([]*ViewPolicyDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*ViewPolicyDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single viewpolicy with typed request/response
// summary: List View Policies
func (r *ViewPolicy) Get(req *ViewPolicySearchParams) (*ViewPolicyDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single viewpolicy with typed request/response using provided context
// summary: List View Policies
func (r *ViewPolicy) GetWithContext(ctx context.Context, req *ViewPolicySearchParams) (*ViewPolicyDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ViewPolicyDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single viewpolicy by ID
// summary: Return Details of a View Policy
func (r *ViewPolicy) GetById(id any) (*ViewPolicyDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single viewpolicy by ID using provided context
// summary: Return Details of a View Policy
func (r *ViewPolicy) GetByIdWithContext(ctx context.Context, id any) (*ViewPolicyDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response ViewPolicyDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new viewpolicy with typed request/response
// summary: Create View Policy
func (r *ViewPolicy) Create(req *ViewPolicyRequestBody) (*ViewPolicyUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new viewpolicy with typed request/response using provided context
// summary: Create View Policy
func (r *ViewPolicy) CreateWithContext(ctx context.Context, req *ViewPolicyRequestBody) (*ViewPolicyUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ViewPolicyUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a viewpolicy with search parameters
func (r *ViewPolicy) Delete(req *ViewPolicySearchParams) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req)
}

// DeleteWithContext deletes a viewpolicy with search parameters using provided context
func (r *ViewPolicy) DeleteWithContext(ctx context.Context, req *ViewPolicySearchParams) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a viewpolicy by ID
// summary: Delete View Policy
//
// Parameters:
//   - id: The ID of the view policy to delete
func (r *ViewPolicy) DeleteById(id any) error {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id)
}

// DeleteByIdWithContext deletes a viewpolicy by ID using provided context
// summary: Delete View Policy
//
// Parameters:
//   - id: The ID of the view policy to delete
func (r *ViewPolicy) DeleteByIdWithContext(ctx context.Context, id any) error {
	_, err := r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteByIdWithContext(ctx, id, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a viewpolicy exists with typed response
func (r *ViewPolicy) Ensure(searchParams *ViewPolicySearchParams, body *ViewPolicyRequestBody) (*ViewPolicyUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a viewpolicy exists with typed response using provided context
func (r *ViewPolicy) EnsureWithContext(ctx context.Context, searchParams *ViewPolicySearchParams, body *ViewPolicyRequestBody) (*ViewPolicyUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response ViewPolicyUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a viewpolicy exists
func (r *ViewPolicy) Exists(req *ViewPolicySearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a viewpolicy exists using provided context
func (r *ViewPolicy) ExistsWithContext(ctx context.Context, req *ViewPolicySearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a viewpolicy exists and panics if not
func (r *ViewPolicy) MustExists(req *ViewPolicySearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a viewpolicy exists and panics if not using provided context
func (r *ViewPolicy) MustExistsWithContext(ctx context.Context, req *ViewPolicySearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// ViewPolicyRefreshNetgroupsWithContext_PATCH
// method: PATCH
// url: /viewpolicies/{id}/refresh_netgroups/
// summary: refresh View policy netgroups
func (r *ViewPolicy) ViewPolicyRefreshNetgroupsWithContext_PATCH(ctx context.Context, id any) error {
	resourcePath := core.BuildResourcePathWithID("viewpolicies", id, "refresh_netgroups")

	var reqParams core.Params
	var reqBody core.Params

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	return err

}

// ViewPolicyRefreshNetgroups_PATCH
// method: PATCH
// url: /viewpolicies/{id}/refresh_netgroups/
// summary: refresh View policy netgroups
func (r *ViewPolicy) ViewPolicyRefreshNetgroups_PATCH(id any) error {
	return r.ViewPolicyRefreshNetgroupsWithContext_PATCH(r.Untyped.GetCtx(), id)
}

// ViewPolicyRemoteMappingWithContext_DELETE
// method: DELETE
// url: /viewpolicies/{id}/remote_mapping/
//
// Parameters:
//   - peer (body): Peer name
func (r *ViewPolicy) ViewPolicyRemoteMappingWithContext_DELETE(ctx context.Context, id any, peer string) error {
	resourcePath := core.BuildResourcePathWithID("viewpolicies", id, "remote_mapping")

	var reqParams core.Params
	reqBody := core.Params{}
	if peer != "" {
		reqBody["peer"] = peer
	}

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// ViewPolicyRemoteMapping_DELETE
// method: DELETE
// url: /viewpolicies/{id}/remote_mapping/
//
// Parameters:
//   - peer (body): Peer name
func (r *ViewPolicy) ViewPolicyRemoteMapping_DELETE(id any, peer string) error {
	return r.ViewPolicyRemoteMappingWithContext_DELETE(r.Untyped.GetCtx(), id, peer)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - Extra method POST /viewpolicies/{id}/remote_mapping/ skipped: POST /viewpolicies/{id}/remote_mapping/ - No response schema defined in OpenAPI spec. Error: no valid schema found in POST response (200/201/202/204) for resource /viewpolicies/{id}/remote_mapping/
//   - UPDATE operation excluded: PATCH/PUT /viewpolicies/{id}/ has no response schema and doesn't return 204 NO CONTENT
