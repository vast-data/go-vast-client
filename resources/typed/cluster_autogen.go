// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|UPDATE|DELETE

package typed

import (
	"context"
	"net/http"
	"time"

	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/resources/untyped"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// Cluster represents a typed resource for cluster operations
type Cluster struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// ClusterSearchParams represents the search parameters for Cluster operations
type ClusterSearchParams struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:"Name"`
	Guid string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:"globally unique identifier"`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &ClusterSearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// ClusterRequestBody_RackPoolsValue represents a nested type for request body
type ClusterRequestBody_RackPoolsValue struct {
	CnodeIpPool   *[]string `json:"cnode_ip_pool,omitempty" yaml:"cnode_ip_pool,omitempty" required:"false" doc:""`
	CnodeIpmiPool *[]string `json:"cnode_ipmi_pool,omitempty" yaml:"cnode_ipmi_pool,omitempty" required:"false" doc:""`
	DnodeIpPool   *[]string `json:"dnode_ip_pool,omitempty" yaml:"dnode_ip_pool,omitempty" required:"false" doc:""`
	DnodeIpmiPool *[]string `json:"dnode_ipmi_pool,omitempty" yaml:"dnode_ipmi_pool,omitempty" required:"false" doc:""`
}

// ClusterRequestBody represents the request body for Cluster operations
type ClusterRequestBody struct {
	Name                                           string                                       `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:"Cluster name"`
	AuditDirName                                   string                                       `json:"audit_dir_name,omitempty" yaml:"audit_dir_name,omitempty" required:"false" doc:"Audit directory name, located under root directory. Protocol audit logs are saved to this directory."`
	AutoDriveFwUpgrade                             bool                                         `json:"auto_drive_fw_upgrade,omitempty" yaml:"auto_drive_fw_upgrade,omitempty" required:"false" doc:"Enable/disable auto drives FW upgrade"`
	BmcUpgrade                                     bool                                         `json:"bmc_upgrade,omitempty" yaml:"bmc_upgrade,omitempty" required:"false" doc:"BMC upgrade"`
	Build                                          string                                       `json:"build,omitempty" yaml:"build,omitempty" required:"false" doc:"The build to be installed on the cluster"`
	CloudLb                                        bool                                         `json:"cloud_lb,omitempty" yaml:"cloud_lb,omitempty" required:"false" doc:"vast on cloud installation flag (default is False)"`
	ClusterGuid                                    string                                       `json:"cluster_guid,omitempty" yaml:"cluster_guid,omitempty" required:"false" doc:"Guid of the system"`
	CnodeCores                                     int64                                        `json:"cnode_cores,omitempty" yaml:"cnode_cores,omitempty" required:"false" doc:"Number of cnode cores"`
	CnodeIps                                       *[]string                                    `json:"cnode_ips,omitempty" yaml:"cnode_ips,omitempty" required:"false" doc:"The list of cnode ips, optional"`
	CnodeIpv6Pool                                  *[]string                                    `json:"cnode_ipv6_pool,omitempty" yaml:"cnode_ipv6_pool,omitempty" required:"false" doc:"The list of cnode ipv6 addresses, optional"`
	DboxHaSupport                                  bool                                         `json:"dbox_ha_support,omitempty" yaml:"dbox_ha_support,omitempty" required:"false" doc:"DBox HA support"`
	DeepStripe                                     bool                                         `json:"deep_stripe,omitempty" yaml:"deep_stripe,omitempty" required:"false" doc:"Is deep stripe system"`
	DefaultOthersShareLevelPerm                    string                                       `json:"default_others_share_level_perm,omitempty" yaml:"default_others_share_level_perm,omitempty" required:"false" doc:"Default Share level permissions for Others. (deprecated since 4.6)"`
	DefragThreshold                                int64                                        `json:"defrag_threshold,omitempty" yaml:"defrag_threshold,omitempty" required:"false" doc:"Defrag Threshold"`
	DeleteSnapBlocksThreshold                      int64                                        `json:"delete_snap_blocks_threshold,omitempty" yaml:"delete_snap_blocks_threshold,omitempty" required:"false" doc:"Threshold limiting the number of content blocks handled in a single execution of a delete-snap fiber"`
	DenyCnodeSystemAccess                          bool                                         `json:"deny_cnode_system_access,omitempty" yaml:"deny_cnode_system_access,omitempty" required:"false" doc:"Flag for disabling cnode access to the system, default: False"`
	DisableDboxesSlots                             *[]string                                    `json:"disable_dboxes_slots,omitempty" yaml:"disable_dboxes_slots,omitempty" required:"false" doc:"List of dboxes slots to disable, optional"`
	DisableDefaultMicroShards                      bool                                         `json:"disable_default_micro_shards,omitempty" yaml:"disable_default_micro_shards,omitempty" required:"false" doc:"Set the micro shards values to equal the mega shards values"`
	DisableDirsnap                                 bool                                         `json:"disable_dirsnap,omitempty" yaml:"disable_dirsnap,omitempty" required:"false" doc:"Disable directory snapshots"`
	DisableMetrics                                 bool                                         `json:"disable_metrics,omitempty" yaml:"disable_metrics,omitempty" required:"false" doc:"Disable internal metrics collection"`
	DisableMgmtHa                                  bool                                         `json:"disable_mgmt_ha,omitempty" yaml:"disable_mgmt_ha,omitempty" required:"false" doc:"Disable management HA"`
	DisableRestrictUser                            bool                                         `json:"disable_restrict_user,omitempty" yaml:"disable_restrict_user,omitempty" required:"false" doc:"Ignore user restriction on raider clusters"`
	Dmsetup                                        bool                                         `json:"dmsetup,omitempty" yaml:"dmsetup,omitempty" required:"false" doc:"Mock NVMeoF devices with dmsetup devices"`
	DnodeIps                                       *[]string                                    `json:"dnode_ips,omitempty" yaml:"dnode_ips,omitempty" required:"false" doc:"The list of D-Boxes"`
	DnodeIpv6Pool                                  *[]string                                    `json:"dnode_ipv6_pool,omitempty" yaml:"dnode_ipv6_pool,omitempty" required:"false" doc:"The list of dnode ipv6 addresses, optional"`
	DoubleValueMicroShards                         bool                                         `json:"double_value_micro_shards,omitempty" yaml:"double_value_micro_shards,omitempty" required:"false" doc:"Set the micro shards values to double the mega shards values"`
	DrHashSize                                     int64                                        `json:"dr_hash_size,omitempty" yaml:"dr_hash_size,omitempty" required:"false" doc:"DR hash size in buckets"`
	DrShards                                       int64                                        `json:"dr_shards,omitempty" yaml:"dr_shards,omitempty" required:"false" doc:"Number of DR shards"`
	DrWbShards                                     int64                                        `json:"dr_wb_shards,omitempty" yaml:"dr_wb_shards,omitempty" required:"false" doc:"Number of DR write buffer shards"`
	DriveSize                                      int64                                        `json:"drive_size,omitempty" yaml:"drive_size,omitempty" required:"false" doc:"Drive size for mocked devices"`
	EkmAddress                                     string                                       `json:"ekm_address,omitempty" yaml:"ekm_address,omitempty" required:"false" doc:"IP address or DNS name of External Key Manager. Applicable if encryption is enabled and encryption type is one of the external key management types."`
	EkmAuthDomain                                  string                                       `json:"ekm_auth_domain,omitempty" yaml:"ekm_auth_domain,omitempty" required:"false" doc:"EKM auth domain (Thales)"`
	EkmBypassValidation                            bool                                         `json:"ekm_bypass_validation,omitempty" yaml:"ekm_bypass_validation,omitempty" required:"false" doc:"Bypass key and certificate validation"`
	EkmCaCertificate                               string                                       `json:"ekm_ca_certificate,omitempty" yaml:"ekm_ca_certificate,omitempty" required:"false" doc:"The CA certificate for the connection to the EKM servers"`
	EkmCertificate                                 string                                       `json:"ekm_certificate,omitempty" yaml:"ekm_certificate,omitempty" required:"false" doc:"The SSL certificate for the connection to the EKM servers"`
	EkmDomain                                      string                                       `json:"ekm_domain,omitempty" yaml:"ekm_domain,omitempty" required:"false" doc:"EKM domain (Thales)"`
	EkmPort                                        int64                                        `json:"ekm_port,omitempty" yaml:"ekm_port,omitempty" required:"false" doc:"Port number for connections to an External Key Manager. Applicable if encryption is enabled and encryption type is one of the external key management types. Valid range: 1024 - 65535. Default: 5696"`
	EkmPrivateKey                                  string                                       `json:"ekm_private_key,omitempty" yaml:"ekm_private_key,omitempty" required:"false" doc:"The private key of the SSL certificate for the connection to the EKM servers."`
	EkmProxyAddress                                string                                       `json:"ekm_proxy_address,omitempty" yaml:"ekm_proxy_address,omitempty" required:"false" doc:"Thales EKM proxy address: https://proxy-address:port"`
	EkmServers                                     string                                       `json:"ekm_servers,omitempty" yaml:"ekm_servers,omitempty" required:"false" doc:"List of EKM server IPs, additional to ekm_address. Up to five servers may be specified in total. For example: 10.0.0.1:5696,11.0.0.1:5697"`
	EnableDr                                       bool                                         `json:"enable_dr,omitempty" yaml:"enable_dr,omitempty" required:"false" doc:"Enable data reduction"`
	EnableEncryption                               bool                                         `json:"enable_encryption,omitempty" yaml:"enable_encryption,omitempty" required:"false" doc:"Enable data encryption"`
	EnableRackLevelResiliency                      bool                                         `json:"enable_rack_level_resiliency,omitempty" yaml:"enable_rack_level_resiliency,omitempty" required:"false" doc:"Enable rack level resiliency"`
	EnableSimilarity                               bool                                         `json:"enable_similarity,omitempty" yaml:"enable_similarity,omitempty" required:"false" doc:"Enable similarity"`
	EnableSmb                                      bool                                         `json:"enable_smb,omitempty" yaml:"enable_smb,omitempty" required:"false" doc:"Enable support for SMB"`
	EncryptionType                                 string                                       `json:"encryption_type,omitempty" yaml:"encryption_type,omitempty" required:"false" doc:"Encryption type. INTERNAL = keys are managed internally. CIPHER_TRUST_KMIP=Keys are stored and managed on Thales Group CipherTrust Data Security Platform, FORTANIX_KMIP=Keys are stored and managed on Fortanix DSM, HASHICORP_KMIP=Keys are stored and managed on HashiCorp Vault Enterprise."`
	FailingComponentsCnodesFailureToFailPercentage int64                                        `json:"failing_components_cnodes_failure_to_fail_percentage,omitempty" yaml:"failing_components_cnodes_failure_to_fail_percentage,omitempty" required:"false" doc:"Percentage of all CNodes that are allowed to fail"`
	FailingComponentsEnabled                       bool                                         `json:"failing_components_enabled,omitempty" yaml:"failing_components_enabled,omitempty" required:"false" doc:"Enable failing components feature"`
	FailureDomainsSupport                          bool                                         `json:"failure_domains_support,omitempty" yaml:"failure_domains_support,omitempty" required:"false" doc:"Failure domains support"`
	FormatDrives                                   bool                                         `json:"format_drives,omitempty" yaml:"format_drives,omitempty" required:"false" doc:"Format drives"`
	HalfSystem                                     bool                                         `json:"half_system,omitempty" yaml:"half_system,omitempty" required:"false" doc:"Is half system"`
	IbMode                                         string                                       `json:"ib_mode,omitempty" yaml:"ib_mode,omitempty" required:"false" doc:"Mode of Infiniband network"`
	Ipv6Gateway                                    string                                       `json:"ipv6_gateway,omitempty" yaml:"ipv6_gateway,omitempty" required:"false" doc:"External ipv6 gateway"`
	Ipv6MgmtVip                                    string                                       `json:"ipv6_mgmt_vip,omitempty" yaml:"ipv6_mgmt_vip,omitempty" required:"false" doc:"IPV6 Management VIP"`
	Ipv6Prefix                                     int64                                        `json:"ipv6_prefix,omitempty" yaml:"ipv6_prefix,omitempty" required:"false" doc:"IPV6 Prefix"`
	LabDeploy                                      bool                                         `json:"lab_deploy,omitempty" yaml:"lab_deploy,omitempty" required:"false" doc:"Flag for lab deploy only, default: False"`
	LargeObjectScale                               bool                                         `json:"large_object_scale,omitempty" yaml:"large_object_scale,omitempty" required:"false" doc:"Flag for large object scale system"`
	Loopback                                       bool                                         `json:"loopback,omitempty" yaml:"loopback,omitempty" required:"false" doc:"Loopback (single node) installation"`
	LoopbackConf                                   string                                       `json:"loopback_conf,omitempty" yaml:"loopback_conf,omitempty" required:"false" doc:"Loopback Configuration"`
	MaxFileSize                                    int64                                        `json:"max_file_size,omitempty" yaml:"max_file_size,omitempty" required:"false" doc:"Maximum audit file size for each CNode core"`
	MaxNvramCapacityPercent                        int64                                        `json:"max_nvram_capacity_percent,omitempty" yaml:"max_nvram_capacity_percent,omitempty" required:"false" doc:"Max NVRAM capacity percent"`
	MaxNvramReplicationFactor                      int64                                        `json:"max_nvram_replication_factor,omitempty" yaml:"max_nvram_replication_factor,omitempty" required:"false" doc:"Max NVRAM replication factor"`
	MaxRetentionPeriod                             int64                                        `json:"max_retention_period,omitempty" yaml:"max_retention_period,omitempty" required:"false" doc:"Max retention period for audit files. Units of measurement set by max_renention_timeunit."`
	MaxRetentionTimeunit                           string                                       `json:"max_retention_timeunit,omitempty" yaml:"max_retention_timeunit,omitempty" required:"false" doc:"Unit of measurement for the period specified as max_retention_period"`
	MaxSsdCapacityPercent                          int64                                        `json:"max_ssd_capacity_percent,omitempty" yaml:"max_ssd_capacity_percent,omitempty" required:"false" doc:"Max SSD capacity percent"`
	MegaDrShards                                   int64                                        `json:"mega_dr_shards,omitempty" yaml:"mega_dr_shards,omitempty" required:"false" doc:"Number of DR shards"`
	MegaDrWbShards                                 int64                                        `json:"mega_dr_wb_shards,omitempty" yaml:"mega_dr_wb_shards,omitempty" required:"false" doc:"Number of DR write buffer shards"`
	MegaShards                                     int64                                        `json:"mega_shards,omitempty" yaml:"mega_shards,omitempty" required:"false" doc:"Number of shards"`
	MegaStripeGroups                               int64                                        `json:"mega_stripe_groups,omitempty" yaml:"mega_stripe_groups,omitempty" required:"false" doc:"Number of stripe groups"`
	MicroDrShards                                  int64                                        `json:"micro_dr_shards,omitempty" yaml:"micro_dr_shards,omitempty" required:"false" doc:"Number of DR shards"`
	MicroDrWbShards                                int64                                        `json:"micro_dr_wb_shards,omitempty" yaml:"micro_dr_wb_shards,omitempty" required:"false" doc:"Number of DR write buffer shards"`
	MicroShards                                    int64                                        `json:"micro_shards,omitempty" yaml:"micro_shards,omitempty" required:"false" doc:"Number of shards"`
	MicroStripeGroups                              int64                                        `json:"micro_stripe_groups,omitempty" yaml:"micro_stripe_groups,omitempty" required:"false" doc:"Number of stripe groups"`
	MockRaiderGuiAvailability                      bool                                         `json:"mock_raider_gui_availability,omitempty" yaml:"mock_raider_gui_availability,omitempty" required:"false" doc:"Creates mock for HPE Raider GUI availability, default is False"`
	NbEthMtu                                       int64                                        `json:"nb_eth_mtu,omitempty" yaml:"nb_eth_mtu,omitempty" required:"false" doc:"Ethernet Northbound MTU, optional"`
	NbIbMtu                                        int64                                        `json:"nb_ib_mtu,omitempty" yaml:"nb_ib_mtu,omitempty" required:"false" doc:"Infiniband Northbound MTU, optional"`
	NoPerfCheck                                    bool                                         `json:"no_perf_check,omitempty" yaml:"no_perf_check,omitempty" required:"false" doc:"Don't check cluster performance (default is False, i.e. perform check)"`
	NvramSectionLayout                             string                                       `json:"nvram_section_layout,omitempty" yaml:"nvram_section_layout,omitempty" required:"false" doc:"NVRAM Section Layout"`
	NvramSize                                      int64                                        `json:"nvram_size,omitempty" yaml:"nvram_size,omitempty" required:"false" doc:"NVRAM size for mocked devices"`
	PrefillDevices                                 bool                                         `json:"prefill_devices,omitempty" yaml:"prefill_devices,omitempty" required:"false" doc:"prefill the mocked devices with zeroes at install"`
	Protocols                                      *[]string                                    `json:"protocols,omitempty" yaml:"protocols,omitempty" required:"false" doc:"Protocols to audit for all views."`
	Psnt                                           string                                       `json:"psnt,omitempty" yaml:"psnt,omitempty" required:"false" doc:"Cluster PSNT"`
	RackPools                                      map[string]ClusterRequestBody_RackPoolsValue `json:"rack_pools,omitempty" yaml:"rack_pools,omitempty" required:"false" doc:""`
	ReadAccessUsers                                *[]string                                    `json:"read_access_users,omitempty" yaml:"read_access_users,omitempty" required:"false" doc:"Enter users here to grant them read access to all files in the audit directory. To make the audit directory accessible to clients, create a view on the directory."`
	ReadAccessUsersGroups                          *[]string                                    `json:"read_access_users_groups,omitempty" yaml:"read_access_users_groups,omitempty" required:"false" doc:"Enter groups here to grant them read access to all files in the audit directory. To make the audit directory accessible to clients, create a view on the directory."`
	RestrictUser                                   bool                                         `json:"restrict_user,omitempty" yaml:"restrict_user,omitempty" required:"false" doc:"Flag for restrict vastdata user, default is False"`
	S3BlockV2Authentication                        bool                                         `json:"s3_block_v2_authentication,omitempty" yaml:"s3_block_v2_authentication,omitempty" required:"false" doc:"Manage s3 blocks v2 authentication"`
	SecondaryEkmAddress                            string                                       `json:"secondary_ekm_address,omitempty" yaml:"secondary_ekm_address,omitempty" required:"false" doc:"EKM address"`
	SecondaryEkmPort                               int64                                        `json:"secondary_ekm_port,omitempty" yaml:"secondary_ekm_port,omitempty" required:"false" doc:"EKM port. Valid range: 1024 - 65535."`
	Shards                                         int64                                        `json:"shards,omitempty" yaml:"shards,omitempty" required:"false" doc:"Number of shards"`
	StripeGroups                                   int64                                        `json:"stripe_groups,omitempty" yaml:"stripe_groups,omitempty" required:"false" doc:"Number of stripe groups"`
	SwDefined                                      bool                                         `json:"sw_defined,omitempty" yaml:"sw_defined,omitempty" required:"false" doc:"Enable sw_defined (only for SDS setup)"`
	SystemExpansionHack                            bool                                         `json:"system_expansion_hack,omitempty" yaml:"system_expansion_hack,omitempty" required:"false" doc:"Hack for expansions tests in CI"`
	UseSpdk                                        bool                                         `json:"use_spdk,omitempty" yaml:"use_spdk,omitempty" required:"false" doc:"Should install spdk"`
	Virtual                                        bool                                         `json:"virtual,omitempty" yaml:"virtual,omitempty" required:"false" doc:"virtual hardware deployment (default is False)"`
	Voc                                            bool                                         `json:"voc,omitempty" yaml:"voc,omitempty" required:"false" doc:"vast on cloud installation flag (default is False)"`
	Vsettings                                      map[string]string                            `json:"vsettings,omitempty" yaml:"vsettings,omitempty" required:"false" doc:""`
	WbRaidLayout                                   string                                       `json:"wb_raid_layout,omitempty" yaml:"wb_raid_layout,omitempty" required:"false" doc:"WB Raid layout"`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// ClusterDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/Cluster
type ClusterDetailsModel = Component_Cluster

// ClusterUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/AsyncCluster
type ClusterUpsertModel = Component_AsyncCluster

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple clusters with typed request/response
// summary: List Clusters
func (r *Cluster) List(req *ClusterSearchParams) ([]*ClusterDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple clusters with typed request/response using provided context
// summary: List Clusters
func (r *Cluster) ListWithContext(ctx context.Context, req *ClusterSearchParams) ([]*ClusterDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*ClusterDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single cluster with typed request/response
// summary: List Clusters
func (r *Cluster) Get(req *ClusterSearchParams) (*ClusterDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single cluster with typed request/response using provided context
// summary: List Clusters
func (r *Cluster) GetWithContext(ctx context.Context, req *ClusterSearchParams) (*ClusterDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ClusterDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single cluster by ID
// summary: Detail Cluster Properties
func (r *Cluster) GetById(id any) (*ClusterDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single cluster by ID using provided context
// summary: Detail Cluster Properties
func (r *Cluster) GetByIdWithContext(ctx context.Context, id any) (*ClusterDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response ClusterDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new cluster with typed request/response
// summary: Create Cluster
func (r *Cluster) Create(req *ClusterRequestBody) (*ClusterUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new cluster with typed request/response using provided context
// summary: Create Cluster
func (r *Cluster) CreateWithContext(ctx context.Context, req *ClusterRequestBody) (*ClusterUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ClusterUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// UPDATE
// -----------------------------------------------------

// Update updates an existing cluster with typed request/response
func (r *Cluster) Update(id any, req *ClusterRequestBody) (*ClusterUpsertModel, error) {
	return r.UpdateWithContext(r.Untyped.GetCtx(), id, req)
}

// UpdateWithContext updates an existing cluster with typed request/response using provided context
func (r *Cluster) UpdateWithContext(ctx context.Context, id any, req *ClusterRequestBody) (*ClusterUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].UpdateWithContext(ctx, id, params)
	if err != nil {
		return nil, err
	}

	var response ClusterUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a cluster with search parameters
func (r *Cluster) Delete(req *ClusterSearchParams) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req)
}

// DeleteWithContext deletes a cluster with search parameters using provided context
func (r *Cluster) DeleteWithContext(ctx context.Context, req *ClusterSearchParams) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a cluster by ID
// summary: Delete Cluster
//
// Parameters:
//   - id: Cluster ID
func (r *Cluster) DeleteById(id any) error {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id)
}

// DeleteByIdWithContext deletes a cluster by ID using provided context
// summary: Delete Cluster
//
// Parameters:
//   - id: Cluster ID
func (r *Cluster) DeleteByIdWithContext(ctx context.Context, id any) error {
	_, err := r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteByIdWithContext(ctx, id, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a cluster exists with typed response
func (r *Cluster) Ensure(searchParams *ClusterSearchParams, body *ClusterRequestBody) (*ClusterUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a cluster exists with typed response using provided context
func (r *Cluster) EnsureWithContext(ctx context.Context, searchParams *ClusterSearchParams, body *ClusterRequestBody) (*ClusterUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response ClusterUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a cluster exists
func (r *Cluster) Exists(req *ClusterSearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a cluster exists using provided context
func (r *Cluster) ExistsWithContext(ctx context.Context, req *ClusterSearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a cluster exists and panics if not
func (r *Cluster) MustExists(req *ClusterSearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a cluster exists and panics if not using provided context
func (r *Cluster) MustExistsWithContext(ctx context.Context, req *ClusterSearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// ClusterAddBoxesBody_Cboxes represents a nested type for Cluster extra method body
type ClusterAddBoxesBody_Cboxes struct {
	Hosts  *[]ClusterAddBoxesBody_Cboxes_HostsItem `json:"hosts,omitempty" yaml:"hosts,omitempty" required:"true" doc:""`
	Order  int64                                   `json:"order,omitempty" yaml:"order,omitempty" required:"true" doc:""`
	Subnet int64                                   `json:"subnet,omitempty" yaml:"subnet,omitempty" required:"true" doc:""`
}

// ClusterAddBoxesBody_Cboxes_HostsItem represents a nested type for Cluster extra method body
type ClusterAddBoxesBody_Cboxes_HostsItem struct {
	Id          int64  `json:"id,omitempty" yaml:"id,omitempty" required:"true" doc:""`
	NetType     string `json:"net_type,omitempty" yaml:"net_type,omitempty" required:"true" doc:""`
	ReverseNics bool   `json:"reverse_nics" yaml:"reverse_nics" required:"true" doc:""`
	SkipNic     string `json:"skip_nic,omitempty" yaml:"skip_nic,omitempty" required:"true" doc:""`
	NbEthMtu    int64  `json:"nb_eth_mtu,omitempty" yaml:"nb_eth_mtu,omitempty" required:"false" doc:"relevant only for large subnet"`
	NbIbMode    string `json:"nb_ib_mode,omitempty" yaml:"nb_ib_mode,omitempty" required:"false" doc:"relevant only for large subnet"`
	NbIbMtu     int64  `json:"nb_ib_mtu,omitempty" yaml:"nb_ib_mtu,omitempty" required:"false" doc:"relevant only for large subnet"`
}

// ClusterAddBoxesBody_Dboxes represents a nested type for Cluster extra method body
type ClusterAddBoxesBody_Dboxes struct {
	Hosts  *[]ClusterAddBoxesBody_Dboxes_HostsItem `json:"hosts,omitempty" yaml:"hosts,omitempty" required:"true" doc:""`
	Order  int64                                   `json:"order,omitempty" yaml:"order,omitempty" required:"true" doc:""`
	Subnet int64                                   `json:"subnet,omitempty" yaml:"subnet,omitempty" required:"true" doc:""`
}

// ClusterAddBoxesBody_Dboxes_HostsItem represents a nested type for Cluster extra method body
type ClusterAddBoxesBody_Dboxes_HostsItem struct {
	Id int64 `json:"id,omitempty" yaml:"id,omitempty" required:"true" doc:""`
}

// ClusterAddBoxesBody_RackPoolsValue represents a nested type for Cluster extra method body
type ClusterAddBoxesBody_RackPoolsValue struct {
	CnodeIpPool   *[]string `json:"cnode_ip_pool,omitempty" yaml:"cnode_ip_pool,omitempty" required:"false" doc:""`
	CnodeIpmiPool *[]string `json:"cnode_ipmi_pool,omitempty" yaml:"cnode_ipmi_pool,omitempty" required:"false" doc:""`
	DnodeIpPool   *[]string `json:"dnode_ip_pool,omitempty" yaml:"dnode_ip_pool,omitempty" required:"false" doc:""`
	DnodeIpmiPool *[]string `json:"dnode_ipmi_pool,omitempty" yaml:"dnode_ipmi_pool,omitempty" required:"false" doc:""`
}

// ClusterWipeBody_CnodeListItem represents a nested type for Cluster extra method body
type ClusterWipeBody_CnodeListItem struct {
	Name                       string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:""`
	BiosVersion                string `json:"bios_version,omitempty" yaml:"bios_version,omitempty" required:"false" doc:"BIOS version"`
	BmcFwVersion               string `json:"bmc_fw_version,omitempty" yaml:"bmc_fw_version,omitempty" required:"false" doc:"BMC FW version"`
	BmcState                   string `json:"bmc_state,omitempty" yaml:"bmc_state,omitempty" required:"false" doc:"BMC State"`
	BmcStateReason             string `json:"bmc_state_reason,omitempty" yaml:"bmc_state_reason,omitempty" required:"false" doc:"BMC state reason"`
	BoxVendor                  string `json:"box_vendor,omitempty" yaml:"box_vendor,omitempty" required:"false" doc:"Parent box model description including hardware vendor"`
	Build                      string `json:"build,omitempty" yaml:"build,omitempty" required:"false" doc:""`
	Cbox                       string `json:"cbox,omitempty" yaml:"cbox,omitempty" required:"false" doc:"Parent CBox"`
	CboxId                     int64  `json:"cbox_id,omitempty" yaml:"cbox_id,omitempty" required:"false" doc:"Parent CBox ID"`
	Cluster                    string `json:"cluster,omitempty" yaml:"cluster,omitempty" required:"false" doc:"Parent Cluster"`
	ClusterId                  int64  `json:"cluster_id,omitempty" yaml:"cluster_id,omitempty" required:"false" doc:"Parent Cluster ID"`
	Cores                      int64  `json:"cores,omitempty" yaml:"cores,omitempty" required:"false" doc:"Number of CNode cores"`
	Cpld                       string `json:"cpld,omitempty" yaml:"cpld,omitempty" required:"false" doc:""`
	DataRdmaPort               int64  `json:"data_rdma_port,omitempty" yaml:"data_rdma_port,omitempty" required:"false" doc:"port for internal use"`
	DataTcpPort                int64  `json:"data_tcp_port,omitempty" yaml:"data_tcp_port,omitempty" required:"false" doc:"port for internal use"`
	DisplayName                string `json:"display_name,omitempty" yaml:"display_name,omitempty" required:"false" doc:""`
	DisplayState               string `json:"display_state,omitempty" yaml:"display_state,omitempty" required:"false" doc:"State"`
	Enabled                    bool   `json:"enabled,omitempty" yaml:"enabled,omitempty" required:"false" doc:"True if the CNode is enabled"`
	Guid                       string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:"Global unique ID"`
	HostLabel                  string `json:"host_label,omitempty" yaml:"host_label,omitempty" required:"false" doc:"Host label, used to label container, e.g. 11.0.0.1-4000"`
	HostOpensmMaster           string `json:"host_opensm_master,omitempty" yaml:"host_opensm_master,omitempty" required:"false" doc:"If OpenSM master"`
	Hostname                   string `json:"hostname,omitempty" yaml:"hostname,omitempty" required:"false" doc:"Host Name"`
	Id                         int64  `json:"id,omitempty" yaml:"id,omitempty" required:"false" doc:"CNode ID"`
	Ip                         string `json:"ip,omitempty" yaml:"ip,omitempty" required:"false" doc:"The IP of the bond interface of ip1 and ip2."`
	Ip1                        string `json:"ip1,omitempty" yaml:"ip1,omitempty" required:"false" doc:"1st of two IP addresses on the cluster's internal network"`
	Ip2                        string `json:"ip2,omitempty" yaml:"ip2,omitempty" required:"false" doc:"2nd of two IP addresses on the cluster's internal network"`
	IpmiIp                     string `json:"ipmi_ip,omitempty" yaml:"ipmi_ip,omitempty" required:"false" doc:"IP of IPMI"`
	Ipv6                       string `json:"ipv6,omitempty" yaml:"ipv6,omitempty" required:"false" doc:"External IPv6 Address"`
	IsMgmt                     bool   `json:"is_mgmt,omitempty" yaml:"is_mgmt,omitempty" required:"false" doc:"True if the CNode is currently hosting VMS"`
	LedStatus                  string `json:"led_status,omitempty" yaml:"led_status,omitempty" required:"false" doc:"LED status"`
	MgmtIp                     string `json:"mgmt_ip,omitempty" yaml:"mgmt_ip,omitempty" required:"false" doc:"IP address for management access"`
	NewName                    string `json:"new_name,omitempty" yaml:"new_name,omitempty" required:"false" doc:"Name"`
	OpensmState                bool   `json:"opensm_state,omitempty" yaml:"opensm_state,omitempty" required:"false" doc:"opensm service state"`
	OsVersion                  string `json:"os_version,omitempty" yaml:"os_version,omitempty" required:"false" doc:"VAST OS version"`
	PlatformRdmaPort           int64  `json:"platform_rdma_port,omitempty" yaml:"platform_rdma_port,omitempty" required:"false" doc:"port for internal use"`
	PlatformTcpPort            int64  `json:"platform_tcp_port,omitempty" yaml:"platform_tcp_port,omitempty" required:"false" doc:"port for internal use"`
	Position                   string `json:"position,omitempty" yaml:"position,omitempty" required:"false" doc:"position of CNode in CBox"`
	Rpm                        string `json:"rpm,omitempty" yaml:"rpm,omitempty" required:"false" doc:"VAST Utils Version"`
	Sn                         string `json:"sn,omitempty" yaml:"sn,omitempty" required:"false" doc:"The host serial number"`
	State                      string `json:"state,omitempty" yaml:"state,omitempty" required:"false" doc:"State, e.g. active"`
	Sync                       string `json:"sync,omitempty" yaml:"sync,omitempty" required:"false" doc:"Synchronization state with leader"`
	SyncTime                   string `json:"sync_time,omitempty" yaml:"sync_time,omitempty" required:"false" doc:"Synchronization time with leader"`
	Title                      string `json:"title,omitempty" yaml:"title,omitempty" required:"false" doc:""`
	TpmBootDevEncryptionStatus string `json:"tpm_boot_dev_encryption_status,omitempty" yaml:"tpm_boot_dev_encryption_status,omitempty" required:"false" doc:"Boot encryption status"`
	TurboBoost                 bool   `json:"turbo_boost,omitempty" yaml:"turbo_boost,omitempty" required:"false" doc:""`
	Url                        string `json:"url,omitempty" yaml:"url,omitempty" required:"false" doc:""`
	Vlan                       string `json:"vlan,omitempty" yaml:"vlan,omitempty" required:"false" doc:"VLAN ID"`
	VmsPreferred               bool   `json:"vms_preferred,omitempty" yaml:"vms_preferred,omitempty" required:"false" doc:"VMS preferred CNode"`
}

// ClusterWipeBody_DnodeListItem represents a nested type for Cluster extra method body
type ClusterWipeBody_DnodeListItem struct {
	Name             string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:""`
	ArchType         string `json:"arch_type,omitempty" yaml:"arch_type,omitempty" required:"false" doc:""`
	BiosVersion      string `json:"bios_version,omitempty" yaml:"bios_version,omitempty" required:"false" doc:""`
	BmcFwVersion     string `json:"bmc_fw_version,omitempty" yaml:"bmc_fw_version,omitempty" required:"false" doc:"BMC FW version"`
	BmcState         string `json:"bmc_state,omitempty" yaml:"bmc_state,omitempty" required:"false" doc:""`
	BmcStateReason   string `json:"bmc_state_reason,omitempty" yaml:"bmc_state_reason,omitempty" required:"false" doc:""`
	BoxRdmaPort      int64  `json:"box_rdma_port,omitempty" yaml:"box_rdma_port,omitempty" required:"false" doc:"port for internal use"`
	Build            string `json:"build,omitempty" yaml:"build,omitempty" required:"false" doc:""`
	Cluster          string `json:"cluster,omitempty" yaml:"cluster,omitempty" required:"false" doc:"Parent Cluster"`
	ClusterId        int64  `json:"cluster_id,omitempty" yaml:"cluster_id,omitempty" required:"false" doc:""`
	Cpld             string `json:"cpld,omitempty" yaml:"cpld,omitempty" required:"false" doc:""`
	DataRdmaPort     int64  `json:"data_rdma_port,omitempty" yaml:"data_rdma_port,omitempty" required:"false" doc:"port for internal use"`
	DataTcpPort      int64  `json:"data_tcp_port,omitempty" yaml:"data_tcp_port,omitempty" required:"false" doc:"port for internal use"`
	Dbox             string `json:"dbox,omitempty" yaml:"dbox,omitempty" required:"false" doc:"Parent DBox"`
	DboxId           int64  `json:"dbox_id,omitempty" yaml:"dbox_id,omitempty" required:"false" doc:""`
	DisplayName      string `json:"display_name,omitempty" yaml:"display_name,omitempty" required:"false" doc:""`
	Dtray            string `json:"dtray,omitempty" yaml:"dtray,omitempty" required:"false" doc:"Parent DTray"`
	Ebox             string `json:"ebox,omitempty" yaml:"ebox,omitempty" required:"false" doc:"Parent EBox"`
	EboxId           int64  `json:"ebox_id,omitempty" yaml:"ebox_id,omitempty" required:"false" doc:""`
	Enabled          bool   `json:"enabled,omitempty" yaml:"enabled,omitempty" required:"false" doc:"True if Dnode is enabled"`
	Guid             string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	HostLabel        string `json:"host_label,omitempty" yaml:"host_label,omitempty" required:"false" doc:"Host label, used to label container, e.g. 11.0.0.1-4000"`
	Hostname         string `json:"hostname,omitempty" yaml:"hostname,omitempty" required:"false" doc:"Host Name"`
	Id               int64  `json:"id,omitempty" yaml:"id,omitempty" required:"false" doc:""`
	Ip               string `json:"ip,omitempty" yaml:"ip,omitempty" required:"false" doc:"The IP of the bond interface of ip1 and ip2."`
	Ip1              string `json:"ip1,omitempty" yaml:"ip1,omitempty" required:"false" doc:"1st of two IP addresses on the cluster's internal network"`
	Ip2              string `json:"ip2,omitempty" yaml:"ip2,omitempty" required:"false" doc:"2nd of two IP addresses on the cluster's internal network"`
	IpmiIp           string `json:"ipmi_ip,omitempty" yaml:"ipmi_ip,omitempty" required:"false" doc:"IPMI IP"`
	Ipv6             string `json:"ipv6,omitempty" yaml:"ipv6,omitempty" required:"false" doc:"External IPv6 Address"`
	IsPrimary        bool   `json:"is_primary,omitempty" yaml:"is_primary,omitempty" required:"false" doc:"Indicates if node is the primary, aka master, dnode."`
	LedStatus        string `json:"led_status,omitempty" yaml:"led_status,omitempty" required:"false" doc:""`
	MgmtIp           string `json:"mgmt_ip,omitempty" yaml:"mgmt_ip,omitempty" required:"false" doc:"IP address for management access"`
	NewName          string `json:"new_name,omitempty" yaml:"new_name,omitempty" required:"false" doc:""`
	OsVersion        string `json:"os_version,omitempty" yaml:"os_version,omitempty" required:"false" doc:"Node OS version"`
	PlatformRdmaPort int64  `json:"platform_rdma_port,omitempty" yaml:"platform_rdma_port,omitempty" required:"false" doc:"port for internal use"`
	PlatformTcpPort  int64  `json:"platform_tcp_port,omitempty" yaml:"platform_tcp_port,omitempty" required:"false" doc:"port for internal use"`
	Position         string `json:"position,omitempty" yaml:"position,omitempty" required:"false" doc:""`
	Rpm              string `json:"rpm,omitempty" yaml:"rpm,omitempty" required:"false" doc:"VAST Utils Version"`
	Sn               string `json:"sn,omitempty" yaml:"sn,omitempty" required:"false" doc:"The host serial number"`
	State            string `json:"state,omitempty" yaml:"state,omitempty" required:"false" doc:""`
	Sync             string `json:"sync,omitempty" yaml:"sync,omitempty" required:"false" doc:"Synchronization state with leader"`
	SyncTime         string `json:"sync_time,omitempty" yaml:"sync_time,omitempty" required:"false" doc:"Synchronization time with leader"`
	Title            string `json:"title,omitempty" yaml:"title,omitempty" required:"false" doc:""`
	Url              string `json:"url,omitempty" yaml:"url,omitempty" required:"false" doc:""`
}

// ClusterCloseProtocolHandleModel_FileHandle represents a nested type for Cluster extra method response
type ClusterCloseProtocolHandleModel_FileHandle struct {
	CloneId                   string `json:"clone_id,omitempty" yaml:"clone_id,omitempty" required:"false" doc:""`
	DeletePending             string `json:"delete_pending,omitempty" yaml:"delete_pending,omitempty" required:"false" doc:""`
	Ehandle                   string `json:"ehandle,omitempty" yaml:"ehandle,omitempty" required:"false" doc:""`
	HasAnyLease               string `json:"has_any_lease,omitempty" yaml:"has_any_lease,omitempty" required:"false" doc:""`
	LeaseBreakInProgress      string `json:"lease_break_in_progress,omitempty" yaml:"lease_break_in_progress,omitempty" required:"false" doc:""`
	Nfs4Only                  string `json:"nfs4_only,omitempty" yaml:"nfs4_only,omitempty" required:"false" doc:""`
	NumberOpenProtocolHandles int64  `json:"number_open_protocol_handles,omitempty" yaml:"number_open_protocol_handles,omitempty" required:"false" doc:""`
	StreamKey                 string `json:"stream_key,omitempty" yaml:"stream_key,omitempty" required:"false" doc:"Global access path ID"`
}

// ClusterCloseProtocolHandleModel_OpenProtocolHandlesItem represents a nested type for Cluster extra method response
type ClusterCloseProtocolHandleModel_OpenProtocolHandlesItem struct {
	AccessMask        *[]string `json:"access_mask,omitempty" yaml:"access_mask,omitempty" required:"false" doc:""`
	AccessMaskDisplay string    `json:"access_mask_display,omitempty" yaml:"access_mask_display,omitempty" required:"false" doc:"Human readable access mask string values"`
	ClientIp          string    `json:"client_ip,omitempty" yaml:"client_ip,omitempty" required:"false" doc:""`
	FileMode          string    `json:"file_mode,omitempty" yaml:"file_mode,omitempty" required:"false" doc:""`
	HasLease          string    `json:"has_lease,omitempty" yaml:"has_lease,omitempty" required:"false" doc:""`
	IsNfsExpirable    string    `json:"is_nfs_expirable,omitempty" yaml:"is_nfs_expirable,omitempty" required:"false" doc:""`
	Nfs4Seqid         string    `json:"nfs4_seqid,omitempty" yaml:"nfs4_seqid,omitempty" required:"false" doc:""`
	NfsExpirationTime string    `json:"nfs_expiration_time,omitempty" yaml:"nfs_expiration_time,omitempty" required:"false" doc:""`
	ProtoType         string    `json:"proto_type,omitempty" yaml:"proto_type,omitempty" required:"false" doc:""`
	SessionId         string    `json:"session_id,omitempty" yaml:"session_id,omitempty" required:"false" doc:""`
	ShareAccess       string    `json:"share_access,omitempty" yaml:"share_access,omitempty" required:"false" doc:""`
	UniqueId          string    `json:"unique_id,omitempty" yaml:"unique_id,omitempty" required:"false" doc:""`
	Username          string    `json:"username,omitempty" yaml:"username,omitempty" required:"false" doc:""`
}

// ClusterListOpenProtocolHandlesModel_FileHandle represents a nested type for Cluster extra method response
type ClusterListOpenProtocolHandlesModel_FileHandle struct {
	CloneId                   string `json:"clone_id,omitempty" yaml:"clone_id,omitempty" required:"false" doc:""`
	DeletePending             string `json:"delete_pending,omitempty" yaml:"delete_pending,omitempty" required:"false" doc:""`
	Ehandle                   string `json:"ehandle,omitempty" yaml:"ehandle,omitempty" required:"false" doc:""`
	HasAnyLease               string `json:"has_any_lease,omitempty" yaml:"has_any_lease,omitempty" required:"false" doc:""`
	LeaseBreakInProgress      string `json:"lease_break_in_progress,omitempty" yaml:"lease_break_in_progress,omitempty" required:"false" doc:""`
	Nfs4Only                  string `json:"nfs4_only,omitempty" yaml:"nfs4_only,omitempty" required:"false" doc:""`
	NumberOpenProtocolHandles int64  `json:"number_open_protocol_handles,omitempty" yaml:"number_open_protocol_handles,omitempty" required:"false" doc:""`
	StreamKey                 string `json:"stream_key,omitempty" yaml:"stream_key,omitempty" required:"false" doc:"Global access path ID"`
}

// ClusterListOpenProtocolHandlesModel_OpenProtocolHandlesItem represents a nested type for Cluster extra method response
type ClusterListOpenProtocolHandlesModel_OpenProtocolHandlesItem struct {
	AccessMask        *[]string `json:"access_mask,omitempty" yaml:"access_mask,omitempty" required:"false" doc:""`
	AccessMaskDisplay string    `json:"access_mask_display,omitempty" yaml:"access_mask_display,omitempty" required:"false" doc:"Human readable access mask string values"`
	ClientIp          string    `json:"client_ip,omitempty" yaml:"client_ip,omitempty" required:"false" doc:""`
	FileMode          string    `json:"file_mode,omitempty" yaml:"file_mode,omitempty" required:"false" doc:""`
	HasLease          string    `json:"has_lease,omitempty" yaml:"has_lease,omitempty" required:"false" doc:""`
	IsNfsExpirable    string    `json:"is_nfs_expirable,omitempty" yaml:"is_nfs_expirable,omitempty" required:"false" doc:""`
	Nfs4Seqid         string    `json:"nfs4_seqid,omitempty" yaml:"nfs4_seqid,omitempty" required:"false" doc:""`
	NfsExpirationTime string    `json:"nfs_expiration_time,omitempty" yaml:"nfs_expiration_time,omitempty" required:"false" doc:""`
	ProtoType         string    `json:"proto_type,omitempty" yaml:"proto_type,omitempty" required:"false" doc:""`
	SessionId         string    `json:"session_id,omitempty" yaml:"session_id,omitempty" required:"false" doc:""`
	ShareAccess       string    `json:"share_access,omitempty" yaml:"share_access,omitempty" required:"false" doc:""`
	UniqueId          string    `json:"unique_id,omitempty" yaml:"unique_id,omitempty" required:"false" doc:""`
	Username          string    `json:"username,omitempty" yaml:"username,omitempty" required:"false" doc:""`
}

// ClusterListPrefetchPathsInfoModel_PrefetchDataItem represents a nested type for Cluster extra method response
type ClusterListPrefetchPathsInfoModel_PrefetchDataItem struct {
	Paths  *[]ClusterListPrefetchPathsInfoModel_PrefetchDataItem_PathsItem `json:"paths,omitempty" yaml:"paths,omitempty" required:"false" doc:""`
	Tenant ClusterListPrefetchPathsInfoModel_PrefetchDataItem_Tenant       `json:"tenant,omitempty" yaml:"tenant,omitempty" required:"false" doc:""`
}

// ClusterListPrefetchPathsInfoModel_PrefetchDataItem_PathsItem represents a nested type for Cluster extra method response
type ClusterListPrefetchPathsInfoModel_PrefetchDataItem_PathsItem struct {
	Code            string `json:"code,omitempty" yaml:"code,omitempty" required:"false" doc:""`
	InodesRetrieved int64  `json:"inodes_retrieved,omitempty" yaml:"inodes_retrieved,omitempty" required:"false" doc:""`
	Path            string `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:""`
	PrefetchType    string `json:"prefetch_type,omitempty" yaml:"prefetch_type,omitempty" required:"false" doc:""`
	SizeRetrieved   int64  `json:"size_retrieved,omitempty" yaml:"size_retrieved,omitempty" required:"false" doc:""`
	TaskId          int64  `json:"task_id,omitempty" yaml:"task_id,omitempty" required:"false" doc:""`
}

// ClusterListPrefetchPathsInfoModel_PrefetchDataItem_Tenant represents a nested type for Cluster extra method response
type ClusterListPrefetchPathsInfoModel_PrefetchDataItem_Tenant struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:"Tenant name"`
}

// ClusterAddBoxes_PATCH_Body represents the request body for ClusterAddBoxes
type ClusterAddBoxes_PATCH_Body struct {
	Cboxes                ClusterAddBoxesBody_Cboxes                    `json:"cboxes,omitempty" yaml:"cboxes,omitempty" required:"true" doc:""`
	CnodeIpmiPool         *[]string                                     `json:"cnode_ipmi_pool,omitempty" yaml:"cnode_ipmi_pool,omitempty" required:"true" doc:""`
	CnodeManagementIpPool *[]string                                     `json:"cnode_management_ip_pool,omitempty" yaml:"cnode_management_ip_pool,omitempty" required:"true" doc:""`
	Dboxes                ClusterAddBoxesBody_Dboxes                    `json:"dboxes,omitempty" yaml:"dboxes,omitempty" required:"true" doc:""`
	DnodeIpmiPool         *[]string                                     `json:"dnode_ipmi_pool,omitempty" yaml:"dnode_ipmi_pool,omitempty" required:"true" doc:""`
	DnodeManagementIpPool *[]string                                     `json:"dnode_management_ip_pool,omitempty" yaml:"dnode_management_ip_pool,omitempty" required:"true" doc:""`
	EmptyDbox             bool                                          `json:"empty_dbox" yaml:"empty_dbox" required:"true" doc:""`
	ExternalGateway       *[]string                                     `json:"external_gateway,omitempty" yaml:"external_gateway,omitempty" required:"true" doc:""`
	ManagementCidr        int64                                         `json:"management_cidr,omitempty" yaml:"management_cidr,omitempty" required:"true" doc:""`
	MigrateTarget         bool                                          `json:"migrate_target" yaml:"migrate_target" required:"true" doc:""`
	CnodeStartIndex       int64                                         `json:"cnode_start_index,omitempty" yaml:"cnode_start_index,omitempty" required:"false" doc:"CNode start index valid range: [1, 99], for null value index will be selected automatically, as max_existed_index + 1"`
	ContinueMigration     bool                                          `json:"continue_migration,omitempty" yaml:"continue_migration,omitempty" required:"false" doc:""`
	DnodeStartIndex       int64                                         `json:"dnode_start_index,omitempty" yaml:"dnode_start_index,omitempty" required:"false" doc:"CNode start index valid range: [100, 254], for null value index will be selected automatically, as max_existed_index + 1"`
	HostnamePrefix        string                                        `json:"hostname_prefix,omitempty" yaml:"hostname_prefix,omitempty" required:"false" doc:""`
	Ipv6Prefix            int64                                         `json:"ipv6_prefix,omitempty" yaml:"ipv6_prefix,omitempty" required:"false" doc:""`
	RackPools             map[string]ClusterAddBoxesBody_RackPoolsValue `json:"rack_pools,omitempty" yaml:"rack_pools,omitempty" required:"false" doc:""`
}

// ClusterAddBoxesWithContext_PATCH
// method: PATCH
// url: /clusters/add_boxes/
// summary: Start Add Boxes procedure
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterAddBoxesWithContext_PATCH(ctx context.Context, body *ClusterAddBoxes_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := "/clusters/add_boxes/"

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterAddBoxes_PATCH
// method: PATCH
// url: /clusters/add_boxes/
// summary: Start Add Boxes procedure
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterAddBoxes_PATCH(body *ClusterAddBoxes_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterAddBoxesWithContext_PATCH(r.Untyped.GetCtx(), body, waitTimeout)
}

// ClusterAddEkm_POST_Body represents the request body for ClusterAddEkm
type ClusterAddEkm_POST_Body struct {
	EkmAuthDomain       string `json:"ekm_auth_domain,omitempty" yaml:"ekm_auth_domain,omitempty" required:"false" doc:"Auth domain (Thales)"`
	EkmBypassValidation bool   `json:"ekm_bypass_validation,omitempty" yaml:"ekm_bypass_validation,omitempty" required:"false" doc:"Bypass key and cert validation (VMS)"`
	EkmCaCertificate    string `json:"ekm_ca_certificate,omitempty" yaml:"ekm_ca_certificate,omitempty" required:"false" doc:"EKM CA certificate"`
	EkmCertificate      string `json:"ekm_certificate,omitempty" yaml:"ekm_certificate,omitempty" required:"false" doc:"EKM certificate"`
	EkmDomain           string `json:"ekm_domain,omitempty" yaml:"ekm_domain,omitempty" required:"false" doc:"Domain (Thales)"`
	EkmPrivateKey       string `json:"ekm_private_key,omitempty" yaml:"ekm_private_key,omitempty" required:"false" doc:"EKM private key"`
	EkmProxyAddress     string `json:"ekm_proxy_address,omitempty" yaml:"ekm_proxy_address,omitempty" required:"false" doc:"Thales EKM proxy address: https://proxy-address:port"`
	EkmServers          string `json:"ekm_servers,omitempty" yaml:"ekm_servers,omitempty" required:"false" doc:"List of EKM servers: 10.0.0.1:5696,11.0.0.1:5697"`
	EncryptionType      string `json:"encryption_type,omitempty" yaml:"encryption_type,omitempty" required:"false" doc:"Encryption type"`
}

// ClusterAddEkmWithContext_POST
// method: POST
// url: /clusters/{id}/add_ekm/
// summary: Add EKM
func (r *Cluster) ClusterAddEkmWithContext_POST(ctx context.Context, id any, body *ClusterAddEkm_POST_Body) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "add_ekm")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return err
	}

	_, err = core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	return err

}

// ClusterAddEkm_POST
// method: POST
// url: /clusters/{id}/add_ekm/
// summary: Add EKM
func (r *Cluster) ClusterAddEkm_POST(id any, body *ClusterAddEkm_POST_Body) error {
	return r.ClusterAddEkmWithContext_POST(r.Untyped.GetCtx(), id, body)
}

// ClusterAdvanced_GET_Model represents the response model for ClusterAdvanced
type ClusterAdvanced_GET_Model struct {
	NumberOfFilesAndDirectories int64   `json:"number_of_files_and_directories,omitempty" yaml:"number_of_files_and_directories,omitempty" required:"false" doc:"Number of files and directories"`
	NumberOfProtectedShares     int64   `json:"number_of_protected_shares,omitempty" yaml:"number_of_protected_shares,omitempty" required:"false" doc:"Number of protected shards"`
	NumberOfShares              int64   `json:"number_of_shares,omitempty" yaml:"number_of_shares,omitempty" required:"false" doc:"Number of shards"`
	NumberOfUnprotectedShares   int64   `json:"number_of_unprotected_shares,omitempty" yaml:"number_of_unprotected_shares,omitempty" required:"false" doc:"Number of unprotected shares"`
	ReadBandwidthInBytesPerSec  int64   `json:"read_bandwidth_in_bytes_per_sec,omitempty" yaml:"read_bandwidth_in_bytes_per_sec,omitempty" required:"false" doc:""`
	ReadIopsPerSec              int64   `json:"read_iops_per_sec,omitempty" yaml:"read_iops_per_sec,omitempty" required:"false" doc:""`
	ReadLatencyInMillisec       float64 `json:"read_latency_in_millisec,omitempty" yaml:"read_latency_in_millisec,omitempty" required:"false" doc:""`
	TotalCapacityInGib          float64 `json:"total_capacity_in_gib,omitempty" yaml:"total_capacity_in_gib,omitempty" required:"false" doc:"Total cluster capacity in GiB"`
	UsedCapacityInGib           float64 `json:"used_capacity_in_gib,omitempty" yaml:"used_capacity_in_gib,omitempty" required:"false" doc:"Used cluster capacity in GiB"`
	WriteBandwidthInBytesPerSec int64   `json:"write_bandwidth_in_bytes_per_sec,omitempty" yaml:"write_bandwidth_in_bytes_per_sec,omitempty" required:"false" doc:""`
	WriteIopsPerSec             int64   `json:"write_iops_per_sec,omitempty" yaml:"write_iops_per_sec,omitempty" required:"false" doc:""`
	WriteLatencyInMillisec      float64 `json:"write_latency_in_millisec,omitempty" yaml:"write_latency_in_millisec,omitempty" required:"false" doc:""`
}

// ClusterAdvancedWithContext_GET
// method: GET
// url: /clusters/{id}/advanced/
// summary: Aggregated information about the cluster
func (r *Cluster) ClusterAdvancedWithContext_GET(ctx context.Context, id any) (*ClusterAdvanced_GET_Model, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "advanced")

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterAdvanced_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterAdvanced_GET
// method: GET
// url: /clusters/{id}/advanced/
// summary: Aggregated information about the cluster
func (r *Cluster) ClusterAdvanced_GET(id any) (*ClusterAdvanced_GET_Model, error) {
	return r.ClusterAdvancedWithContext_GET(r.Untyped.GetCtx(), id)
}

// ClusterBgpTable_GET_Model represents the response model for ClusterBgpTable
type ClusterBgpTable_GET_Model struct {
	CnodeId     int64  `json:"cnode_id,omitempty" yaml:"cnode_id,omitempty" required:"false" doc:""`
	CnodeName   string `json:"cnode_name,omitempty" yaml:"cnode_name,omitempty" required:"false" doc:""`
	PeerAddress string `json:"peer_address,omitempty" yaml:"peer_address,omitempty" required:"false" doc:""`
	Port        string `json:"port,omitempty" yaml:"port,omitempty" required:"false" doc:""`
	RackId      int64  `json:"rack_id,omitempty" yaml:"rack_id,omitempty" required:"false" doc:""`
	RackName    string `json:"rack_name,omitempty" yaml:"rack_name,omitempty" required:"false" doc:""`
	SelfAddress string `json:"self_address,omitempty" yaml:"self_address,omitempty" required:"false" doc:""`
	State       string `json:"state,omitempty" yaml:"state,omitempty" required:"false" doc:""`
}

// ClusterBgpTableWithContext_GET
// method: GET
// url: /clusters/bgp_table/
// summary: Return BGP Connections Table
func (r *Cluster) ClusterBgpTableWithContext_GET(ctx context.Context) (*ClusterBgpTable_GET_Model, error) {
	resourcePath := "/clusters/bgp_table/"

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterBgpTable_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterBgpTable_GET
// method: GET
// url: /clusters/bgp_table/
// summary: Return BGP Connections Table
func (r *Cluster) ClusterBgpTable_GET() (*ClusterBgpTable_GET_Model, error) {
	return r.ClusterBgpTableWithContext_GET(r.Untyped.GetCtx())
}

// ClusterCeleryRemoveQueuedTaskWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/celery_remove_queued_task/
// summary: Delete all tasks of a specific name from the celery queue
func (r *Cluster) ClusterCeleryRemoveQueuedTaskWithContext_DELETE(ctx context.Context, id any) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "celery_remove_queued_task")

	var reqParams core.Params
	var reqBody core.Params

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// ClusterCeleryRemoveQueuedTask_DELETE
// method: DELETE
// url: /clusters/{id}/celery_remove_queued_task/
// summary: Delete all tasks of a specific name from the celery queue
func (r *Cluster) ClusterCeleryRemoveQueuedTask_DELETE(id any) error {
	return r.ClusterCeleryRemoveQueuedTaskWithContext_DELETE(r.Untyped.GetCtx(), id)
}

// ClusterCloseProtocolHandle_DELETE_Model represents the response model for ClusterCloseProtocolHandle
type ClusterCloseProtocolHandle_DELETE_Model struct {
	Error               string                                                     `json:"error,omitempty" yaml:"error,omitempty" required:"false" doc:""`
	FileHandle          ClusterCloseProtocolHandleModel_FileHandle                 `json:"file_handle,omitempty" yaml:"file_handle,omitempty" required:"false" doc:""`
	OpenProtocolHandles *[]ClusterCloseProtocolHandleModel_OpenProtocolHandlesItem `json:"open_protocol_handles,omitempty" yaml:"open_protocol_handles,omitempty" required:"false" doc:""`
}

// ClusterCloseProtocolHandleWithContext_DELETE
// method: DELETE
// url: /clusters/close_protocol_handle/
// summary: Close open protocol filehandles
func (r *Cluster) ClusterCloseProtocolHandleWithContext_DELETE(ctx context.Context) (*ClusterCloseProtocolHandle_DELETE_Model, error) {
	resourcePath := "/clusters/close_protocol_handle/"

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterCloseProtocolHandle_DELETE_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterCloseProtocolHandle_DELETE
// method: DELETE
// url: /clusters/close_protocol_handle/
// summary: Close open protocol filehandles
func (r *Cluster) ClusterCloseProtocolHandle_DELETE() (*ClusterCloseProtocolHandle_DELETE_Model, error) {
	return r.ClusterCloseProtocolHandleWithContext_DELETE(r.Untyped.GetCtx())
}

// ClusterDboxMigrationUpdateSourceTarget_GET_Model represents the response model for ClusterDboxMigrationUpdateSourceTarget
type ClusterDboxMigrationUpdateSourceTarget_GET_Model struct {
	SourceIds *[]int64 `json:"source_ids,omitempty" yaml:"source_ids,omitempty" required:"false" doc:""`
	TargetIds *[]int64 `json:"target_ids,omitempty" yaml:"target_ids,omitempty" required:"false" doc:""`
}

// ClusterDboxMigrationUpdateSourceTargetWithContext_GET
// method: GET
// url: /clusters/dbox_migration_update_source_target/
// summary: Dbox migration update source target info
func (r *Cluster) ClusterDboxMigrationUpdateSourceTargetWithContext_GET(ctx context.Context) (*ClusterDboxMigrationUpdateSourceTarget_GET_Model, error) {
	resourcePath := "/clusters/dbox_migration_update_source_target/"

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterDboxMigrationUpdateSourceTarget_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterDboxMigrationUpdateSourceTarget_GET
// method: GET
// url: /clusters/dbox_migration_update_source_target/
// summary: Dbox migration update source target info
func (r *Cluster) ClusterDboxMigrationUpdateSourceTarget_GET() (*ClusterDboxMigrationUpdateSourceTarget_GET_Model, error) {
	return r.ClusterDboxMigrationUpdateSourceTargetWithContext_GET(r.Untyped.GetCtx())
}

// ClusterDboxesTotalCapacity_GET_Body represents the request body for ClusterDboxesTotalCapacity
type ClusterDboxesTotalCapacity_GET_Body struct {
	Ids string `json:"ids,omitempty" yaml:"ids,omitempty" required:"false" doc:"DBox ids separated by comma"`
}

// ClusterDboxesTotalCapacity_GET_Model represents the response model for ClusterDboxesTotalCapacity
type ClusterDboxesTotalCapacity_GET_Model struct {
	NvramCapacity int64 `json:"nvram_capacity,omitempty" yaml:"nvram_capacity,omitempty" required:"false" doc:""`
	NvramNumber   int64 `json:"nvram_number,omitempty" yaml:"nvram_number,omitempty" required:"false" doc:""`
	SsdCapacity   int64 `json:"ssd_capacity,omitempty" yaml:"ssd_capacity,omitempty" required:"false" doc:""`
	SsdNumber     int64 `json:"ssd_number,omitempty" yaml:"ssd_number,omitempty" required:"false" doc:""`
}

// ClusterDboxesTotalCapacityWithContext_GET
// method: GET
// url: /clusters/dboxes_total_capacity/
// summary: DBoxes total capacity
func (r *Cluster) ClusterDboxesTotalCapacityWithContext_GET(ctx context.Context, params *ClusterDboxesTotalCapacity_GET_Body) (*ClusterDboxesTotalCapacity_GET_Model, error) {
	resourcePath := "/clusters/dboxes_total_capacity/"

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterDboxesTotalCapacity_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterDboxesTotalCapacity_GET
// method: GET
// url: /clusters/dboxes_total_capacity/
// summary: DBoxes total capacity
func (r *Cluster) ClusterDboxesTotalCapacity_GET(params *ClusterDboxesTotalCapacity_GET_Body) (*ClusterDboxesTotalCapacity_GET_Model, error) {
	return r.ClusterDboxesTotalCapacityWithContext_GET(r.Untyped.GetCtx(), params)
}

// ClusterDeleteFolderWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/delete_folder/
// summary: Delete Cluster Folder
//
// Parameters:
//   - path (body): Folder path to delete
//   - tenantId (body): Tenant ID
func (r *Cluster) ClusterDeleteFolderWithContext_DELETE(ctx context.Context, id any, path string, tenantId int64) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "delete_folder")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["path"] = path
	if tenantId != 0 {
		reqBody["tenant_id"] = tenantId
	}

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// ClusterDeleteFolder_DELETE
// method: DELETE
// url: /clusters/{id}/delete_folder/
// summary: Delete Cluster Folder
//
// Parameters:
//   - path (body): Folder path to delete
//   - tenantId (body): Tenant ID
func (r *Cluster) ClusterDeleteFolder_DELETE(id any, path string, tenantId int64) error {
	return r.ClusterDeleteFolderWithContext_DELETE(r.Untyped.GetCtx(), id, path, tenantId)
}

// ClusterExpandWithContext_POST
// method: POST
// url: /clusters/{id}/expand/
// summary: Expand Cluster
//
// Parameters:
//   - devicesMock (body): Devices Mock for NVRAM section layout (only for loopback)
//   - nvramSectionLayout (body): NVRAM section layout
//   - skipLayoutValidation (body): skip layout validation
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterExpandWithContext_POST(ctx context.Context, id any, devicesMock string, nvramSectionLayout string, skipLayoutValidation string, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "expand")

	var reqParams core.Params
	reqBody := core.Params{}
	if devicesMock != "" {
		reqBody["devices_mock"] = devicesMock
	}
	if nvramSectionLayout != "" {
		reqBody["nvram_section_layout"] = nvramSectionLayout
	}
	if skipLayoutValidation != "" {
		reqBody["skip_layout_validation"] = skipLayoutValidation
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterExpand_POST
// method: POST
// url: /clusters/{id}/expand/
// summary: Expand Cluster
//
// Parameters:
//   - devicesMock (body): Devices Mock for NVRAM section layout (only for loopback)
//   - nvramSectionLayout (body): NVRAM section layout
//   - skipLayoutValidation (body): skip layout validation
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterExpand_POST(id any, devicesMock string, nvramSectionLayout string, skipLayoutValidation string, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterExpandWithContext_POST(r.Untyped.GetCtx(), id, devicesMock, nvramSectionLayout, skipLayoutValidation, waitTimeout)
}

// ClusterGenerateUnfreezeToken_POST_Model represents the response model for ClusterGenerateUnfreezeToken
type ClusterGenerateUnfreezeToken_POST_Model struct {
	Name           string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:"Token name"`
	ExpirationTime string `json:"expiration_time,omitempty" yaml:"expiration_time,omitempty" required:"false" doc:"Token expiration time"`
	Guid           string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	Id             int64  `json:"id,omitempty" yaml:"id,omitempty" required:"false" doc:""`
	Password       string `json:"password,omitempty" yaml:"password,omitempty" required:"false" doc:""`
	Token          string `json:"token,omitempty" yaml:"token,omitempty" required:"false" doc:"Token value"`
}

// ClusterGenerateUnfreezeTokenWithContext_POST
// method: POST
// url: /clusters/{id}/generate_unfreeze_token/
// summary: Generate Token to Unlock Indestructibility
//
// Parameters:
//   - password (body): Unfreeze password
func (r *Cluster) ClusterGenerateUnfreezeTokenWithContext_POST(ctx context.Context, id any, password string) (*ClusterGenerateUnfreezeToken_POST_Model, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "generate_unfreeze_token")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["password"] = password

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterGenerateUnfreezeToken_POST_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterGenerateUnfreezeToken_POST
// method: POST
// url: /clusters/{id}/generate_unfreeze_token/
// summary: Generate Token to Unlock Indestructibility
//
// Parameters:
//   - password (body): Unfreeze password
func (r *Cluster) ClusterGenerateUnfreezeToken_POST(id any, password string) (*ClusterGenerateUnfreezeToken_POST_Model, error) {
	return r.ClusterGenerateUnfreezeTokenWithContext_POST(r.Untyped.GetCtx(), id, password)
}

// ClusterListOpenProtocolHandles_GET_Body represents the request body for ClusterListOpenProtocolHandles
type ClusterListOpenProtocolHandles_GET_Body struct {
	FilePath   string `json:"file_path,omitempty" yaml:"file_path,omitempty" required:"false" doc:"File path"`
	TenantGuid string `json:"tenant_guid,omitempty" yaml:"tenant_guid,omitempty" required:"false" doc:"Tenant GUID"`
}

// ClusterListOpenProtocolHandles_GET_Model represents the response model for ClusterListOpenProtocolHandles
type ClusterListOpenProtocolHandles_GET_Model struct {
	Error               string                                                         `json:"error,omitempty" yaml:"error,omitempty" required:"false" doc:""`
	FileHandle          ClusterListOpenProtocolHandlesModel_FileHandle                 `json:"file_handle,omitempty" yaml:"file_handle,omitempty" required:"false" doc:""`
	OpenProtocolHandles *[]ClusterListOpenProtocolHandlesModel_OpenProtocolHandlesItem `json:"open_protocol_handles,omitempty" yaml:"open_protocol_handles,omitempty" required:"false" doc:""`
}

// ClusterListOpenProtocolHandlesWithContext_GET
// method: GET
// url: /clusters/list_open_protocol_handles/
// summary: Query open protocol filehandles
func (r *Cluster) ClusterListOpenProtocolHandlesWithContext_GET(ctx context.Context, params *ClusterListOpenProtocolHandles_GET_Body) (*ClusterListOpenProtocolHandles_GET_Model, error) {
	resourcePath := "/clusters/list_open_protocol_handles/"

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterListOpenProtocolHandles_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterListOpenProtocolHandles_GET
// method: GET
// url: /clusters/list_open_protocol_handles/
// summary: Query open protocol filehandles
func (r *Cluster) ClusterListOpenProtocolHandles_GET(params *ClusterListOpenProtocolHandles_GET_Body) (*ClusterListOpenProtocolHandles_GET_Model, error) {
	return r.ClusterListOpenProtocolHandlesWithContext_GET(r.Untyped.GetCtx(), params)
}

// ClusterListPrefetchPathsInfo_GET_Model represents the response model for ClusterListPrefetchPathsInfo
type ClusterListPrefetchPathsInfo_GET_Model struct {
	PrefetchData *[]ClusterListPrefetchPathsInfoModel_PrefetchDataItem `json:"prefetch_data,omitempty" yaml:"prefetch_data,omitempty" required:"false" doc:""`
	StaleTasks   *[]int64                                              `json:"stale_tasks,omitempty" yaml:"stale_tasks,omitempty" required:"false" doc:""`
}

// ClusterListPrefetchPathsInfoWithContext_GET
// method: GET
// url: /clusters/list_prefetch_paths_info/
// summary: List Prefetch Path Information
func (r *Cluster) ClusterListPrefetchPathsInfoWithContext_GET(ctx context.Context) (*ClusterListPrefetchPathsInfo_GET_Model, error) {
	resourcePath := "/clusters/list_prefetch_paths_info/"

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterListPrefetchPathsInfo_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterListPrefetchPathsInfo_GET
// method: GET
// url: /clusters/list_prefetch_paths_info/
// summary: List Prefetch Path Information
func (r *Cluster) ClusterListPrefetchPathsInfo_GET() (*ClusterListPrefetchPathsInfo_GET_Model, error) {
	return r.ClusterListPrefetchPathsInfoWithContext_GET(r.Untyped.GetCtx())
}

// ClusterReleaseRecursiveLocks_DELETE_Body represents the request body for ClusterReleaseRecursiveLocks
type ClusterReleaseRecursiveLocks_DELETE_Body struct {
	LockType   string `json:"lock_type,omitempty" yaml:"lock_type,omitempty" required:"false" doc:"Lock type. Specify if unlock_type is SINGLE."`
	Path       string `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:"The full path to a locked file, formed as: VIEW_PATH/FILE_PATH, where VIEW_PATH is the VAST Cluster view path, and FILE_PATH is the client path to a locked file, relative to the mount point."`
	TenantId   int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:""`
	UnlockId   string `json:"unlock_id,omitempty" yaml:"unlock_id,omitempty" required:"false" doc:"Unlock ID. Specify if unlock_type is SINGLE."`
	UnlockType string `json:"unlock_type,omitempty" yaml:"unlock_type,omitempty" required:"false" doc:"The type of unlock operation to perform. 'SINGLE' unlocks a single specified lock, 'ALL' unlocks all locks."`
}

// ClusterReleaseRecursiveLocksWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/release_recursive_locks/
// summary: Deletes NLM Locks Recursively
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterReleaseRecursiveLocksWithContext_DELETE(ctx context.Context, id any, body *ClusterReleaseRecursiveLocks_DELETE_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "release_recursive_locks")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterReleaseRecursiveLocks_DELETE
// method: DELETE
// url: /clusters/{id}/release_recursive_locks/
// summary: Deletes NLM Locks Recursively
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterReleaseRecursiveLocks_DELETE(id any, body *ClusterReleaseRecursiveLocks_DELETE_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterReleaseRecursiveLocksWithContext_DELETE(r.Untyped.GetCtx(), id, body, waitTimeout)
}

// ClusterRotateMasterEncryptionGroupKeyWithContext_POST
// method: POST
// url: /clusters/rotate_master_encryption_group_key/
// summary: Rotate master encryption group key.
func (r *Cluster) ClusterRotateMasterEncryptionGroupKeyWithContext_POST(ctx context.Context) error {
	resourcePath := "/clusters/rotate_master_encryption_group_key/"

	var reqParams core.Params
	var reqBody core.Params

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	return err

}

// ClusterRotateMasterEncryptionGroupKey_POST
// method: POST
// url: /clusters/rotate_master_encryption_group_key/
// summary: Rotate master encryption group key.
func (r *Cluster) ClusterRotateMasterEncryptionGroupKey_POST() error {
	return r.ClusterRotateMasterEncryptionGroupKeyWithContext_POST(r.Untyped.GetCtx())
}

// ClusterRunHardwareCheck_PATCH_Body represents the request body for ClusterRunHardwareCheck
type ClusterRunHardwareCheck_PATCH_Body struct {
	BmcUpgrade        bool `json:"bmc_upgrade,omitempty" yaml:"bmc_upgrade,omitempty" required:"false" doc:"is bmc upgrade"`
	Force             bool `json:"force,omitempty" yaml:"force,omitempty" required:"false" doc:"force"`
	SkipHwCheck       bool `json:"skip_hw_check,omitempty" yaml:"skip_hw_check,omitempty" required:"false" doc:"Skip hardware related checks"`
	SkipOsUpgrade     bool `json:"skip_os_upgrade,omitempty" yaml:"skip_os_upgrade,omitempty" required:"false" doc:"skip os upgrade related checks"`
	SkipSwValidations bool `json:"skip_sw_validations,omitempty" yaml:"skip_sw_validations,omitempty" required:"false" doc:"Skip SW validations"`
}

// ClusterRunHardwareCheckWithContext_PATCH
// method: PATCH
// url: /clusters/run_hardware_check/
// summary: Run Hardware Validations
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterRunHardwareCheckWithContext_PATCH(ctx context.Context, body *ClusterRunHardwareCheck_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := "/clusters/run_hardware_check/"

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterRunHardwareCheck_PATCH
// method: PATCH
// url: /clusters/run_hardware_check/
// summary: Run Hardware Validations
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterRunHardwareCheck_PATCH(body *ClusterRunHardwareCheck_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterRunHardwareCheckWithContext_PATCH(r.Untyped.GetCtx(), body, waitTimeout)
}

// ClusterSetCertificates_POST_Body represents the request body for ClusterSetCertificates
type ClusterSetCertificates_POST_Body struct {
	EkmAuthDomain       string `json:"ekm_auth_domain,omitempty" yaml:"ekm_auth_domain,omitempty" required:"false" doc:"Auth domain (Thales)"`
	EkmBypassValidation bool   `json:"ekm_bypass_validation,omitempty" yaml:"ekm_bypass_validation,omitempty" required:"false" doc:"Bypass key and cert validation (VMS)"`
	EkmCaCertificate    string `json:"ekm_ca_certificate,omitempty" yaml:"ekm_ca_certificate,omitempty" required:"false" doc:"EKM CA certificate"`
	EkmCertificate      string `json:"ekm_certificate,omitempty" yaml:"ekm_certificate,omitempty" required:"false" doc:"EKM certificate"`
	EkmDomain           string `json:"ekm_domain,omitempty" yaml:"ekm_domain,omitempty" required:"false" doc:"Domain (Thales)"`
	EkmPrivateKey       string `json:"ekm_private_key,omitempty" yaml:"ekm_private_key,omitempty" required:"false" doc:"EKM private key"`
	EkmProxyAddress     string `json:"ekm_proxy_address,omitempty" yaml:"ekm_proxy_address,omitempty" required:"false" doc:"Thales EKM proxy address: https://proxy-address:port"`
	EkmServers          string `json:"ekm_servers,omitempty" yaml:"ekm_servers,omitempty" required:"false" doc:"List of EKM servers: 10.0.0.1:5696,11.0.0.1:5697"`
	EncryptionType      string `json:"encryption_type,omitempty" yaml:"encryption_type,omitempty" required:"false" doc:"Encryption type"`
}

// ClusterSetCertificatesWithContext_POST
// method: POST
// url: /clusters/{id}/set_certificates/
// summary: Update EKM certificates
func (r *Cluster) ClusterSetCertificatesWithContext_POST(ctx context.Context, id any, body *ClusterSetCertificates_POST_Body) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "set_certificates")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return err
	}

	_, err = core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	return err

}

// ClusterSetCertificates_POST
// method: POST
// url: /clusters/{id}/set_certificates/
// summary: Update EKM certificates
func (r *Cluster) ClusterSetCertificates_POST(id any, body *ClusterSetCertificates_POST_Body) error {
	return r.ClusterSetCertificatesWithContext_POST(r.Untyped.GetCtx(), id, body)
}

// ClusterSetPasswordWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/set_password/
// summary: Change Cluster Passwords
//
// Parameters:
//   - password (body): The new given password
//   - username (body): The given username for password change
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterSetPasswordWithContext_PATCH(ctx context.Context, id any, password string, username string, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "set_password")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["password"] = password
	reqBody["username"] = username

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterSetPassword_PATCH
// method: PATCH
// url: /clusters/{id}/set_password/
// summary: Change Cluster Passwords
//
// Parameters:
//   - password (body): The new given password
//   - username (body): The given username for password change
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterSetPassword_PATCH(id any, password string, username string, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterSetPasswordWithContext_PATCH(r.Untyped.GetCtx(), id, password, username, waitTimeout)
}

// ClusterStopUpgradeWithContext_POST
// method: POST
// url: /clusters/{id}/stop_upgrade/
// summary: Stop Running Upgrade
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterStopUpgradeWithContext_POST(ctx context.Context, id any, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "stop_upgrade")

	var reqParams core.Params
	var reqBody core.Params

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterStopUpgrade_POST
// method: POST
// url: /clusters/{id}/stop_upgrade/
// summary: Stop Running Upgrade
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterStopUpgrade_POST(id any, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterStopUpgradeWithContext_POST(r.Untyped.GetCtx(), id, waitTimeout)
}

// ClusterSystemSettingsWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/system_settings/
// summary: Set Cluster System Settings
//
// Parameters:
//   - settings (body): system settings to modify
func (r *Cluster) ClusterSystemSettingsWithContext_PATCH(ctx context.Context, id any, settings string) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "system_settings")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["settings"] = settings

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	return err

}

// ClusterSystemSettings_PATCH
// method: PATCH
// url: /clusters/{id}/system_settings/
// summary: Set Cluster System Settings
//
// Parameters:
//   - settings (body): system settings to modify
func (r *Cluster) ClusterSystemSettings_PATCH(id any, settings string) error {
	return r.ClusterSystemSettingsWithContext_PATCH(r.Untyped.GetCtx(), id, settings)
}

// ClusterUnfreezeWithContext_POST
// method: POST
// url: /clusters/{id}/unfreeze/
// summary: Unfreeze Cluster
//
// Parameters:
//   - token (body): Token
func (r *Cluster) ClusterUnfreezeWithContext_POST(ctx context.Context, id any, token string) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "unfreeze")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["token"] = token

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	return err

}

// ClusterUnfreeze_POST
// method: POST
// url: /clusters/{id}/unfreeze/
// summary: Unfreeze Cluster
//
// Parameters:
//   - token (body): Token
func (r *Cluster) ClusterUnfreeze_POST(id any, token string) error {
	return r.ClusterUnfreezeWithContext_POST(r.Untyped.GetCtx(), id, token)
}

// ClusterUpgradeOptaneWithContext_POST
// method: POST
// url: /clusters/{id}/upgrade_optane/
// summary: Upgrade Optane NVRAM
//
// Parameters:
//   - force (body): Force upgrade regardless of version
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeOptaneWithContext_POST(ctx context.Context, id any, force bool, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade_optane")

	var reqParams core.Params
	reqBody := core.Params{}
	if force {
		reqBody["force"] = force
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterUpgradeOptane_POST
// method: POST
// url: /clusters/{id}/upgrade_optane/
// summary: Upgrade Optane NVRAM
//
// Parameters:
//   - force (body): Force upgrade regardless of version
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeOptane_POST(id any, force bool, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterUpgradeOptaneWithContext_POST(r.Untyped.GetCtx(), id, force, waitTimeout)
}

// ClusterUpgradeSsdWithContext_POST
// method: POST
// url: /clusters/{id}/upgrade_ssd/
// summary: Upgrade SSD
//
// Parameters:
//   - force (body): Forces upgrade regardless of version
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeSsdWithContext_POST(ctx context.Context, id any, force bool, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade_ssd")

	var reqParams core.Params
	reqBody := core.Params{}
	if force {
		reqBody["force"] = force
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterUpgradeSsd_POST
// method: POST
// url: /clusters/{id}/upgrade_ssd/
// summary: Upgrade SSD
//
// Parameters:
//   - force (body): Forces upgrade regardless of version
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeSsd_POST(id any, force bool, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterUpgradeSsdWithContext_POST(r.Untyped.GetCtx(), id, force, waitTimeout)
}

// ClusterUpgradeWithoutFile_POST_Body represents the request body for ClusterUpgradeWithoutFile
type ClusterUpgradeWithoutFile_POST_Body struct {
	EnableDr                  bool    `json:"enable_dr" yaml:"enable_dr" required:"true" doc:"Enables data reduction (DR) for a cluster without DR enabled prior to upgrade"`
	Force                     bool    `json:"force" yaml:"force" required:"true" doc:"Forces upgrade regardless of version or upgrade state"`
	BmcUpgrade                bool    `json:"bmc_upgrade,omitempty" yaml:"bmc_upgrade,omitempty" required:"false" doc:"BMC upgrade"`
	CnodesBatchSizePercentage int64   `json:"cnodes_batch_size_percentage,omitempty" yaml:"cnodes_batch_size_percentage,omitempty" required:"false" doc:"Overrides default percentage of CNodes to upgrade in parallel. Max 50"`
	DnodesBatchSizePercentage float32 `json:"dnodes_batch_size_percentage,omitempty" yaml:"dnodes_batch_size_percentage,omitempty" required:"false" doc:"Overrides default percentage of DNodes to upgrade in parallel. Max 37.5. Not relevant during os upgrade"`
	DpusBatchSizePercentage   float32 `json:"dpus_batch_size_percentage,omitempty" yaml:"dpus_batch_size_percentage,omitempty" required:"false" doc:"Overrides default percentage of DPUs to upgrade in parallel. Max 37.5."`
	DrivesFwUpgrade           bool    `json:"drives_fw_upgrade,omitempty" yaml:"drives_fw_upgrade,omitempty" required:"false" doc:"Upgrade FW for SSD/SCMs exclusively"`
	FwUpgrade                 bool    `json:"fw_upgrade,omitempty" yaml:"fw_upgrade,omitempty" required:"false" doc:"Upgrade FWs: BMC, MCU, PCI, NIC"`
	Isolcpus                  bool    `json:"isolcpus,omitempty" yaml:"isolcpus,omitempty" required:"false" doc:"Resets the configuration of isolated CPUs according to a formula"`
	OsUpgrade                 bool    `json:"os_upgrade,omitempty" yaml:"os_upgrade,omitempty" required:"false" doc:"Performs OS upgrade on CNodes and DNodes in addition to upgrading core platform build"`
	SkipHwCheck               bool    `json:"skip_hw_check,omitempty" yaml:"skip_hw_check,omitempty" required:"false" doc:"Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade."`
	SkipSwValidations         bool    `json:"skip_sw_validations,omitempty" yaml:"skip_sw_validations,omitempty" required:"false" doc:"Skips SW validations (e.g. deny list)"`
	VmsOnlyUpgrade            bool    `json:"vms_only_upgrade,omitempty" yaml:"vms_only_upgrade,omitempty" required:"false" doc:"Forces upgrade of VMS only"`
}

// ClusterUpgradeWithoutFileWithContext_POST
// method: POST
// url: /clusters/{id}/upgrade_without_file/
// summary: Upgrade Cluster from Pre-Uploaded Bundle
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeWithoutFileWithContext_POST(ctx context.Context, id any, body *ClusterUpgradeWithoutFile_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade_without_file")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterUpgradeWithoutFile_POST
// method: POST
// url: /clusters/{id}/upgrade_without_file/
// summary: Upgrade Cluster from Pre-Uploaded Bundle
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeWithoutFile_POST(id any, body *ClusterUpgradeWithoutFile_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterUpgradeWithoutFileWithContext_POST(r.Untyped.GetCtx(), id, body, waitTimeout)
}

// ClusterUpgrade_PATCH_Body represents the request body for ClusterUpgrade
type ClusterUpgrade_PATCH_Body struct {
	Build             string `json:"build,omitempty" yaml:"build,omitempty" required:"true" doc:"Specifies the build for upgrade"`
	BmcUpgrade        bool   `json:"bmc_upgrade,omitempty" yaml:"bmc_upgrade,omitempty" required:"false" doc:"BMC upgrade"`
	DrivesFwUpgrade   bool   `json:"drives_fw_upgrade,omitempty" yaml:"drives_fw_upgrade,omitempty" required:"false" doc:"Exclusive flag to perform SSD/SCM FW upgrade"`
	EnableDr          bool   `json:"enable_dr,omitempty" yaml:"enable_dr,omitempty" required:"false" doc:"Enables data reduction (DR) for a cluster without DR enabled prior to upgrade"`
	Force             bool   `json:"force,omitempty" yaml:"force,omitempty" required:"false" doc:"Forces upgrade regardless of version or upgrade state"`
	OsUpgrade         bool   `json:"os_upgrade,omitempty" yaml:"os_upgrade,omitempty" required:"false" doc:"OS upgrade"`
	Prepare           bool   `json:"prepare,omitempty" yaml:"prepare,omitempty" required:"false" doc:"Pull docker images only"`
	SkipHwCheck       bool   `json:"skip_hw_check,omitempty" yaml:"skip_hw_check,omitempty" required:"false" doc:"Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade."`
	SkipSwValidations bool   `json:"skip_sw_validations,omitempty" yaml:"skip_sw_validations,omitempty" required:"false" doc:"Skips SW validations (e.g. deny list)"`
}

// ClusterUpgradeWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/upgrade/
// summary: Upgrade Cluster
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgradeWithContext_PATCH(ctx context.Context, id any, body *ClusterUpgrade_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterUpgrade_PATCH
// method: PATCH
// url: /clusters/{id}/upgrade/
// summary: Upgrade Cluster
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUpgrade_PATCH(id any, body *ClusterUpgrade_PATCH_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterUpgradeWithContext_PATCH(r.Untyped.GetCtx(), id, body, waitTimeout)
}

// ClusterUploadFromS3_POST_Body represents the request body for ClusterUploadFromS3
type ClusterUploadFromS3_POST_Body struct {
	S3Url             string `json:"s3_url,omitempty" yaml:"s3_url,omitempty" required:"false" doc:"S3 URL to upgrade package. If not provided, will be taken from db"`
	SkipHwCheck       bool   `json:"skip_hw_check,omitempty" yaml:"skip_hw_check,omitempty" required:"false" doc:"Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade."`
	SkipPrepare       bool   `json:"skip_prepare,omitempty" yaml:"skip_prepare,omitempty" required:"false" doc:"Skips preparing the cluster for upgrade, including: pre-upgrade validations, copying the bundle to other hosts, and pulling the image on all CNodes."`
	SkipSwValidations bool   `json:"skip_sw_validations,omitempty" yaml:"skip_sw_validations,omitempty" required:"false" doc:"Skips SW validations (e.g. deny list)"`
}

// ClusterUploadFromS3WithContext_POST
// method: POST
// url: /clusters/{id}/upload_from_s3/
// summary: Upload Upgrade Bundle from S3 URL
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUploadFromS3WithContext_POST(ctx context.Context, id any, body *ClusterUploadFromS3_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upload_from_s3")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterUploadFromS3_POST
// method: POST
// url: /clusters/{id}/upload_from_s3/
// summary: Upload Upgrade Bundle from S3 URL
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterUploadFromS3_POST(id any, body *ClusterUploadFromS3_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterUploadFromS3WithContext_POST(r.Untyped.GetCtx(), id, body, waitTimeout)
}

// ClusterVastDb_GET_Model represents the response model for ClusterVastDb
type ClusterVastDb_GET_Model struct {
	VastDbSplits    int64 `json:"vast_db_splits,omitempty" yaml:"vast_db_splits,omitempty" required:"true" doc:"Number of splits used for query_data scanning speed. Default 8."`
	VastDbSubSplits int64 `json:"vast_db_sub_splits,omitempty" yaml:"vast_db_sub_splits,omitempty" required:"true" doc:"Number of sub-splits used for query_data scanning speed. Default 8."`
}

// ClusterVastDbWithContext_GET
// method: GET
// url: /clusters/{id}/vast_db/
// summary: Show Cluster Vast DB Settings
func (r *Cluster) ClusterVastDbWithContext_GET(ctx context.Context, id any) (*ClusterVastDb_GET_Model, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vast_db")

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterVastDb_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterVastDb_GET
// method: GET
// url: /clusters/{id}/vast_db/
// summary: Show Cluster Vast DB Settings
func (r *Cluster) ClusterVastDb_GET(id any) (*ClusterVastDb_GET_Model, error) {
	return r.ClusterVastDbWithContext_GET(r.Untyped.GetCtx(), id)
}

// ClusterVastDb_PATCH_Model represents the response model for ClusterVastDb
type ClusterVastDb_PATCH_Model struct {
	VastDbSplits    int64 `json:"vast_db_splits,omitempty" yaml:"vast_db_splits,omitempty" required:"true" doc:"Number of splits used for query_data scanning speed. Default 8."`
	VastDbSubSplits int64 `json:"vast_db_sub_splits,omitempty" yaml:"vast_db_sub_splits,omitempty" required:"true" doc:"Number of sub-splits used for query_data scanning speed. Default 8."`
}

// ClusterVastDbWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/vast_db/
// summary: Modify Cluster Vast DB Settings
//
// Parameters:
//   - vastDbSplits (body): The number of splits used for query_data scanning speed. Default 8.
//   - vastDbSubSplits (body): The number of sub-splits used for query_data scanning speed. Default 8.
func (r *Cluster) ClusterVastDbWithContext_PATCH(ctx context.Context, id any, vastDbSplits int64, vastDbSubSplits int64) (*ClusterVastDb_PATCH_Model, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vast_db")

	var reqParams core.Params
	reqBody := core.Params{}
	if vastDbSplits != 0 {
		reqBody["vast_db_splits"] = vastDbSplits
	}
	if vastDbSubSplits != 0 {
		reqBody["vast_db_sub_splits"] = vastDbSubSplits
	}

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ClusterVastDb_PATCH_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ClusterVastDb_PATCH
// method: PATCH
// url: /clusters/{id}/vast_db/
// summary: Modify Cluster Vast DB Settings
//
// Parameters:
//   - vastDbSplits (body): The number of splits used for query_data scanning speed. Default 8.
//   - vastDbSubSplits (body): The number of sub-splits used for query_data scanning speed. Default 8.
func (r *Cluster) ClusterVastDb_PATCH(id any, vastDbSplits int64, vastDbSubSplits int64) (*ClusterVastDb_PATCH_Model, error) {
	return r.ClusterVastDbWithContext_PATCH(r.Untyped.GetCtx(), id, vastDbSplits, vastDbSubSplits)
}

// ClusterVsettingsWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/vsettings/
// summary: Delete Cluster VSetting by key
//
// Parameters:
//   - key (body): vsetting key
func (r *Cluster) ClusterVsettingsWithContext_DELETE(ctx context.Context, id any, key string) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vsettings")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["key"] = key

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// ClusterVsettings_DELETE
// method: DELETE
// url: /clusters/{id}/vsettings/
// summary: Delete Cluster VSetting by key
//
// Parameters:
//   - key (body): vsetting key
func (r *Cluster) ClusterVsettings_DELETE(id any, key string) error {
	return r.ClusterVsettingsWithContext_DELETE(r.Untyped.GetCtx(), id, key)
}

// ClusterVsettings_PATCH_Body represents the request body for ClusterVsettings
type ClusterVsettings_PATCH_Body struct {
	Vsettings map[string]string `json:"vsettings,omitempty" yaml:"vsettings,omitempty" required:"true" doc:""`
}

// ClusterVsettingsWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/vsettings/
// summary: Modify Cluster VSettings
func (r *Cluster) ClusterVsettingsWithContext_PATCH(ctx context.Context, id any, body *ClusterVsettings_PATCH_Body) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vsettings")

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return err
	}

	_, err = core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	return err

}

// ClusterVsettings_PATCH
// method: PATCH
// url: /clusters/{id}/vsettings/
// summary: Modify Cluster VSettings
func (r *Cluster) ClusterVsettings_PATCH(id any, body *ClusterVsettings_PATCH_Body) error {
	return r.ClusterVsettingsWithContext_PATCH(r.Untyped.GetCtx(), id, body)
}

// ClusterWipe_POST_Body represents the request body for ClusterWipe
type ClusterWipe_POST_Body struct {
	CnodeList    *[]ClusterWipeBody_CnodeListItem `json:"cnode_list,omitempty" yaml:"cnode_list,omitempty" required:"false" doc:"The list of C-Nodes"`
	DnodeList    *[]ClusterWipeBody_DnodeListItem `json:"dnode_list,omitempty" yaml:"dnode_list,omitempty" required:"false" doc:"The list of DNodes"`
	Loopback     bool                             `json:"loopback,omitempty" yaml:"loopback,omitempty" required:"false" doc:"Loopback (single node) installation"`
	LoopbackIp   string                           `json:"loopback_ip,omitempty" yaml:"loopback_ip,omitempty" required:"false" doc:"Loopback IP"`
	LoopbackUser string                           `json:"loopback_user,omitempty" yaml:"loopback_user,omitempty" required:"false" doc:"Loopback User"`
}

// ClusterWipeWithContext_POST
// method: POST
// url: /clusters/wipe/
// summary: Stop Cluster s/w on All Nodes
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterWipeWithContext_POST(ctx context.Context, body *ClusterWipe_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	resourcePath := "/clusters/wipe/"

	var reqParams core.Params
	reqBody, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	result, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	asyncResult, _, err := untyped.MaybeWaitAsyncResultWithContext(ctx, result, r.Untyped, waitTimeout)
	return asyncResult, err

}

// ClusterWipe_POST
// method: POST
// url: /clusters/wipe/
// summary: Stop Cluster s/w on All Nodes
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (r *Cluster) ClusterWipe_POST(body *ClusterWipe_POST_Body, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.ClusterWipeWithContext_POST(r.Untyped.GetCtx(), body, waitTimeout)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - Extra method GET /clusters/dbox_migration_status/ skipped: GET /clusters/dbox_migration_status/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/dbox_migration_validate/ skipped: GET /clusters/dbox_migration_validate/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/dbox_migration_validate_state/ skipped: GET /clusters/dbox_migration_validate_state/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/get_shard_expansion_status/ skipped: GET /clusters/get_shard_expansion_status/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/get_snapshoted_paths/ skipped: GET /clusters/get_snapshoted_paths/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/list_clone_snapshoted_paths_remote/ skipped: GET /clusters/list_clone_snapshoted_paths_remote/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/list_smb_client_connections/ skipped: GET /clusters/list_smb_client_connections/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/list_smb_open_files/ skipped: GET /clusters/list_smb_open_files/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/list_snapshoted_paths_remote/ skipped: GET /clusters/list_snapshoted_paths_remote/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/list_tenants_remote/ skipped: GET /clusters/list_tenants_remote/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/auditing/ skipped: GET /clusters/{id}/auditing/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/celery_queue/ skipped: GET /clusters/{id}/celery_queue/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/celery_reserved/ skipped: GET /clusters/{id}/celery_reserved/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/celery_scheduled/ skipped: GET /clusters/{id}/celery_scheduled/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/celery_status/ skipped: GET /clusters/{id}/celery_status/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/pre_upgrade_validation_exceptions/ skipped: GET /clusters/{id}/pre_upgrade_validation_exceptions/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method GET /clusters/{id}/vsettings/ skipped: GET /clusters/{id}/vsettings/ - Response is a map-like object (additionalProperties: string). Typed methods do not support map return types
//   - Extra method PATCH /clusters/block_providers/ skipped: PATCH /clusters/block_providers/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /clusters/block_providers/
//   - Extra method PATCH /clusters/dbox_migration_update_source_target/ skipped: PATCH /clusters/dbox_migration_update_source_target/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method PATCH /clusters/{id}/auditing/ skipped: PATCH /clusters/{id}/auditing/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method PATCH /clusters/{id}/resume_deploy/ skipped: PATCH /clusters/{id}/resume_deploy/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method PATCH /clusters/{id}/rpc/ skipped: PATCH /clusters/{id}/rpc/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method POST /clusters/dbox_migration/ skipped: POST /clusters/dbox_migration/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method POST /clusters/shard_expand/ skipped: POST /clusters/shard_expand/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - Extra method POST /clusters/{id}/locks/ skipped: POST /clusters/{id}/locks/ - Array item schema is ambiguous or empty
//   - Extra method POST /clusters/{id}/notify_new_version/ skipped: POST /clusters/{id}/notify_new_version/ - No response schema defined in OpenAPI spec. Error: no valid schema found in POST response (200/201/202/204) for resource /clusters/{id}/notify_new_version/
//   - Extra method POST /clusters/{id}/set_drive_fw_upgrade/ skipped: POST /clusters/{id}/set_drive_fw_upgrade/ - No response schema defined in OpenAPI spec. Error: no valid schema found in POST response (200/201/202/204) for resource /clusters/{id}/set_drive_fw_upgrade/
