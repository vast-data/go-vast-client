// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|DELETE

package typed

import (
	"context"
	"net/http"

	"github.com/vast-data/go-vast-client/core"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// Ldap represents a typed resource for ldap operations
type Ldap struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// LdapSearchParams represents the search parameters for Ldap operations
type LdapSearchParams struct {
	Guid     string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:""`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:""`
	TenantId int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Tenant ID"`
	Uid      string `json:"uid,omitempty" yaml:"uid,omitempty" required:"false" doc:""`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &LdapSearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// LdapRequestBody represents the request body for Ldap operations
type LdapRequestBody struct {
	Searchbase                 string    `json:"searchbase,omitempty" yaml:"searchbase,omitempty" required:"true" doc:"The entry in the LDAP directory tree to use as a starting point for user queries."`
	Urls                       *[]string `json:"urls,omitempty" yaml:"urls,omitempty" required:"true" doc:"Comma separated list of URIs of LDAP servers in the format SCHEME://ADDRESS. The order of listing defines the priority order. The URI with highest priority that has a good health status is used."`
	AbacReadOnlyValueName      string    `json:"abac_read_only_value_name,omitempty" yaml:"abac_read_only_value_name,omitempty" required:"false" doc:"The attribute to use when querying a provider for a read only attribute access check."`
	AbacReadWriteValueName     string    `json:"abac_read_write_value_name,omitempty" yaml:"abac_read_write_value_name,omitempty" required:"false" doc:"The attribute to use when querying a provider for a read-write attribute access check."`
	AdvancedFilter             string    `json:"advanced_filter,omitempty" yaml:"advanced_filter,omitempty" required:"false" doc:"Use this parameter to specify manual filters for the BaseDN. This is useful when accounts are distributed across OUs and the baseDN needs to be wide to include all accounts, while there are also accounts that you would like to exclude from user queries."`
	Binddn                     string    `json:"binddn,omitempty" yaml:"binddn,omitempty" required:"false" doc:"The bind DN for authenticating to the LDAP domain. You can specify any user account that has read access to the domain."`
	Bindpw                     string    `json:"bindpw,omitempty" yaml:"bindpw,omitempty" required:"false" doc:"The password used with the Bind DN to authenticate to the LDAP server."`
	DomainName                 string    `json:"domain_name,omitempty" yaml:"domain_name,omitempty" required:"false" doc:"FQDN of Active Directory domain. Must be resolvable in DNS."`
	DomainsWithPosixAttributes *[]string `json:"domains_with_posix_attributes,omitempty" yaml:"domains_with_posix_attributes,omitempty" required:"false" doc:"Allows to enumerate specific domains for POSIX attributes in case posix_attributes_source is set to SPECIFIC_DOMAINS."`
	GidNumber                  string    `json:"gid_number,omitempty" yaml:"gid_number,omitempty" required:"false" doc:"The attribute of a group entry on the LDAP server that contains the GID number of a group, if different from 'gidNumber'. When binding VAST Cluster to AD, you may need to set this to 'gidnumber' (case sensitive)."`
	GroupLoginName             string    `json:"group_login_name,omitempty" yaml:"group_login_name,omitempty" required:"false" doc:"Specifies the attribute used to query Active Directory for the group login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	GroupSearchbase            string    `json:"group_searchbase,omitempty" yaml:"group_searchbase,omitempty" required:"false" doc:"Base DN for group queries within the joined domain only. When auto discovery is enabled, group queries outside the joined domain use auto-discovered Base DNs."`
	IsVmsAuthProvider          bool      `json:"is_vms_auth_provider,omitempty" yaml:"is_vms_auth_provider,omitempty" required:"false" doc:"Enables use of the LDAP for VMS authentication. Two LDAP configurations per cluster can be used for VMS authentication: one with Active Directory and one without."`
	MailPropertyName           string    `json:"mail_property_name,omitempty" yaml:"mail_property_name,omitempty" required:"false" doc:"Specifies the attribute to use for the user's email address."`
	MatchUser                  string    `json:"match_user,omitempty" yaml:"match_user,omitempty" required:"false" doc:"The attribute to use when querying a provider for a user that matches a user that was already retrieved from another provider. A user entry that contains a matching value in this attribute will be considered the same user as the user previously retrieved."`
	Method                     string    `json:"method,omitempty" yaml:"method,omitempty" required:"false" doc:"The authentication method configured on the LDAP server for authenticating clients."`
	MonitorAction              string    `json:"monitor_action,omitempty" yaml:"monitor_action,omitempty" required:"false" doc:"The type of periodic health check that VAST Cluster performs for the Active Directory provider. PING (default, less overhead and impact on the provider) = pings the provider. BIND = binds to the provider."`
	Port                       int64     `json:"port,omitempty" yaml:"port,omitempty" required:"false" doc:"The port of the remote LDAP server. Typical values: 389, 636."`
	PosixAccount               string    `json:"posix_account,omitempty" yaml:"posix_account,omitempty" required:"false" doc:"The object class that defines a user entry on the LDAP server, if different from 'posixAccount'. When binding VAST Cluster to AD, set this parameter to 'user' in order for authorization to work properly."`
	PosixAttributesSource      string    `json:"posix_attributes_source,omitempty" yaml:"posix_attributes_source,omitempty" required:"false" doc:"Defines which domains POSIX attributes will be supported from."`
	PosixGroup                 string    `json:"posix_group,omitempty" yaml:"posix_group,omitempty" required:"false" doc:"The object class that defines a group entry on the LDAP server, if different from 'posixGroup'. When binding VAST Cluster to AD, set this parameter to 'group' in order for authorization to work properly."`
	QueryGroupsMode            string    `json:"query_groups_mode,omitempty" yaml:"query_groups_mode,omitempty" required:"false" doc:"A mode setting for how groups are queried: Set to COMPATIBLE to look up user groups using the 'memberOf' and 'memberUid' attributes. Set to RFC2307BIS_ONLY to look up user groups using only the 'memberOf' attribute. Set to RFC2307_ONLY to look up user groups using only the 'memberUid' attribute. Set to NONE not to look up user groups other than by leading GID and primary group SID."`
	QueryPosixAttributesFromGc bool      `json:"query_posix_attributes_from_gc,omitempty" yaml:"query_posix_attributes_from_gc,omitempty" required:"false" doc:"When set to True - users/groups from non-joined domain POSIX attributes are supported, when set to False - Posix attributes of users/groups from non-joined domain are not supported. As a condition Global catalog needs to be configured to support Posix attributes. (deprecated since 4.6)"`
	ReverseLookup              bool      `json:"reverse_lookup,omitempty" yaml:"reverse_lookup,omitempty" required:"false" doc:"Resolve LDAP netgroups into hostnames"`
	SuperAdminGroups           *[]string `json:"super_admin_groups,omitempty" yaml:"super_admin_groups,omitempty" required:"false" doc:"List of groups on the LDAP provider. Members of these groups can log into VMS as cluster admin users."`
	TlsCertificate             string    `json:"tls_certificate,omitempty" yaml:"tls_certificate,omitempty" required:"false" doc:"TLS certificate to use for verifying the remote LDAP server's TLS certificate."`
	Uid                        string    `json:"uid,omitempty" yaml:"uid,omitempty" required:"false" doc:"The attribute of a user entry on the LDAP server that contains the user name, if different from 'uid' When binding VAST Cluster to AD, you may need to set this to 'sAMAccountname'."`
	UidMember                  string    `json:"uid_member,omitempty" yaml:"uid_member,omitempty" required:"false" doc:"The attribute of a group entry on the LDAP server that contains names of group members, if different from 'memberUid'. When binding VAST Cluster to AD, you may need to set this to 'memberUID'."`
	UidMemberValuePropertyName string    `json:"uid_member_value_property_name,omitempty" yaml:"uid_member_value_property_name,omitempty" required:"false" doc:"Specifies the attribute which represents the value of the LDAP group's member property."`
	UidNumber                  string    `json:"uid_number,omitempty" yaml:"uid_number,omitempty" required:"false" doc:"The attribute of a user entry on the LDAP server that contains the UID number, if different from 'uidNumber'. Often when binding VAST Cluster to Active Directory this does not need to be set."`
	Url                        string    `json:"url,omitempty" yaml:"url,omitempty" required:"false" doc:"LDAP server URI in the format SCHEME://ADDRESS. ADDRESS can be either a DNS name or an IP address. Example: ldap://ldap.company.com"`
	UseAutoDiscovery           bool      `json:"use_auto_discovery,omitempty" yaml:"use_auto_discovery,omitempty" required:"false" doc:"When enabled, Active Directory Domain Controllers (DCs) and Active Directory domains are auto discovered. Queries extend beyond the joined domain to all domains in the forest. When disabled, queries are restricted to the joined domain and DCs must be provided in the URLs field."`
	UseLdaps                   bool      `json:"use_ldaps,omitempty" yaml:"use_ldaps,omitempty" required:"false" doc:"Use LDAPS for Auto-Discovery"`
	UseMultiForest             bool      `json:"use_multi_forest,omitempty" yaml:"use_multi_forest,omitempty" required:"false" doc:"Allow access for users from trusted domains on other forests."`
	UsePosix                   bool      `json:"use_posix,omitempty" yaml:"use_posix,omitempty" required:"false" doc:"POSIX support"`
	UseTls                     bool      `json:"use_tls,omitempty" yaml:"use_tls,omitempty" required:"false" doc:"Set to true to enable use of TLS to secure communication between VAST Cluster and the LDAP server."`
	UserLoginName              string    `json:"user_login_name,omitempty" yaml:"user_login_name,omitempty" required:"false" doc:"Specifies the attribute used to query Active Directory for the user login name in NFS ID mapping. Applicable only with Active Directory and NFSv4."`
	UsernamePropertyName       string    `json:"username_property_name,omitempty" yaml:"username_property_name,omitempty" required:"false" doc:"The attribute to use for querying users in VMS user-initated user queries. Default is 'name'. Sometimes set to 'cn'"`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// LdapDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/Ldap
type LdapDetailsModel = Component_Ldap

// LdapUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/Ldap
type LdapUpsertModel = Component_Ldap

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple ldaps with typed request/response
// summary: List LDAP Configurations
func (r *Ldap) List(req *LdapSearchParams) ([]*LdapDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple ldaps with typed request/response using provided context
// summary: List LDAP Configurations
func (r *Ldap) ListWithContext(ctx context.Context, req *LdapSearchParams) ([]*LdapDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*LdapDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single ldap with typed request/response
// summary: List LDAP Configurations
func (r *Ldap) Get(req *LdapSearchParams) (*LdapDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single ldap with typed request/response using provided context
// summary: List LDAP Configurations
func (r *Ldap) GetWithContext(ctx context.Context, req *LdapSearchParams) (*LdapDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response LdapDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single ldap by ID
// summary: Return Details of an LDAP configuration.
func (r *Ldap) GetById(id any) (*LdapDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single ldap by ID using provided context
// summary: Return Details of an LDAP configuration.
func (r *Ldap) GetByIdWithContext(ctx context.Context, id any) (*LdapDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response LdapDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new ldap with typed request/response
// summary: Create LDAP Configuration
func (r *Ldap) Create(req *LdapRequestBody) (*LdapUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new ldap with typed request/response using provided context
// summary: Create LDAP Configuration
func (r *Ldap) CreateWithContext(ctx context.Context, req *LdapRequestBody) (*LdapUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response LdapUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a ldap with search parameters
func (r *Ldap) Delete(req *LdapSearchParams) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req)
}

// DeleteWithContext deletes a ldap with search parameters using provided context
func (r *Ldap) DeleteWithContext(ctx context.Context, req *LdapSearchParams) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a ldap by ID
// summary: Delete LDAP Configuration
//
// Parameters:
//   - id: LDAP ID
func (r *Ldap) DeleteById(id any) error {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id)
}

// DeleteByIdWithContext deletes a ldap by ID using provided context
// summary: Delete LDAP Configuration
//
// Parameters:
//   - id: LDAP ID
func (r *Ldap) DeleteByIdWithContext(ctx context.Context, id any) error {
	_, err := r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteByIdWithContext(ctx, id, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a ldap exists with typed response
func (r *Ldap) Ensure(searchParams *LdapSearchParams, body *LdapRequestBody) (*LdapUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a ldap exists with typed response using provided context
func (r *Ldap) EnsureWithContext(ctx context.Context, searchParams *LdapSearchParams, body *LdapRequestBody) (*LdapUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response LdapUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a ldap exists
func (r *Ldap) Exists(req *LdapSearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a ldap exists using provided context
func (r *Ldap) ExistsWithContext(ctx context.Context, req *LdapSearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a ldap exists and panics if not
func (r *Ldap) MustExists(req *LdapSearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a ldap exists and panics if not using provided context
func (r *Ldap) MustExistsWithContext(ctx context.Context, req *LdapSearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// LdapSetPosixPrimaryWithContext_PATCH
// method: PATCH
// url: /ldaps/{id}/set_posix_primary/
// summary: Set LDAP as POSIX Primary Provider
func (r *Ldap) LdapSetPosixPrimaryWithContext_PATCH(ctx context.Context, id any) error {
	resourcePath := core.BuildResourcePathWithID("ldaps", id, "set_posix_primary")

	var reqParams core.Params
	var reqBody core.Params

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	return err

}

// LdapSetPosixPrimary_PATCH
// method: PATCH
// url: /ldaps/{id}/set_posix_primary/
// summary: Set LDAP as POSIX Primary Provider
func (r *Ldap) LdapSetPosixPrimary_PATCH(id any) error {
	return r.LdapSetPosixPrimaryWithContext_PATCH(r.Untyped.GetCtx(), id)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - UPDATE operation excluded: PATCH/PUT /ldaps/{id}/ has no response schema and doesn't return 204 NO CONTENT
