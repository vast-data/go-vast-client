// Code generated by generate-typed-resources. DO NOT EDIT.
// Template: CREATE|LIST|READ|DELETE

package typed

import (
	"context"
	"net/http"
	"time"

	"github.com/vast-data/go-vast-client/core"
	"github.com/vast-data/go-vast-client/resources/untyped"
)

// -----------------------------------------------------
// RESOURCE TYPE
// -----------------------------------------------------

// ProtectedPath represents a typed resource for protectedpath operations
type ProtectedPath struct {
	*core.TypedVastResource
}

// -----------------------------------------------------
// SEARCH PARAMS
// -----------------------------------------------------

// ProtectedPathSearchParams represents the search parameters for ProtectedPath operations
type ProtectedPathSearchParams struct {
	Enabled   string `json:"enabled,omitempty" yaml:"enabled,omitempty" required:"false" doc:"start/pause protected path"`
	Guid      string `json:"guid,omitempty" yaml:"guid,omitempty" required:"false" doc:"guid"`
	Name      string `json:"name,omitempty" yaml:"name,omitempty" required:"false" doc:""`
	Role      string `json:"role,omitempty" yaml:"role,omitempty" required:"false" doc:""`
	SourceDir string `json:"source_dir,omitempty" yaml:"source_dir,omitempty" required:"false" doc:""`
	State     string `json:"state,omitempty" yaml:"state,omitempty" required:"false" doc:""`
	TenantId  int64  `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"false" doc:"Local Tenant ID"`

	// RawData allows passing arbitrary search parameters as key-value pairs.
	//
	// Use this field when you need query parameters that are not covered by the typed fields above.
	// This is particularly useful for:
	//   - Dynamic filter operations (e.g., "path__contains", "name__icontains")
	//   - Django-style query filters
	//   - Custom backend-specific parameters
	//
	// Example:
	//   params := &ProtectedPathSearchParams{
	//       RawData: core.Params{"path__contains": "/foo", "name__icontains": "bar"},
	//   }
	//
	// Note: You can use either the typed fields or RawData, or combine both.
	RawData core.Params `json:"-" yaml:"-"`
}

// -----------------------------------------------------
// REQUEST BODY
// -----------------------------------------------------

// ProtectedPathRequestBody represents the request body for ProtectedPath operations
type ProtectedPathRequestBody struct {
	Name                     string `json:"name,omitempty" yaml:"name,omitempty" required:"true" doc:""`
	SourceDir                string `json:"source_dir,omitempty" yaml:"source_dir,omitempty" required:"true" doc:"A path on the local cluster to protect. A snapshot of the specified path will be taken periodically on the schedule configured in the specified protection policy."`
	TargetExportedDir        string `json:"target_exported_dir,omitempty" yaml:"target_exported_dir,omitempty" required:"true" doc:"A path on a remote peer to which to replicate."`
	TenantId                 string `json:"tenant_id,omitempty" yaml:"tenant_id,omitempty" required:"true" doc:"Tenant ID of the tenant on the local cluster to which the source_dir belongs."`
	Capabilities             string `json:"capabilities,omitempty" yaml:"capabilities,omitempty" required:"false" doc:"Indicates if the protected path supports global access streams (\"STARED_GLOBAL_NAMESPACE\") or async replication streams (\"ASYNC_REPLICATION\") or a single stream for synchronous replication (\"SYNC_REPLICATION\") or both global access and async replication (\"REPLICATION_AND_GN\")."`
	Enabled                  bool   `json:"enabled,omitempty" yaml:"enabled,omitempty" required:"false" doc:"Enables/pauses the protected path"`
	LeaseExpiryTime          int64  `json:"lease_expiry_time,omitempty" yaml:"lease_expiry_time,omitempty" required:"false" doc:"The lease expiry time, in seconds, for a global access protected path. This is the duration for which data that was already requested at the destination path can be read locally from cache without the destination peer requesting it from the source peer. When the lease expires, the cache is invalidated and the next read request for the data is requested again from the source peer."`
	ProtectionPolicyId       string `json:"protection_policy_id,omitempty" yaml:"protection_policy_id,omitempty" required:"false" doc:"Specifies whcih protection policy to use"`
	RemoteTargetId           int64  `json:"remote_target_id,omitempty" yaml:"remote_target_id,omitempty" required:"false" doc:"Remote target ID for streams with global namespace or synchronous replication capability."`
	RemoteTenantGuid         string `json:"remote_tenant_guid,omitempty" yaml:"remote_tenant_guid,omitempty" required:"false" doc:"Tenant GUID of the remote peer tenant to which to replicate"`
	SourceMemberCapabilities string `json:"source_member_capabilities,omitempty" yaml:"source_member_capabilities,omitempty" required:"false" doc:"Stream capabilities for the source member"`
	SyncDisconnectTime       int64  `json:"sync_disconnect_time,omitempty" yaml:"sync_disconnect_time,omitempty" required:"false" doc:"A period of time, in seconds, without communication between sync replication peers, after which the peers are disconnected."`
	SyncInterval             int64  `json:"sync_interval,omitempty" yaml:"sync_interval,omitempty" required:"false" doc:"Replication group sync interval"`
}

// -----------------------------------------------------
// MODELS
// -----------------------------------------------------

// ProtectedPathDetailsModel represents the detailed model returned by GET/List operations
// Type alias to component definition: #/components/schemas/ProtectedPath
type ProtectedPathDetailsModel = Component_ProtectedPath

// ProtectedPathUpsertModel represents the model returned by Create/Update operations
// Type alias to component definition: #/components/schemas/ProtectedPath
type ProtectedPathUpsertModel = Component_ProtectedPath

// -----------------------------------------------------
// LIST
// -----------------------------------------------------

// List retrieves multiple protectedpaths with typed request/response
// summary: List Protected Paths
func (r *ProtectedPath) List(req *ProtectedPathSearchParams) ([]*ProtectedPathDetailsModel, error) {
	return r.ListWithContext(r.Untyped.GetCtx(), req)
}

// ListWithContext retrieves multiple protectedpaths with typed request/response using provided context
// summary: List Protected Paths
func (r *ProtectedPath) ListWithContext(ctx context.Context, req *ProtectedPathSearchParams) ([]*ProtectedPathDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	recordSet, err := r.Untyped.GetResourceMap()[r.GetResourceType()].ListWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response []*ProtectedPathDetailsModel
	if err := recordSet.Fill(&response); err != nil {
		return nil, err
	}

	return response, nil
}

// Get retrieves a single protectedpath with typed request/response
// summary: List Protected Paths
func (r *ProtectedPath) Get(req *ProtectedPathSearchParams) (*ProtectedPathDetailsModel, error) {
	return r.GetWithContext(r.Untyped.GetCtx(), req)
}

// GetWithContext retrieves a single protectedpath with typed request/response using provided context
// summary: List Protected Paths
func (r *ProtectedPath) GetWithContext(ctx context.Context, req *ProtectedPathSearchParams) (*ProtectedPathDetailsModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// READ
// -----------------------------------------------------

// GetById retrieves a single protectedpath by ID
// summary: Return Details of a Protected Path
func (r *ProtectedPath) GetById(id any) (*ProtectedPathDetailsModel, error) {
	return r.GetByIdWithContext(r.Untyped.GetCtx(), id)
}

// GetByIdWithContext retrieves a single protectedpath by ID using provided context
// summary: Return Details of a Protected Path
func (r *ProtectedPath) GetByIdWithContext(ctx context.Context, id any) (*ProtectedPathDetailsModel, error) {
	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].GetByIdWithContext(ctx, id)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathDetailsModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// CREATE
// -----------------------------------------------------

// Create creates a new protectedpath with typed request/response
// summary: Create a Protected Path
func (r *ProtectedPath) Create(req *ProtectedPathRequestBody) (*ProtectedPathUpsertModel, error) {
	return r.CreateWithContext(r.Untyped.GetCtx(), req)
}

// CreateWithContext creates a new protectedpath with typed request/response using provided context
// summary: Create a Protected Path
func (r *ProtectedPath) CreateWithContext(ctx context.Context, req *ProtectedPathRequestBody) (*ProtectedPathUpsertModel, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].CreateWithContext(ctx, params)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// -----------------------------------------------------
// DELETE
// -----------------------------------------------------

// Delete deletes a protectedpath with search parameters
func (r *ProtectedPath) Delete(req *ProtectedPathSearchParams) error {
	return r.DeleteWithContext(r.Untyped.GetCtx(), req)
}

// DeleteWithContext deletes a protectedpath with search parameters using provided context
func (r *ProtectedPath) DeleteWithContext(ctx context.Context, req *ProtectedPathSearchParams) error {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return err
	}
	_, err = r.Untyped.GetResourceMap()[r.GetResourceType()].DeleteWithContext(ctx, params, nil, nil)
	if err != nil {
		return err
	}
	return nil
}

// DeleteById deletes a protectedpath by ID and returns an async task
// summary: Delete a Protected Path
func (r *ProtectedPath) DeleteById(id any, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	return r.DeleteByIdWithContext(r.Untyped.GetCtx(), id, waitTimeout)
}

// DeleteByIdWithContext deletes a protectedpath by ID and returns an async task using provided context
// summary: Delete a Protected Path
func (r *ProtectedPath) DeleteByIdWithContext(ctx context.Context, id any, waitTimeout time.Duration) (*untyped.AsyncResult, error) {
	// For async DELETE, call core.Request directly to get the task response
	path := core.BuildResourcePathWithID(r.Untyped.GetResourceMap()[r.GetResourceType()].GetResourcePath(), id)
	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, path, nil, nil)
	if err != nil {
		return nil, err
	}

	return untyped.MaybeWaitAsyncResultWithContext(ctx, record, r.Untyped, waitTimeout)
}

// -----------------------------------------------------
// ENSURE
// -----------------------------------------------------

// Ensure ensures a protectedpath exists with typed response
func (r *ProtectedPath) Ensure(searchParams *ProtectedPathSearchParams, body *ProtectedPathRequestBody) (*ProtectedPathUpsertModel, error) {
	return r.EnsureWithContext(r.Untyped.GetCtx(), searchParams, body)
}

// EnsureWithContext ensures a protectedpath exists with typed response using provided context
func (r *ProtectedPath) EnsureWithContext(ctx context.Context, searchParams *ProtectedPathSearchParams, body *ProtectedPathRequestBody) (*ProtectedPathUpsertModel, error) {
	searchParamsConverted, err := core.NewParamsFromStruct(searchParams)
	if err != nil {
		return nil, err
	}
	bodyConverted, err := core.NewParamsFromStruct(body)
	if err != nil {
		return nil, err
	}

	record, err := r.Untyped.GetResourceMap()[r.GetResourceType()].EnsureWithContext(ctx, searchParamsConverted, bodyConverted)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathUpsertModel
	if err := record.Fill(&response); err != nil {
		return nil, err
	}

	return &response, nil
}

// Exists checks if a protectedpath exists
func (r *ProtectedPath) Exists(req *ProtectedPathSearchParams) (bool, error) {
	return r.ExistsWithContext(r.Untyped.GetCtx(), req)
}

// ExistsWithContext checks if a protectedpath exists using provided context
func (r *ProtectedPath) ExistsWithContext(ctx context.Context, req *ProtectedPathSearchParams) (bool, error) {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		return false, err
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].ExistsWithContext(ctx, params)
}

// MustExists checks if a protectedpath exists and panics if not
func (r *ProtectedPath) MustExists(req *ProtectedPathSearchParams) bool {
	return r.MustExistsWithContext(r.Untyped.GetCtx(), req)
}

// MustExistsWithContext checks if a protectedpath exists and panics if not using provided context
func (r *ProtectedPath) MustExistsWithContext(ctx context.Context, req *ProtectedPathSearchParams) bool {
	params, err := core.NewParamsFromStruct(req)
	if err != nil {
		panic(err)
	}
	return r.Untyped.GetResourceMap()[r.GetResourceType()].MustExistsWithContext(ctx, params)
}

// -----------------------------------------------------
// EXTRA METHODS
// -----------------------------------------------------

// ProtectedPathPrefetchPathWithContext_DELETE
// method: DELETE
// url: /protectedpaths/{id}/prefetch_path/
// summary: Delete Path Prefetch Task
//
// Parameters:
//   - stopRunningPrefetch (body): If true, stops the prefetch task running if it's still running.
//   - taskId (body): ID of the prefetch task to delete.
func (r *ProtectedPath) ProtectedPathPrefetchPathWithContext_DELETE(ctx context.Context, id any, stopRunningPrefetch bool, taskId int64) error {
	resourcePath := core.BuildResourcePathWithID("protectedpaths", id, "prefetch_path")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["stop_running_prefetch"] = stopRunningPrefetch
	reqBody["task_id"] = taskId

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodDelete, resourcePath, reqParams, reqBody)
	return err

}

// ProtectedPathPrefetchPath_DELETE
// method: DELETE
// url: /protectedpaths/{id}/prefetch_path/
// summary: Delete Path Prefetch Task
//
// Parameters:
//   - stopRunningPrefetch (body): If true, stops the prefetch task running if it's still running.
//   - taskId (body): ID of the prefetch task to delete.
func (r *ProtectedPath) ProtectedPathPrefetchPath_DELETE(id any, stopRunningPrefetch bool, taskId int64) error {
	return r.ProtectedPathPrefetchPathWithContext_DELETE(r.Untyped.GetCtx(), id, stopRunningPrefetch, taskId)
}

// ProtectedPathPrefetchPath_GET_Body represents the request body for ProtectedPathPrefetchPath
type ProtectedPathPrefetchPath_GET_Body struct {
	TaskId int64 `json:"task_id,omitempty" yaml:"task_id,omitempty" required:"false" doc:"ID of task for which to get the prefetch status"`
}

// ProtectedPathPrefetchPath_GET_Model represents the response model for ProtectedPathPrefetchPath
type ProtectedPathPrefetchPath_GET_Model struct {
	Code            string `json:"code,omitempty" yaml:"code,omitempty" required:"false" doc:"Result code"`
	InodesRetrieved int64  `json:"inodes_retrieved,omitempty" yaml:"inodes_retrieved,omitempty" required:"false" doc:"Number of retrieved inodes (files and directories)"`
	Path            string `json:"path,omitempty" yaml:"path,omitempty" required:"false" doc:"Prefetched path"`
	PrefetchType    string `json:"prefetch_type,omitempty" yaml:"prefetch_type,omitempty" required:"false" doc:"Prefetch type"`
	SizeRetrieved   int64  `json:"size_retrieved,omitempty" yaml:"size_retrieved,omitempty" required:"false" doc:"Retrieved size"`
	TaskId          int64  `json:"task_id,omitempty" yaml:"task_id,omitempty" required:"false" doc:"Prefetch task ID"`
}

// ProtectedPathPrefetchPathWithContext_GET
// method: GET
// url: /protectedpaths/{id}/prefetch_path/
// summary: Return Status for Prefetch Path
func (r *ProtectedPath) ProtectedPathPrefetchPathWithContext_GET(ctx context.Context, id any, params *ProtectedPathPrefetchPath_GET_Body) (*ProtectedPathPrefetchPath_GET_Model, error) {
	resourcePath := core.BuildResourcePathWithID("protectedpaths", id, "prefetch_path")

	reqParams, err := core.NewParamsFromStruct(params)
	if err != nil {
		return nil, err
	}
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathPrefetchPath_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ProtectedPathPrefetchPath_GET
// method: GET
// url: /protectedpaths/{id}/prefetch_path/
// summary: Return Status for Prefetch Path
func (r *ProtectedPath) ProtectedPathPrefetchPath_GET(id any, params *ProtectedPathPrefetchPath_GET_Body) (*ProtectedPathPrefetchPath_GET_Model, error) {
	return r.ProtectedPathPrefetchPathWithContext_GET(r.Untyped.GetCtx(), id, params)
}

// ProtectedPathPrefetchPath_POST_Model represents the response model for ProtectedPathPrefetchPath
type ProtectedPathPrefetchPath_POST_Model struct {
	Code   string `json:"code,omitempty" yaml:"code,omitempty" required:"false" doc:"Result code"`
	TaskId int64  `json:"task_id,omitempty" yaml:"task_id,omitempty" required:"false" doc:"Prefetch task ID"`
}

// ProtectedPathPrefetchPathWithContext_POST
// method: POST
// url: /protectedpaths/{id}/prefetch_path/
// summary: Prefetch a Path to Global Access Cache
//
// Parameters:
//   - path (body): The path on the destination peer for which to prefetch data from the equivalent source path to the global access cache. The path can be the entire protected path or a subdirectory.
//   - prefetchType (body): Whether to prefetch full data or only metadata.
func (r *ProtectedPath) ProtectedPathPrefetchPathWithContext_POST(ctx context.Context, id any, path string, prefetchType string) (*ProtectedPathPrefetchPath_POST_Model, error) {
	resourcePath := core.BuildResourcePathWithID("protectedpaths", id, "prefetch_path")

	var reqParams core.Params
	reqBody := core.Params{}
	reqBody["path"] = path
	reqBody["prefetch_type"] = prefetchType

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPost, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathPrefetchPath_POST_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ProtectedPathPrefetchPath_POST
// method: POST
// url: /protectedpaths/{id}/prefetch_path/
// summary: Prefetch a Path to Global Access Cache
//
// Parameters:
//   - path (body): The path on the destination peer for which to prefetch data from the equivalent source path to the global access cache. The path can be the entire protected path or a subdirectory.
//   - prefetchType (body): Whether to prefetch full data or only metadata.
func (r *ProtectedPath) ProtectedPathPrefetchPath_POST(id any, path string, prefetchType string) (*ProtectedPathPrefetchPath_POST_Model, error) {
	return r.ProtectedPathPrefetchPathWithContext_POST(r.Untyped.GetCtx(), id, path, prefetchType)
}

// ProtectedPathRemoveStreamWithContext_PATCH
// method: PATCH
// url: /protectedpaths/{id}/remove_stream/
// summary: Remove a Stream from a Protected Path
//
// Parameters:
//   - streamId (body): The ID of the replication stream
func (r *ProtectedPath) ProtectedPathRemoveStreamWithContext_PATCH(ctx context.Context, id any, streamId string) error {
	resourcePath := core.BuildResourcePathWithID("protectedpaths", id, "remove_stream")

	var reqParams core.Params
	reqBody := core.Params{}
	if streamId != "" {
		reqBody["stream_id"] = streamId
	}

	_, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodPatch, resourcePath, reqParams, reqBody)
	return err

}

// ProtectedPathRemoveStream_PATCH
// method: PATCH
// url: /protectedpaths/{id}/remove_stream/
// summary: Remove a Stream from a Protected Path
//
// Parameters:
//   - streamId (body): The ID of the replication stream
func (r *ProtectedPath) ProtectedPathRemoveStream_PATCH(id any, streamId string) error {
	return r.ProtectedPathRemoveStreamWithContext_PATCH(r.Untyped.GetCtx(), id, streamId)
}

// ProtectedPathValidate_GET_Model represents the response model for ProtectedPathValidate
type ProtectedPathValidate_GET_Model struct {
	HasGnStreams        bool      `json:"has_gn_streams,omitempty" yaml:"has_gn_streams,omitempty" required:"false" doc:"True if the protected Path has global access streams"`
	IsDestPpath         bool      `json:"is_dest_ppath,omitempty" yaml:"is_dest_ppath,omitempty" required:"false" doc:"True if the protected path or one of its descendants is a replication destination"`
	IsMultiTenantSystem bool      `json:"is_multi_tenant_system,omitempty" yaml:"is_multi_tenant_system,omitempty" required:"false" doc:"True if the protected path is on a multi-tenant cluster."`
	IsSourcePpath       bool      `json:"is_source_ppath,omitempty" yaml:"is_source_ppath,omitempty" required:"false" doc:"True if the protected path or one of its descendants is a replication source"`
	S3Versioning        *[]string `json:"s3_versioning,omitempty" yaml:"s3_versioning,omitempty" required:"false" doc:"View paths with s3_versioning enabled."`
}

// ProtectedPathValidateWithContext_GET
// method: GET
// url: /protectedpaths/{id}/validate/
// summary: Returns validations results for Protected Path.
func (r *ProtectedPath) ProtectedPathValidateWithContext_GET(ctx context.Context, id any) (*ProtectedPathValidate_GET_Model, error) {
	resourcePath := core.BuildResourcePathWithID("protectedpaths", id, "validate")

	var reqParams core.Params
	var reqBody core.Params

	record, err := core.Request[core.Record](ctx, r.Untyped.GetResourceMap()[r.GetResourceType()], http.MethodGet, resourcePath, reqParams, reqBody)
	if err != nil {
		return nil, err
	}

	var response ProtectedPathValidate_GET_Model
	if err := record.Fill(&response); err != nil {
		return nil, err
	}
	return &response, nil

}

// ProtectedPathValidate_GET
// method: GET
// url: /protectedpaths/{id}/validate/
// summary: Returns validations results for Protected Path.
func (r *ProtectedPath) ProtectedPathValidate_GET(id any) (*ProtectedPathValidate_GET_Model, error) {
	return r.ProtectedPathValidateWithContext_GET(r.Untyped.GetCtx(), id)
}

// -----------------------------------------------------
// GENERATION ISSUES
// -----------------------------------------------------
//   - Extra method PATCH /protectedpaths/{id}/add_stream/ skipped: PATCH /protectedpaths/{id}/add_stream/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/add_stream/
//   - Extra method PATCH /protectedpaths/{id}/commit/ skipped: PATCH /protectedpaths/{id}/commit/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/commit/
//   - Extra method PATCH /protectedpaths/{id}/force_failover/ skipped: PATCH /protectedpaths/{id}/force_failover/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/force_failover/
//   - Extra method PATCH /protectedpaths/{id}/modify_member/ skipped: PATCH /protectedpaths/{id}/modify_member/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/modify_member/
//   - Extra method PATCH /protectedpaths/{id}/pause/ skipped: PATCH /protectedpaths/{id}/pause/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/pause/
//   - Extra method PATCH /protectedpaths/{id}/reattach_stream/ skipped: PATCH /protectedpaths/{id}/reattach_stream/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/reattach_stream/
//   - Extra method PATCH /protectedpaths/{id}/replicate_now/ skipped: PATCH /protectedpaths/{id}/replicate_now/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/replicate_now/
//   - Extra method PATCH /protectedpaths/{id}/resume/ skipped: PATCH /protectedpaths/{id}/resume/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/resume/
//   - Extra method PATCH /protectedpaths/{id}/stop/ skipped: PATCH /protectedpaths/{id}/stop/ - No response schema defined in OpenAPI spec. Error: no valid schema found in PATCH response (200/201/202/204) for resource /protectedpaths/{id}/stop/
//   - Extra method POST /protectedpaths/{id}/restore/ skipped: POST /protectedpaths/{id}/restore/ - Response schema contains ambiguous nested objects (objects with no properties)
//   - UPDATE operation excluded: PATCH/PUT /protectedpaths/{id}/ has no response schema and doesn't return 204 NO CONTENT
