// Code generated by generate-untyped-resources. DO NOT EDIT.

package untyped

import (
	"context"
	"net/http"
	"time"

	"github.com/vast-data/go-vast-client/core"
)

// ClusterAddBoxesWithContext_PATCH
// method: PATCH
// url: /clusters/add_boxes/
// summary: Start Add Boxes procedure
//
// Body:
//   - cboxes
//   - cnode_ipmi_pool
//   - cnode_management_ip_pool
//   - cnode_start_index: CNode start index valid range: [1, 99], for null value index will be selected automatically, as max_existed_index + 1
//   - continue_migration
//   - dboxes
//   - dnode_ipmi_pool
//   - dnode_management_ip_pool
//   - dnode_start_index: CNode start index valid range: [100, 254], for null value index will be selected automatically, as max_existed_index + 1
//   - empty_dbox
//   - external_gateway
//   - hostname_prefix
//   - ipv6_prefix
//   - management_cidr
//   - migrate_target
//   - rack_pools
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterAddBoxesWithContext_PATCH(ctx context.Context, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := "/clusters/add_boxes/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterAddBoxes_PATCH
// method: PATCH
// url: /clusters/add_boxes/
// summary: Start Add Boxes procedure
//
// Body:
//   - cboxes
//   - cnode_ipmi_pool
//   - cnode_management_ip_pool
//   - cnode_start_index: CNode start index valid range: [1, 99], for null value index will be selected automatically, as max_existed_index + 1
//   - continue_migration
//   - dboxes
//   - dnode_ipmi_pool
//   - dnode_management_ip_pool
//   - dnode_start_index: CNode start index valid range: [100, 254], for null value index will be selected automatically, as max_existed_index + 1
//   - empty_dbox
//   - external_gateway
//   - hostname_prefix
//   - ipv6_prefix
//   - management_cidr
//   - migrate_target
//   - rack_pools
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterAddBoxes_PATCH(body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterAddBoxesWithContext_PATCH(c.Rest.GetCtx(), body, waitTimeout)
}

// ClusterAddEkmWithContext_POST
// method: POST
// url: /clusters/{id}/add_ekm/
// summary: Add EKM
//
// Body:
//   - ekm_auth_domain: Auth domain (Thales)
//   - ekm_bypass_validation: Bypass key and cert validation (VMS)
//   - ekm_ca_certificate: EKM CA certificate
//   - ekm_certificate: EKM certificate
//   - ekm_domain: Domain (Thales)
//   - ekm_private_key: EKM private key
//   - ekm_proxy_address: Thales EKM proxy address: https://proxy-address:port
//   - ekm_servers: List of EKM servers: 10.0.0.1:5696,11.0.0.1:5697
//   - encryption_type: Encryption type
func (c *Cluster) ClusterAddEkmWithContext_POST(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "add_ekm")
	_, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	return err

}

// ClusterAddEkm_POST
// method: POST
// url: /clusters/{id}/add_ekm/
// summary: Add EKM
//
// Body:
//   - ekm_auth_domain: Auth domain (Thales)
//   - ekm_bypass_validation: Bypass key and cert validation (VMS)
//   - ekm_ca_certificate: EKM CA certificate
//   - ekm_certificate: EKM certificate
//   - ekm_domain: Domain (Thales)
//   - ekm_private_key: EKM private key
//   - ekm_proxy_address: Thales EKM proxy address: https://proxy-address:port
//   - ekm_servers: List of EKM servers: 10.0.0.1:5696,11.0.0.1:5697
//   - encryption_type: Encryption type
func (c *Cluster) ClusterAddEkm_POST(id any, body core.Params) error {
	return c.ClusterAddEkmWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterAdvancedWithContext_GET
// method: GET
// url: /clusters/{id}/advanced/
// summary: Aggregated information about the cluster
func (c *Cluster) ClusterAdvancedWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "advanced")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterAdvanced_GET
// method: GET
// url: /clusters/{id}/advanced/
// summary: Aggregated information about the cluster
func (c *Cluster) ClusterAdvanced_GET(id any) (core.Record, error) {
	return c.ClusterAdvancedWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterAuditingWithContext_GET
// method: GET
// url: /clusters/{id}/auditing/
// summary: Show Cluster Audit Settings
func (c *Cluster) ClusterAuditingWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "auditing")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterAuditing_GET
// method: GET
// url: /clusters/{id}/auditing/
// summary: Show Cluster Audit Settings
func (c *Cluster) ClusterAuditing_GET(id any) (core.Record, error) {
	return c.ClusterAuditingWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterAuditingWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/auditing/
// summary: Modify Cluster Audit Settings
//
// Body:
//   - audit_dir_name: Name of the audit directory, which is located under the root directory.
//   - enable_json_audit: If enabled, audit logs are saved in JSON format into a file in the directory specified as audit_dir_name. Can be enabled in addition to enable_vast_db_audit.
//   - enable_vast_db_audit: If enabled, audit logs are saved in a VAST DataBase table. Can be enabled in addition to enable_json_audit.
//   - max_audit_dir_size: Maximum audit directory size
//   - max_file_size: Maximum audit file size for each CNode core
//   - max_retention_period: Max retention period for audit files
//   - max_retention_timeunit: Max retention period timeunit for audit files
//   - protocols: Protocols to audit
//   - protocols_audit: Map of protocols audit configurations
//   - read_access_users: Enter users here to grant them read access to all files in the audit directory. To make the audit directory accessible to clients, create a view on the directory.
//   - read_access_users_groups: Enter groups here to grant them read access to all files in the audit directory. To make the audit directory accessible to clients, create a view on the directory.
func (c *Cluster) ClusterAuditingWithContext_PATCH(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "auditing")
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterAuditing_PATCH
// method: PATCH
// url: /clusters/{id}/auditing/
// summary: Modify Cluster Audit Settings
//
// Body:
//   - audit_dir_name: Name of the audit directory, which is located under the root directory.
//   - enable_json_audit: If enabled, audit logs are saved in JSON format into a file in the directory specified as audit_dir_name. Can be enabled in addition to enable_vast_db_audit.
//   - enable_vast_db_audit: If enabled, audit logs are saved in a VAST DataBase table. Can be enabled in addition to enable_json_audit.
//   - max_audit_dir_size: Maximum audit directory size
//   - max_file_size: Maximum audit file size for each CNode core
//   - max_retention_period: Max retention period for audit files
//   - max_retention_timeunit: Max retention period timeunit for audit files
//   - protocols: Protocols to audit
//   - protocols_audit: Map of protocols audit configurations
//   - read_access_users: Enter users here to grant them read access to all files in the audit directory. To make the audit directory accessible to clients, create a view on the directory.
//   - read_access_users_groups: Enter groups here to grant them read access to all files in the audit directory. To make the audit directory accessible to clients, create a view on the directory.
func (c *Cluster) ClusterAuditing_PATCH(id any, body core.Params) (core.Record, error) {
	return c.ClusterAuditingWithContext_PATCH(c.Rest.GetCtx(), id, body)
}

// ClusterBgpTableWithContext_GET
// method: GET
// url: /clusters/bgp_table/
// summary: Return BGP Connections Table
func (c *Cluster) ClusterBgpTableWithContext_GET(ctx context.Context) (core.Record, error) {
	resourcePath := "/clusters/bgp_table/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterBgpTable_GET
// method: GET
// url: /clusters/bgp_table/
// summary: Return BGP Connections Table
func (c *Cluster) ClusterBgpTable_GET() (core.Record, error) {
	return c.ClusterBgpTableWithContext_GET(c.Rest.GetCtx())
}

// ClusterBlockProvidersWithContext_PATCH
// method: PATCH
// url: /clusters/block_providers/
// summary: Block Authentication Providers
//
// Body:
//   - blocked
func (c *Cluster) ClusterBlockProvidersWithContext_PATCH(ctx context.Context, body core.Params) (core.Record, error) {
	resourcePath := "/clusters/block_providers/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterBlockProviders_PATCH
// method: PATCH
// url: /clusters/block_providers/
// summary: Block Authentication Providers
//
// Body:
//   - blocked
func (c *Cluster) ClusterBlockProviders_PATCH(body core.Params) (core.Record, error) {
	return c.ClusterBlockProvidersWithContext_PATCH(c.Rest.GetCtx(), body)
}

// ClusterCeleryQueueWithContext_GET
// method: GET
// url: /clusters/{id}/celery_queue/
// summary: List celery queue
//
// Params:
//   - task_name: Task name
func (c *Cluster) ClusterCeleryQueueWithContext_GET(ctx context.Context, id any, params core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "celery_queue")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterCeleryQueue_GET
// method: GET
// url: /clusters/{id}/celery_queue/
// summary: List celery queue
//
// Params:
//   - task_name: Task name
func (c *Cluster) ClusterCeleryQueue_GET(id any, params core.Params) (core.Record, error) {
	return c.ClusterCeleryQueueWithContext_GET(c.Rest.GetCtx(), id, params)
}

// ClusterCeleryRemoveQueuedTaskWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/celery_remove_queued_task/
// summary: Delete all tasks of a specific name from the celery queue
//
// Params:
//   - task_name: Task name
func (c *Cluster) ClusterCeleryRemoveQueuedTaskWithContext_DELETE(ctx context.Context, id any, params core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "celery_remove_queued_task")
	_, err := core.Request[core.Record](ctx, c, http.MethodDelete, resourcePath, params, nil)
	return err

}

// ClusterCeleryRemoveQueuedTask_DELETE
// method: DELETE
// url: /clusters/{id}/celery_remove_queued_task/
// summary: Delete all tasks of a specific name from the celery queue
//
// Params:
//   - task_name: Task name
func (c *Cluster) ClusterCeleryRemoveQueuedTask_DELETE(id any, params core.Params) error {
	return c.ClusterCeleryRemoveQueuedTaskWithContext_DELETE(c.Rest.GetCtx(), id, params)
}

// ClusterCeleryReservedWithContext_GET
// method: GET
// url: /clusters/{id}/celery_reserved/
// summary: List celery reserved queue
func (c *Cluster) ClusterCeleryReservedWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "celery_reserved")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterCeleryReserved_GET
// method: GET
// url: /clusters/{id}/celery_reserved/
// summary: List celery reserved queue
func (c *Cluster) ClusterCeleryReserved_GET(id any) (core.Record, error) {
	return c.ClusterCeleryReservedWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterCeleryScheduledWithContext_GET
// method: GET
// url: /clusters/{id}/celery_scheduled/
// summary: List celery scheduled queue
func (c *Cluster) ClusterCeleryScheduledWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "celery_scheduled")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterCeleryScheduled_GET
// method: GET
// url: /clusters/{id}/celery_scheduled/
// summary: List celery scheduled queue
func (c *Cluster) ClusterCeleryScheduled_GET(id any) (core.Record, error) {
	return c.ClusterCeleryScheduledWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterCeleryStatusWithContext_GET
// method: GET
// url: /clusters/{id}/celery_status/
// summary: Show the full celery stats
func (c *Cluster) ClusterCeleryStatusWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "celery_status")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterCeleryStatus_GET
// method: GET
// url: /clusters/{id}/celery_status/
// summary: Show the full celery stats
func (c *Cluster) ClusterCeleryStatus_GET(id any) (core.Record, error) {
	return c.ClusterCeleryStatusWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterCloseProtocolHandleWithContext_DELETE
// method: DELETE
// url: /clusters/close_protocol_handle/
// summary: Close open protocol filehandles
//
// Params:
//   - file_path: File path
//   - session_id: Session ID
//   - session_handle_unique_id: Handle ID
//   - tenant_guid: Tenant GUID
func (c *Cluster) ClusterCloseProtocolHandleWithContext_DELETE(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/close_protocol_handle/"
	result, err := core.Request[core.Record](ctx, c, http.MethodDelete, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterCloseProtocolHandle_DELETE
// method: DELETE
// url: /clusters/close_protocol_handle/
// summary: Close open protocol filehandles
//
// Params:
//   - file_path: File path
//   - session_id: Session ID
//   - session_handle_unique_id: Handle ID
//   - tenant_guid: Tenant GUID
func (c *Cluster) ClusterCloseProtocolHandle_DELETE(params core.Params) (core.Record, error) {
	return c.ClusterCloseProtocolHandleWithContext_DELETE(c.Rest.GetCtx(), params)
}

// ClusterDboxMigrationStatusWithContext_GET
// method: GET
// url: /clusters/dbox_migration_status/
// summary: DBox migration status
//
// Params:
//   - with_capacity: The flag to show the migration status with capacity
func (c *Cluster) ClusterDboxMigrationStatusWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/dbox_migration_status/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxMigrationStatus_GET
// method: GET
// url: /clusters/dbox_migration_status/
// summary: DBox migration status
//
// Params:
//   - with_capacity: The flag to show the migration status with capacity
func (c *Cluster) ClusterDboxMigrationStatus_GET(params core.Params) (core.Record, error) {
	return c.ClusterDboxMigrationStatusWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterDboxMigrationUpdateSourceTargetWithContext_GET
// method: GET
// url: /clusters/dbox_migration_update_source_target/
// summary: Dbox migration update source target info
func (c *Cluster) ClusterDboxMigrationUpdateSourceTargetWithContext_GET(ctx context.Context) (core.Record, error) {
	resourcePath := "/clusters/dbox_migration_update_source_target/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxMigrationUpdateSourceTarget_GET
// method: GET
// url: /clusters/dbox_migration_update_source_target/
// summary: Dbox migration update source target info
func (c *Cluster) ClusterDboxMigrationUpdateSourceTarget_GET() (core.Record, error) {
	return c.ClusterDboxMigrationUpdateSourceTargetWithContext_GET(c.Rest.GetCtx())
}

// ClusterDboxMigrationUpdateSourceTargetWithContext_PATCH
// method: PATCH
// url: /clusters/dbox_migration_update_source_target/
// summary: Dbox migration update source target
//
// Body:
//   - source_ids: Source DBox ids
//   - target_ids: Target DBox ids
func (c *Cluster) ClusterDboxMigrationUpdateSourceTargetWithContext_PATCH(ctx context.Context, body core.Params) (core.Record, error) {
	resourcePath := "/clusters/dbox_migration_update_source_target/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxMigrationUpdateSourceTarget_PATCH
// method: PATCH
// url: /clusters/dbox_migration_update_source_target/
// summary: Dbox migration update source target
//
// Body:
//   - source_ids: Source DBox ids
//   - target_ids: Target DBox ids
func (c *Cluster) ClusterDboxMigrationUpdateSourceTarget_PATCH(body core.Params) (core.Record, error) {
	return c.ClusterDboxMigrationUpdateSourceTargetWithContext_PATCH(c.Rest.GetCtx(), body)
}

// ClusterDboxMigrationValidateStateWithContext_GET
// method: GET
// url: /clusters/dbox_migration_validate_state/
// summary: DBox migration validate state
func (c *Cluster) ClusterDboxMigrationValidateStateWithContext_GET(ctx context.Context) (core.Record, error) {
	resourcePath := "/clusters/dbox_migration_validate_state/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxMigrationValidateState_GET
// method: GET
// url: /clusters/dbox_migration_validate_state/
// summary: DBox migration validate state
func (c *Cluster) ClusterDboxMigrationValidateState_GET() (core.Record, error) {
	return c.ClusterDboxMigrationValidateStateWithContext_GET(c.Rest.GetCtx())
}

// ClusterDboxMigrationValidateWithContext_GET
// method: GET
// url: /clusters/dbox_migration_validate/
// summary: DBox migration validate
func (c *Cluster) ClusterDboxMigrationValidateWithContext_GET(ctx context.Context) (core.Record, error) {
	resourcePath := "/clusters/dbox_migration_validate/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxMigrationValidate_GET
// method: GET
// url: /clusters/dbox_migration_validate/
// summary: DBox migration validate
func (c *Cluster) ClusterDboxMigrationValidate_GET() (core.Record, error) {
	return c.ClusterDboxMigrationValidateWithContext_GET(c.Rest.GetCtx())
}

// ClusterDboxMigrationWithContext_POST
// method: POST
// url: /clusters/dbox_migration/
// summary: Dbox migration
//
// Body:
//   - allow_unhealthy_raid: Allow unhealthy RAID state
//   - dbox_ids: Source DBox ids
//   - nvram_section_layout: Optional NVRAM section layout for DBox expansion
//   - use_spare_mem: Use spare mem
func (c *Cluster) ClusterDboxMigrationWithContext_POST(ctx context.Context, body core.Params) (core.Record, error) {
	resourcePath := "/clusters/dbox_migration/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxMigration_POST
// method: POST
// url: /clusters/dbox_migration/
// summary: Dbox migration
//
// Body:
//   - allow_unhealthy_raid: Allow unhealthy RAID state
//   - dbox_ids: Source DBox ids
//   - nvram_section_layout: Optional NVRAM section layout for DBox expansion
//   - use_spare_mem: Use spare mem
func (c *Cluster) ClusterDboxMigration_POST(body core.Params) (core.Record, error) {
	return c.ClusterDboxMigrationWithContext_POST(c.Rest.GetCtx(), body)
}

// ClusterDboxesTotalCapacityWithContext_GET
// method: GET
// url: /clusters/dboxes_total_capacity/
// summary: DBoxes total capacity
//
// Params:
//   - ids: DBox ids separated by comma
func (c *Cluster) ClusterDboxesTotalCapacityWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/dboxes_total_capacity/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterDboxesTotalCapacity_GET
// method: GET
// url: /clusters/dboxes_total_capacity/
// summary: DBoxes total capacity
//
// Params:
//   - ids: DBox ids separated by comma
func (c *Cluster) ClusterDboxesTotalCapacity_GET(params core.Params) (core.Record, error) {
	return c.ClusterDboxesTotalCapacityWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterDeleteFolderWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/delete_folder/
// summary: Delete Cluster Folder
//
// Body:
//   - path: Folder path to delete
//   - tenant_id: Tenant ID
func (c *Cluster) ClusterDeleteFolderWithContext_DELETE(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "delete_folder")
	_, err := core.Request[core.Record](ctx, c, http.MethodDelete, resourcePath, nil, body)
	return err

}

// ClusterDeleteFolder_DELETE
// method: DELETE
// url: /clusters/{id}/delete_folder/
// summary: Delete Cluster Folder
//
// Body:
//   - path: Folder path to delete
//   - tenant_id: Tenant ID
func (c *Cluster) ClusterDeleteFolder_DELETE(id any, body core.Params) error {
	return c.ClusterDeleteFolderWithContext_DELETE(c.Rest.GetCtx(), id, body)
}

// ClusterExpandWithContext_POST
// method: POST
// url: /clusters/{id}/expand/
// summary: Expand Cluster
//
// Body:
//   - devices_mock: Devices Mock for NVRAM section layout (only for loopback)
//   - nvram_section_layout: NVRAM section layout
//   - skip_layout_validation: skip layout validation
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterExpandWithContext_POST(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "expand")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterExpand_POST
// method: POST
// url: /clusters/{id}/expand/
// summary: Expand Cluster
//
// Body:
//   - devices_mock: Devices Mock for NVRAM section layout (only for loopback)
//   - nvram_section_layout: NVRAM section layout
//   - skip_layout_validation: skip layout validation
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterExpand_POST(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterExpandWithContext_POST(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterGenerateUnfreezeTokenWithContext_POST
// method: POST
// url: /clusters/{id}/generate_unfreeze_token/
// summary: Generate Token to Unlock Indestructibility
//
// Body:
//   - password: Unfreeze password
func (c *Cluster) ClusterGenerateUnfreezeTokenWithContext_POST(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "generate_unfreeze_token")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterGenerateUnfreezeToken_POST
// method: POST
// url: /clusters/{id}/generate_unfreeze_token/
// summary: Generate Token to Unlock Indestructibility
//
// Body:
//   - password: Unfreeze password
func (c *Cluster) ClusterGenerateUnfreezeToken_POST(id any, body core.Params) (core.Record, error) {
	return c.ClusterGenerateUnfreezeTokenWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterGetShardExpansionStatusWithContext_GET
// method: GET
// url: /clusters/get_shard_expansion_status/
// summary: System shard expansion status
func (c *Cluster) ClusterGetShardExpansionStatusWithContext_GET(ctx context.Context) (core.Record, error) {
	resourcePath := "/clusters/get_shard_expansion_status/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterGetShardExpansionStatus_GET
// method: GET
// url: /clusters/get_shard_expansion_status/
// summary: System shard expansion status
func (c *Cluster) ClusterGetShardExpansionStatus_GET() (core.Record, error) {
	return c.ClusterGetShardExpansionStatusWithContext_GET(c.Rest.GetCtx())
}

// ClusterGetSnapshotedPathsWithContext_GET
// method: GET
// url: /clusters/get_snapshoted_paths/
// summary: Return Paths that have Snapshots
//
// Params:
//   - tenant_id: Tenant ID
func (c *Cluster) ClusterGetSnapshotedPathsWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/get_snapshoted_paths/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterGetSnapshotedPaths_GET
// method: GET
// url: /clusters/get_snapshoted_paths/
// summary: Return Paths that have Snapshots
//
// Params:
//   - tenant_id: Tenant ID
func (c *Cluster) ClusterGetSnapshotedPaths_GET(params core.Params) (core.Record, error) {
	return c.ClusterGetSnapshotedPathsWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterListCloneSnapshotedPathsRemoteWithContext_GET
// method: GET
// url: /clusters/list_clone_snapshoted_paths_remote/
// summary: List snapshots on a remote replication peer
//
// Params:
//   - remote_target_guid: remote target GUID
//   - handle: Provide the handle from a GET /cluster/list_snapshoted_paths_remote/ response
//   - start_snapshot_id: Start snapshot ID
func (c *Cluster) ClusterListCloneSnapshotedPathsRemoteWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/list_clone_snapshoted_paths_remote/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListCloneSnapshotedPathsRemote_GET
// method: GET
// url: /clusters/list_clone_snapshoted_paths_remote/
// summary: List snapshots on a remote replication peer
//
// Params:
//   - remote_target_guid: remote target GUID
//   - handle: Provide the handle from a GET /cluster/list_snapshoted_paths_remote/ response
//   - start_snapshot_id: Start snapshot ID
func (c *Cluster) ClusterListCloneSnapshotedPathsRemote_GET(params core.Params) (core.Record, error) {
	return c.ClusterListCloneSnapshotedPathsRemoteWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterListOpenProtocolHandlesWithContext_GET
// method: GET
// url: /clusters/list_open_protocol_handles/
// summary: Query open protocol filehandles
//
// Params:
//   - file_path: File path
//   - tenant_guid: Tenant GUID
func (c *Cluster) ClusterListOpenProtocolHandlesWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/list_open_protocol_handles/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListOpenProtocolHandles_GET
// method: GET
// url: /clusters/list_open_protocol_handles/
// summary: Query open protocol filehandles
//
// Params:
//   - file_path: File path
//   - tenant_guid: Tenant GUID
func (c *Cluster) ClusterListOpenProtocolHandles_GET(params core.Params) (core.Record, error) {
	return c.ClusterListOpenProtocolHandlesWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterListPrefetchPathsInfoWithContext_GET
// method: GET
// url: /clusters/list_prefetch_paths_info/
// summary: List Prefetch Path Information
func (c *Cluster) ClusterListPrefetchPathsInfoWithContext_GET(ctx context.Context) (core.Record, error) {
	resourcePath := "/clusters/list_prefetch_paths_info/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListPrefetchPathsInfo_GET
// method: GET
// url: /clusters/list_prefetch_paths_info/
// summary: List Prefetch Path Information
func (c *Cluster) ClusterListPrefetchPathsInfo_GET() (core.Record, error) {
	return c.ClusterListPrefetchPathsInfoWithContext_GET(c.Rest.GetCtx())
}

// ClusterListSmbClientConnectionsWithContext_GET
// method: GET
// url: /clusters/list_smb_client_connections/
// summary: Query SMB client connections
//
// Params:
//   - client_ip: Client IP
//   - tenant_id: Filter by tenant. Specify tenant ID.
func (c *Cluster) ClusterListSmbClientConnectionsWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/list_smb_client_connections/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListSmbClientConnections_GET
// method: GET
// url: /clusters/list_smb_client_connections/
// summary: Query SMB client connections
//
// Params:
//   - client_ip: Client IP
//   - tenant_id: Filter by tenant. Specify tenant ID.
func (c *Cluster) ClusterListSmbClientConnections_GET(params core.Params) (core.Record, error) {
	return c.ClusterListSmbClientConnectionsWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterListSmbOpenFilesWithContext_GET
// method: GET
// url: /clusters/list_smb_open_files/
// summary: Query SMB open files
//
// Params:
//   - file_path: File path
//   - tenant_guid: Tenant GUID
func (c *Cluster) ClusterListSmbOpenFilesWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/list_smb_open_files/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListSmbOpenFiles_GET
// method: GET
// url: /clusters/list_smb_open_files/
// summary: Query SMB open files
//
// Params:
//   - file_path: File path
//   - tenant_guid: Tenant GUID
func (c *Cluster) ClusterListSmbOpenFiles_GET(params core.Params) (core.Record, error) {
	return c.ClusterListSmbOpenFilesWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterListSnapshotedPathsRemoteWithContext_GET
// method: GET
// url: /clusters/list_snapshoted_paths_remote/
// summary: List snapshoted paths on remote target
//
// Params:
//   - remote_target_guid: The GUID of the remote target, which you can obtain from a GET /replicationtargets/ request
//   - remote_tenant_guid: The GUID of the remote tenant
func (c *Cluster) ClusterListSnapshotedPathsRemoteWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/list_snapshoted_paths_remote/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListSnapshotedPathsRemote_GET
// method: GET
// url: /clusters/list_snapshoted_paths_remote/
// summary: List snapshoted paths on remote target
//
// Params:
//   - remote_target_guid: The GUID of the remote target, which you can obtain from a GET /replicationtargets/ request
//   - remote_tenant_guid: The GUID of the remote tenant
func (c *Cluster) ClusterListSnapshotedPathsRemote_GET(params core.Params) (core.Record, error) {
	return c.ClusterListSnapshotedPathsRemoteWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterListTenantsRemoteWithContext_GET
// method: GET
// url: /clusters/list_tenants_remote/
// summary: List tenants on remote target
//
// Params:
//   - remote_target_guid: remote target GUID
func (c *Cluster) ClusterListTenantsRemoteWithContext_GET(ctx context.Context, params core.Params) (core.Record, error) {
	resourcePath := "/clusters/list_tenants_remote/"
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterListTenantsRemote_GET
// method: GET
// url: /clusters/list_tenants_remote/
// summary: List tenants on remote target
//
// Params:
//   - remote_target_guid: remote target GUID
func (c *Cluster) ClusterListTenantsRemote_GET(params core.Params) (core.Record, error) {
	return c.ClusterListTenantsRemoteWithContext_GET(c.Rest.GetCtx(), params)
}

// ClusterLocksWithContext_POST
// method: POST
// url: /clusters/{id}/locks/
// summary: List NLM Locks
//
// Body:
//   - direction: Pagination direction.
//   - lock_type: Lock type. Specify if unlock_type is SINGLE.
//   - path: The full path to a locked file, formed as: VIEW_PATH/FILE_PATH, where VIEW_PATH is the VAST Cluster view path, and FILE_PATH is the client path to a locked file, relative to the mount point.
//   - tenant_id
//   - unlock_id: Unlock ID. Specify if unlock_type is SINGLE.
//   - unlock_type: The type of unlock operation to perform. 'SINGLE' unlocks a single specified lock, 'ALL' unlocks all locks.
func (c *Cluster) ClusterLocksWithContext_POST(ctx context.Context, id any, body core.Params) (core.RecordSet, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "locks")
	result, err := core.Request[core.RecordSet](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil

}

// ClusterLocks_POST
// method: POST
// url: /clusters/{id}/locks/
// summary: List NLM Locks
//
// Body:
//   - direction: Pagination direction.
//   - lock_type: Lock type. Specify if unlock_type is SINGLE.
//   - path: The full path to a locked file, formed as: VIEW_PATH/FILE_PATH, where VIEW_PATH is the VAST Cluster view path, and FILE_PATH is the client path to a locked file, relative to the mount point.
//   - tenant_id
//   - unlock_id: Unlock ID. Specify if unlock_type is SINGLE.
//   - unlock_type: The type of unlock operation to perform. 'SINGLE' unlocks a single specified lock, 'ALL' unlocks all locks.
func (c *Cluster) ClusterLocks_POST(id any, body core.Params) (core.RecordSet, error) {
	return c.ClusterLocksWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterNotifyNewVersionWithContext_POST
// method: POST
// url: /clusters/{id}/notify_new_version/
// summary: Notify of New Version Available for Download
//
// Body:
//   - bmc_fw_version: bmc_fw_version
//   - build: build
//   - nvram_version: nvram_version
//   - os_version: os_version
//   - s3_url: link to download new version
//   - ssd_version: ssd_version
//   - sys_version: sys_version
func (c *Cluster) ClusterNotifyNewVersionWithContext_POST(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "notify_new_version")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterNotifyNewVersion_POST
// method: POST
// url: /clusters/{id}/notify_new_version/
// summary: Notify of New Version Available for Download
//
// Body:
//   - bmc_fw_version: bmc_fw_version
//   - build: build
//   - nvram_version: nvram_version
//   - os_version: os_version
//   - s3_url: link to download new version
//   - ssd_version: ssd_version
//   - sys_version: sys_version
func (c *Cluster) ClusterNotifyNewVersion_POST(id any, body core.Params) (core.Record, error) {
	return c.ClusterNotifyNewVersionWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterPreUpgradeValidationExceptionsWithContext_GET
// method: GET
// url: /clusters/{id}/pre_upgrade_validation_exceptions/
// summary: Run Pre-Upgrade Validation
func (c *Cluster) ClusterPreUpgradeValidationExceptionsWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "pre_upgrade_validation_exceptions")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterPreUpgradeValidationExceptions_GET
// method: GET
// url: /clusters/{id}/pre_upgrade_validation_exceptions/
// summary: Run Pre-Upgrade Validation
func (c *Cluster) ClusterPreUpgradeValidationExceptions_GET(id any) (core.Record, error) {
	return c.ClusterPreUpgradeValidationExceptionsWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterReleaseRecursiveLocksWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/release_recursive_locks/
// summary: Deletes NLM Locks Recursively
//
// Body:
//   - lock_type: Lock type. Specify if unlock_type is SINGLE.
//   - path: The full path to a locked file, formed as: VIEW_PATH/FILE_PATH, where VIEW_PATH is the VAST Cluster view path, and FILE_PATH is the client path to a locked file, relative to the mount point.
//   - tenant_id
//   - unlock_id: Unlock ID. Specify if unlock_type is SINGLE.
//   - unlock_type: The type of unlock operation to perform. 'SINGLE' unlocks a single specified lock, 'ALL' unlocks all locks.
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterReleaseRecursiveLocksWithContext_DELETE(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "release_recursive_locks")
	result, err := core.Request[core.Record](ctx, c, http.MethodDelete, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterReleaseRecursiveLocks_DELETE
// method: DELETE
// url: /clusters/{id}/release_recursive_locks/
// summary: Deletes NLM Locks Recursively
//
// Body:
//   - lock_type: Lock type. Specify if unlock_type is SINGLE.
//   - path: The full path to a locked file, formed as: VIEW_PATH/FILE_PATH, where VIEW_PATH is the VAST Cluster view path, and FILE_PATH is the client path to a locked file, relative to the mount point.
//   - tenant_id
//   - unlock_id: Unlock ID. Specify if unlock_type is SINGLE.
//   - unlock_type: The type of unlock operation to perform. 'SINGLE' unlocks a single specified lock, 'ALL' unlocks all locks.
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterReleaseRecursiveLocks_DELETE(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterReleaseRecursiveLocksWithContext_DELETE(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterResumeDeployWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/resume_deploy/
// summary: Resume failed deploy
//
// Body:
//
//	< not declared in schema >
func (c *Cluster) ClusterResumeDeployWithContext_PATCH(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "resume_deploy")
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterResumeDeploy_PATCH
// method: PATCH
// url: /clusters/{id}/resume_deploy/
// summary: Resume failed deploy
//
// Body:
//
//	< not declared in schema >
func (c *Cluster) ClusterResumeDeploy_PATCH(id any, body core.Params) (core.Record, error) {
	return c.ClusterResumeDeployWithContext_PATCH(c.Rest.GetCtx(), id, body)
}

// ClusterRotateMasterEncryptionGroupKeyWithContext_POST
// method: POST
// url: /clusters/rotate_master_encryption_group_key/
// summary: Rotate master encryption group key.
//
// Body:
//
//	< not declared in schema >
func (c *Cluster) ClusterRotateMasterEncryptionGroupKeyWithContext_POST(ctx context.Context, body core.Params) error {
	resourcePath := "/clusters/rotate_master_encryption_group_key/"
	_, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	return err

}

// ClusterRotateMasterEncryptionGroupKey_POST
// method: POST
// url: /clusters/rotate_master_encryption_group_key/
// summary: Rotate master encryption group key.
//
// Body:
//
//	< not declared in schema >
func (c *Cluster) ClusterRotateMasterEncryptionGroupKey_POST(body core.Params) error {
	return c.ClusterRotateMasterEncryptionGroupKeyWithContext_POST(c.Rest.GetCtx(), body)
}

// ClusterRpcWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/rpc/
// summary: This endpoint runs cluster rpc.
//
// Body:
//   - module_type: Module type for the commander connection
//   - params: params for rpc call
//   - rpc: rpc name to execute
func (c *Cluster) ClusterRpcWithContext_PATCH(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "rpc")
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterRpc_PATCH
// method: PATCH
// url: /clusters/{id}/rpc/
// summary: This endpoint runs cluster rpc.
//
// Body:
//   - module_type: Module type for the commander connection
//   - params: params for rpc call
//   - rpc: rpc name to execute
func (c *Cluster) ClusterRpc_PATCH(id any, body core.Params) (core.Record, error) {
	return c.ClusterRpcWithContext_PATCH(c.Rest.GetCtx(), id, body)
}

// ClusterRunHardwareCheckWithContext_PATCH
// method: PATCH
// url: /clusters/run_hardware_check/
// summary: Run Hardware Validations
//
// Body:
//   - bmc_upgrade: is bmc upgrade
//   - force: force
//   - skip_hw_check: Skip hardware related checks
//   - skip_os_upgrade: skip os upgrade related checks
//   - skip_sw_validations: Skip SW validations
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterRunHardwareCheckWithContext_PATCH(ctx context.Context, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := "/clusters/run_hardware_check/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterRunHardwareCheck_PATCH
// method: PATCH
// url: /clusters/run_hardware_check/
// summary: Run Hardware Validations
//
// Body:
//   - bmc_upgrade: is bmc upgrade
//   - force: force
//   - skip_hw_check: Skip hardware related checks
//   - skip_os_upgrade: skip os upgrade related checks
//   - skip_sw_validations: Skip SW validations
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterRunHardwareCheck_PATCH(body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterRunHardwareCheckWithContext_PATCH(c.Rest.GetCtx(), body, waitTimeout)
}

// ClusterSetCertificatesWithContext_POST
// method: POST
// url: /clusters/{id}/set_certificates/
// summary: Update EKM certificates
//
// Body:
//   - ekm_auth_domain: Auth domain (Thales)
//   - ekm_bypass_validation: Bypass key and cert validation (VMS)
//   - ekm_ca_certificate: EKM CA certificate
//   - ekm_certificate: EKM certificate
//   - ekm_domain: Domain (Thales)
//   - ekm_private_key: EKM private key
//   - ekm_proxy_address: Thales EKM proxy address: https://proxy-address:port
//   - ekm_servers: List of EKM servers: 10.0.0.1:5696,11.0.0.1:5697
//   - encryption_type: Encryption type
func (c *Cluster) ClusterSetCertificatesWithContext_POST(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "set_certificates")
	_, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	return err

}

// ClusterSetCertificates_POST
// method: POST
// url: /clusters/{id}/set_certificates/
// summary: Update EKM certificates
//
// Body:
//   - ekm_auth_domain: Auth domain (Thales)
//   - ekm_bypass_validation: Bypass key and cert validation (VMS)
//   - ekm_ca_certificate: EKM CA certificate
//   - ekm_certificate: EKM certificate
//   - ekm_domain: Domain (Thales)
//   - ekm_private_key: EKM private key
//   - ekm_proxy_address: Thales EKM proxy address: https://proxy-address:port
//   - ekm_servers: List of EKM servers: 10.0.0.1:5696,11.0.0.1:5697
//   - encryption_type: Encryption type
func (c *Cluster) ClusterSetCertificates_POST(id any, body core.Params) error {
	return c.ClusterSetCertificatesWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterSetDriveFwUpgradeWithContext_POST
// method: POST
// url: /clusters/{id}/set_drive_fw_upgrade/
// summary: Set true/false to upgrade non-active drives fw
//
// Body:
//   - enabled: Enable/disable flag
func (c *Cluster) ClusterSetDriveFwUpgradeWithContext_POST(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "set_drive_fw_upgrade")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterSetDriveFwUpgrade_POST
// method: POST
// url: /clusters/{id}/set_drive_fw_upgrade/
// summary: Set true/false to upgrade non-active drives fw
//
// Body:
//   - enabled: Enable/disable flag
func (c *Cluster) ClusterSetDriveFwUpgrade_POST(id any, body core.Params) (core.Record, error) {
	return c.ClusterSetDriveFwUpgradeWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterSetPasswordWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/set_password/
// summary: Change Cluster Passwords
//
// Body:
//   - password: The new given password
//   - username: The given username for password change
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterSetPasswordWithContext_PATCH(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "set_password")
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterSetPassword_PATCH
// method: PATCH
// url: /clusters/{id}/set_password/
// summary: Change Cluster Passwords
//
// Body:
//   - password: The new given password
//   - username: The given username for password change
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterSetPassword_PATCH(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterSetPasswordWithContext_PATCH(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterShardExpandWithContext_POST
// method: POST
// url: /clusters/shard_expand/
// summary: Shard expansion
//
// Body:
//   - dr_shard_count: DR shard count
//   - dr_wb_shard_count: DR WB shard count
//   - estore_shard_count: EStore shard count
//   - force: Force shard expansion. Use if you want to run shard expansion even though shards are denylisted (indicated by MAINTENANCE_DENYLIST_EXISTS in error code when running without 'force').
func (c *Cluster) ClusterShardExpandWithContext_POST(ctx context.Context, body core.Params) (core.Record, error) {
	resourcePath := "/clusters/shard_expand/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterShardExpand_POST
// method: POST
// url: /clusters/shard_expand/
// summary: Shard expansion
//
// Body:
//   - dr_shard_count: DR shard count
//   - dr_wb_shard_count: DR WB shard count
//   - estore_shard_count: EStore shard count
//   - force: Force shard expansion. Use if you want to run shard expansion even though shards are denylisted (indicated by MAINTENANCE_DENYLIST_EXISTS in error code when running without 'force').
func (c *Cluster) ClusterShardExpand_POST(body core.Params) (core.Record, error) {
	return c.ClusterShardExpandWithContext_POST(c.Rest.GetCtx(), body)
}

// ClusterStopUpgradeWithContext_POST
// method: POST
// url: /clusters/{id}/stop_upgrade/
// summary: Stop Running Upgrade
//
// Body:
//
//	< not declared in schema >
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterStopUpgradeWithContext_POST(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "stop_upgrade")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterStopUpgrade_POST
// method: POST
// url: /clusters/{id}/stop_upgrade/
// summary: Stop Running Upgrade
//
// Body:
//
//	< not declared in schema >
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterStopUpgrade_POST(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterStopUpgradeWithContext_POST(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterSystemSettingsWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/system_settings/
// summary: Set Cluster System Settings
//
// Body:
//   - settings: system settings to modify
func (c *Cluster) ClusterSystemSettingsWithContext_PATCH(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "system_settings")
	_, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	return err

}

// ClusterSystemSettings_PATCH
// method: PATCH
// url: /clusters/{id}/system_settings/
// summary: Set Cluster System Settings
//
// Body:
//   - settings: system settings to modify
func (c *Cluster) ClusterSystemSettings_PATCH(id any, body core.Params) error {
	return c.ClusterSystemSettingsWithContext_PATCH(c.Rest.GetCtx(), id, body)
}

// ClusterUnfreezeWithContext_POST
// method: POST
// url: /clusters/{id}/unfreeze/
// summary: Unfreeze Cluster
//
// Body:
//   - token: Token
func (c *Cluster) ClusterUnfreezeWithContext_POST(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "unfreeze")
	_, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	return err

}

// ClusterUnfreeze_POST
// method: POST
// url: /clusters/{id}/unfreeze/
// summary: Unfreeze Cluster
//
// Body:
//   - token: Token
func (c *Cluster) ClusterUnfreeze_POST(id any, body core.Params) error {
	return c.ClusterUnfreezeWithContext_POST(c.Rest.GetCtx(), id, body)
}

// ClusterUpgradeOptaneWithContext_POST
// method: POST
// url: /clusters/{id}/upgrade_optane/
// summary: Upgrade Optane NVRAM
//
// Body:
//   - force: Force upgrade regardless of version
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeOptaneWithContext_POST(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade_optane")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterUpgradeOptane_POST
// method: POST
// url: /clusters/{id}/upgrade_optane/
// summary: Upgrade Optane NVRAM
//
// Body:
//   - force: Force upgrade regardless of version
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeOptane_POST(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterUpgradeOptaneWithContext_POST(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterUpgradeSsdWithContext_POST
// method: POST
// url: /clusters/{id}/upgrade_ssd/
// summary: Upgrade SSD
//
// Body:
//   - force: Forces upgrade regardless of version
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeSsdWithContext_POST(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade_ssd")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterUpgradeSsd_POST
// method: POST
// url: /clusters/{id}/upgrade_ssd/
// summary: Upgrade SSD
//
// Body:
//   - force: Forces upgrade regardless of version
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeSsd_POST(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterUpgradeSsdWithContext_POST(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterUpgradeWithoutFileWithContext_POST
// method: POST
// url: /clusters/{id}/upgrade_without_file/
// summary: Upgrade Cluster from Pre-Uploaded Bundle
//
// Body:
//   - bmc_upgrade: BMC upgrade
//   - cnodes_batch_size_percentage: Overrides default percentage of CNodes to upgrade in parallel. Max 50
//   - dnodes_batch_size_percentage: Overrides default percentage of DNodes to upgrade in parallel. Max 37.5. Not relevant during os upgrade
//   - dpus_batch_size_percentage: Overrides default percentage of DPUs to upgrade in parallel. Max 37.5.
//   - drives_fw_upgrade: Upgrade FW for SSD/SCMs exclusively
//   - enable_dr: Enables data reduction (DR) for a cluster without DR enabled prior to upgrade
//   - force: Forces upgrade regardless of version or upgrade state
//   - fw_upgrade: Upgrade FWs: BMC, MCU, PCI, NIC
//   - isolcpus: Resets the configuration of isolated CPUs according to a formula
//   - os_upgrade: Performs OS upgrade on CNodes and DNodes in addition to upgrading core platform build
//   - skip_hw_check: Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade.
//   - skip_sw_validations: Skips SW validations (e.g. deny list)
//   - vms_only_upgrade: Forces upgrade of VMS only
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeWithoutFileWithContext_POST(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade_without_file")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterUpgradeWithoutFile_POST
// method: POST
// url: /clusters/{id}/upgrade_without_file/
// summary: Upgrade Cluster from Pre-Uploaded Bundle
//
// Body:
//   - bmc_upgrade: BMC upgrade
//   - cnodes_batch_size_percentage: Overrides default percentage of CNodes to upgrade in parallel. Max 50
//   - dnodes_batch_size_percentage: Overrides default percentage of DNodes to upgrade in parallel. Max 37.5. Not relevant during os upgrade
//   - dpus_batch_size_percentage: Overrides default percentage of DPUs to upgrade in parallel. Max 37.5.
//   - drives_fw_upgrade: Upgrade FW for SSD/SCMs exclusively
//   - enable_dr: Enables data reduction (DR) for a cluster without DR enabled prior to upgrade
//   - force: Forces upgrade regardless of version or upgrade state
//   - fw_upgrade: Upgrade FWs: BMC, MCU, PCI, NIC
//   - isolcpus: Resets the configuration of isolated CPUs according to a formula
//   - os_upgrade: Performs OS upgrade on CNodes and DNodes in addition to upgrading core platform build
//   - skip_hw_check: Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade.
//   - skip_sw_validations: Skips SW validations (e.g. deny list)
//   - vms_only_upgrade: Forces upgrade of VMS only
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeWithoutFile_POST(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterUpgradeWithoutFileWithContext_POST(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterUpgradeWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/upgrade/
// summary: Upgrade Cluster
//
// Body:
//   - bmc_upgrade: BMC upgrade
//   - build: Specifies the build for upgrade
//   - drives_fw_upgrade: Exclusive flag to perform SSD/SCM FW upgrade
//   - enable_dr: Enables data reduction (DR) for a cluster without DR enabled prior to upgrade
//   - force: Forces upgrade regardless of version or upgrade state
//   - os_upgrade: OS upgrade
//   - prepare: Pull docker images only
//   - skip_hw_check: Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade.
//   - skip_sw_validations: Skips SW validations (e.g. deny list)
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgradeWithContext_PATCH(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upgrade")
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterUpgrade_PATCH
// method: PATCH
// url: /clusters/{id}/upgrade/
// summary: Upgrade Cluster
//
// Body:
//   - bmc_upgrade: BMC upgrade
//   - build: Specifies the build for upgrade
//   - drives_fw_upgrade: Exclusive flag to perform SSD/SCM FW upgrade
//   - enable_dr: Enables data reduction (DR) for a cluster without DR enabled prior to upgrade
//   - force: Forces upgrade regardless of version or upgrade state
//   - os_upgrade: OS upgrade
//   - prepare: Pull docker images only
//   - skip_hw_check: Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade.
//   - skip_sw_validations: Skips SW validations (e.g. deny list)
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUpgrade_PATCH(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterUpgradeWithContext_PATCH(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterUploadFromS3WithContext_POST
// method: POST
// url: /clusters/{id}/upload_from_s3/
// summary: Upload Upgrade Bundle from S3 URL
//
// Body:
//   - s3_url: S3 URL to upgrade package. If not provided, will be taken from db
//   - skip_hw_check: Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade.
//   - skip_prepare: Skips preparing the cluster for upgrade, including: pre-upgrade validations, copying the bundle to other hosts, and pulling the image on all CNodes.
//   - skip_sw_validations: Skips SW validations (e.g. deny list)
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUploadFromS3WithContext_POST(ctx context.Context, id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "upload_from_s3")
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterUploadFromS3_POST
// method: POST
// url: /clusters/{id}/upload_from_s3/
// summary: Upload Upgrade Bundle from S3 URL
//
// Body:
//   - s3_url: S3 URL to upgrade package. If not provided, will be taken from db
//   - skip_hw_check: Skips validation of hardware component health. Use with caution since component redundancy is important in NDU. Do not use with OS upgrade.
//   - skip_prepare: Skips preparing the cluster for upgrade, including: pre-upgrade validations, copying the bundle to other hosts, and pulling the image on all CNodes.
//   - skip_sw_validations: Skips SW validations (e.g. deny list)
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterUploadFromS3_POST(id any, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterUploadFromS3WithContext_POST(c.Rest.GetCtx(), id, body, waitTimeout)
}

// ClusterVastDbWithContext_GET
// method: GET
// url: /clusters/{id}/vast_db/
// summary: Show Cluster Vast DB Settings
func (c *Cluster) ClusterVastDbWithContext_GET(ctx context.Context, id any) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vast_db")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, nil, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterVastDb_GET
// method: GET
// url: /clusters/{id}/vast_db/
// summary: Show Cluster Vast DB Settings
func (c *Cluster) ClusterVastDb_GET(id any) (core.Record, error) {
	return c.ClusterVastDbWithContext_GET(c.Rest.GetCtx(), id)
}

// ClusterVastDbWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/vast_db/
// summary: Modify Cluster Vast DB Settings
//
// Body:
//   - vast_db_splits: The number of splits used for query_data scanning speed. Default 8.
//   - vast_db_sub_splits: The number of sub-splits used for query_data scanning speed. Default 8.
func (c *Cluster) ClusterVastDbWithContext_PATCH(ctx context.Context, id any, body core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vast_db")
	result, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterVastDb_PATCH
// method: PATCH
// url: /clusters/{id}/vast_db/
// summary: Modify Cluster Vast DB Settings
//
// Body:
//   - vast_db_splits: The number of splits used for query_data scanning speed. Default 8.
//   - vast_db_sub_splits: The number of sub-splits used for query_data scanning speed. Default 8.
func (c *Cluster) ClusterVastDb_PATCH(id any, body core.Params) (core.Record, error) {
	return c.ClusterVastDbWithContext_PATCH(c.Rest.GetCtx(), id, body)
}

// ClusterVsettingsWithContext_DELETE
// method: DELETE
// url: /clusters/{id}/vsettings/
// summary: Delete Cluster VSetting by key
//
// Body:
//   - key: vsetting key
func (c *Cluster) ClusterVsettingsWithContext_DELETE(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vsettings")
	_, err := core.Request[core.Record](ctx, c, http.MethodDelete, resourcePath, nil, body)
	return err

}

// ClusterVsettings_DELETE
// method: DELETE
// url: /clusters/{id}/vsettings/
// summary: Delete Cluster VSetting by key
//
// Body:
//   - key: vsetting key
func (c *Cluster) ClusterVsettings_DELETE(id any, body core.Params) error {
	return c.ClusterVsettingsWithContext_DELETE(c.Rest.GetCtx(), id, body)
}

// ClusterVsettingsWithContext_GET
// method: GET
// url: /clusters/{id}/vsettings/
// summary: Show or list cluster vsettings
//
// Params:
//   - key: VSetting key
func (c *Cluster) ClusterVsettingsWithContext_GET(ctx context.Context, id any, params core.Params) (core.Record, error) {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vsettings")
	result, err := core.Request[core.Record](ctx, c, http.MethodGet, resourcePath, params, nil)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ClusterVsettings_GET
// method: GET
// url: /clusters/{id}/vsettings/
// summary: Show or list cluster vsettings
//
// Params:
//   - key: VSetting key
func (c *Cluster) ClusterVsettings_GET(id any, params core.Params) (core.Record, error) {
	return c.ClusterVsettingsWithContext_GET(c.Rest.GetCtx(), id, params)
}

// ClusterVsettingsWithContext_PATCH
// method: PATCH
// url: /clusters/{id}/vsettings/
// summary: Modify Cluster VSettings
//
// Body:
//   - vsettings
func (c *Cluster) ClusterVsettingsWithContext_PATCH(ctx context.Context, id any, body core.Params) error {
	resourcePath := core.BuildResourcePathWithID("clusters", id, "vsettings")
	_, err := core.Request[core.Record](ctx, c, http.MethodPatch, resourcePath, nil, body)
	return err

}

// ClusterVsettings_PATCH
// method: PATCH
// url: /clusters/{id}/vsettings/
// summary: Modify Cluster VSettings
//
// Body:
//   - vsettings
func (c *Cluster) ClusterVsettings_PATCH(id any, body core.Params) error {
	return c.ClusterVsettingsWithContext_PATCH(c.Rest.GetCtx(), id, body)
}

// ClusterWipeWithContext_POST
// method: POST
// url: /clusters/wipe/
// summary: Stop Cluster s/w on All Nodes
//
// Body:
//   - cnode_list: The list of C-Nodes
//   - dnode_list: The list of DNodes
//   - loopback: Loopback (single node) installation
//   - loopback_ip: Loopback IP
//   - loopback_user: Loopback User
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterWipeWithContext_POST(ctx context.Context, body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	resourcePath := "/clusters/wipe/"
	result, err := core.Request[core.Record](ctx, c, http.MethodPost, resourcePath, nil, body)
	if err != nil {
		return nil, err
	}

	return MaybeWaitAsyncResultWithContext(ctx, result, c.Rest, waitTimeout)

}

// ClusterWipe_POST
// method: POST
// url: /clusters/wipe/
// summary: Stop Cluster s/w on All Nodes
//
// Body:
//   - cnode_list: The list of C-Nodes
//   - dnode_list: The list of DNodes
//   - loopback: Loopback (single node) installation
//   - loopback_ip: Loopback IP
//   - loopback_user: Loopback User
//
// Parameters:
//   - waitTimeout: If 0, returns immediately without waiting (async). Otherwise, waits for task completion with the specified timeout.
func (c *Cluster) ClusterWipe_POST(body core.Params, waitTimeout time.Duration) (*AsyncResult, error) {
	return c.ClusterWipeWithContext_POST(c.Rest.GetCtx(), body, waitTimeout)
}
